/**
 *   @file  mmwave.h
 *
 *   @brief
 *      This is the high level API which is used to abstract the mmWave
 *      link API and allow application developers to be abstracted from
 *      the lower level complexities.
 *
 *  \par
 *  NOTE:
 *      (C) Copyright 2016-2021 Texas Instruments, Inc.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/** @defgroup MMWAVE      mmWave API
 */
#ifndef MMWAVE_H
#define MMWAVE_H

#include <stdbool.h>

/* mmWave SDK Include Files: */
#include <mmwavelink/mmwavelink.h>

#include <common/mmwave_error.h>
#include <drivers/crc.h>

#include <drivers/hw_include/soc_config.h>

/**
@defgroup MMWAVE_CTRL_EXTERNAL_FUNCTION            mmWave External Functions
@ingroup MMWAVE
@brief
*   The section has a list of all the exported API which the applications need to
*   invoke in order to use the driver
*/
/**
@defgroup MMWAVE_EXTERNAL_DATA_STRUCTURE      mmWave External Data Structures
@ingroup MMWAVE
@brief
*   The section has a list of all the data structures which are exposed to the
*   application
*/
/**
@defgroup MMWAVE_EXTERNAL_DEFINITIONS      mmWave External Defintions
@ingroup MMWAVE
@brief
*   The section has a list of all external definitions which are exposed by the
*   mmWave module.
*/
/**
@defgroup MMWAVE_ERROR_CODE                   mmWave Error Codes
@ingroup MMWAVE
@brief
*   The section has a list of all the error codes which are generated by the module
*/
/**
@defgroup MMWAVE_INTERNAL_FUNCTION            mmWave Internal Functions
@ingroup MMWAVE
@brief
*   The section has a list of all internal API which are not exposed to the external
*   applications.
*/
/**
@defgroup MMWAVE_INTERNAL_DATA_STRUCTURE      mmWave Internal Data Structures
@ingroup MMWAVE
@brief
*   The section has a list of all internal data structures which are used internally
*   by the mmWave module.
*/
/**
@defgroup MMWAVE_INTERNAL_DEFINITIONS      mmWave Internal Defintions
@ingroup MMWAVE
@brief
*   The section has a list of all internal definitions which are used internally
*   by the mmWave module.
*/

#ifdef __cplusplus
extern "C" {
#endif

/** @addtogroup MMWAVE_ERROR_CODE
 *  Base error code for the mmWave module is defined in the
 *  \include ti/common/mmwave_error.h
 @{ */

/**
 * @brief   Error Code: Invalid argument
 */
#define MMWAVE_EINVAL                   (MMWAVE_ERRNO_BASE-1)

/**
 * @brief   Error Code: mmWave link initialization failed
 */
#define MMWAVE_EINIT                    (MMWAVE_ERRNO_BASE-2)

/**
 * @brief   Error Code: mmWave link not supported
 */
#define MMWAVE_ENOTSUP                  (MMWAVE_ERRNO_BASE-3)

/**
 * @brief   Error Code: mmWave link channel configuration failed
 */
#define MMWAVE_ECHCFG                   (MMWAVE_ERRNO_BASE-4)

/**
 * @brief   Error Code: mmWave link ADC configuration failed
 */
#define MMWAVE_EADCCFG                  (MMWAVE_ERRNO_BASE-5)

/**
 * @brief   Error Code: mmWave link Power configuration failed
 */
#define MMWAVE_EPOWERCFG                (MMWAVE_ERRNO_BASE-6)

/**
 * @brief   Error Code: mmWave link RF initialization failed
 */
#define MMWAVE_ERFINIT                  (MMWAVE_ERRNO_BASE-7)

/**
 * @brief   Error Code: mmWave link profile configuration failed
 */
#define MMWAVE_EPROFILECFG              (MMWAVE_ERRNO_BASE-8)

/**
 * @brief   Error Code: mmWave link chirp configuration failed
 */
#define MMWAVE_ECHIRPCFG                (MMWAVE_ERRNO_BASE-9)

/**
 * @brief   Error Code: mmWave link frame configuration failed
 */
#define MMWAVE_EFRAMECFG                (MMWAVE_ERRNO_BASE-10)

/**
 * @brief   Error Code: mmWave link PLL caliberation failed
 */
#define MMWAVE_EPLLCFG                  (MMWAVE_ERRNO_BASE-11)

/**
 * @brief   Error Code: mmWave link sensor failed
 */
#define MMWAVE_ESENSOR                  (MMWAVE_ERRNO_BASE-12)

/**
 * @brief   Error Code: OS Porting layer services failed
 */
#define MMWAVE_EOS                      (MMWAVE_ERRNO_BASE-13)

/**
 * @brief   Error Code: mmWave Link version error
 */
#define MMWAVE_EVERSION                 (MMWAVE_ERRNO_BASE-14)

/**
 * @brief   Error Code: mmWave message processing error
 */
#define MMWAVE_EMSG                     (MMWAVE_ERRNO_BASE-15)

/**
 * @brief   Error Code: mmWave deinitialization error
 */
#define MMWAVE_EDEINIT                  (MMWAVE_ERRNO_BASE-16)

/**
 * @brief   Error Code: mmWave link BSS calibration configuration failed
 */
#define MMWAVE_ECALCFG                  (MMWAVE_ERRNO_BASE-19)

/**
 * @brief   Error Code: mmWave link BSS calibration init
 */
#define MMWAVE_ECALINIT                 (MMWAVE_ERRNO_BASE-20)

/**
 * @brief   Error Code: mmWave link BSS calibration periodicity failed
 */
#define MMWAVE_ECALPERIOD               (MMWAVE_ERRNO_BASE-21)

/**
 * @brief   Error Code: mmWave link BSS calibration trigger failed
 */
#define MMWAVE_ECALTRIG                 (MMWAVE_ERRNO_BASE-22)

/**
 * @brief   Error Code: Out of memory error
 */
#define MMWAVE_ENOMEM                   (MMWAVE_ERRNO_BASE-23)

/**
 * @brief   Error Code: Not found
 */
#define MMWAVE_ENOTFOUND                (MMWAVE_ERRNO_BASE-24)

/**
 * @brief   Error Code: Asynchronous event configuration failed
 */
#define MMWAVE_EASYNCEVENT              (MMWAVE_ERRNO_BASE-25)

/**
 * @brief   Error Code: Calibration failed.
 */
#define MMWAVE_ECALFAIL                 (MMWAVE_ERRNO_BASE-26)

/**
 * @brief   Error Code: mmWave link BPM common configuration failed
 */
#define MMWAVE_ECOMMONBPMCFG            (MMWAVE_ERRNO_BASE-27)

/**
 * @brief   Error Code: mmWave link BPM configuration failed
 */
#define MMWAVE_EBPMCFG                  (MMWAVE_ERRNO_BASE-28)

/**
 * @brief   Error Code: invalid value provided for calibMonTimeUnit 
 * in MMWave_open() failed
 */
#define MMWAVE_EINVALIDCALMONUNIT       (MMWAVE_ERRNO_BASE-29)

/**
 * @brief   Error Code: Phase shift Calibration data restore failed.
 */
#define MMWAVE_EPHASESHIFTCALDATARESTOREFAIL    (MMWAVE_ERRNO_BASE-30)

/**
 * @brief   Error Code: mmWave link datapath configuration failed
 */
#define MMWAVE_EDATAPATHCFG                  (MMWAVE_ERRNO_BASE-31)

/**
 * @brief   Error Code: mmWave link data path clock configuration failed
 */
#define MMWAVE_EDATAPATHCLOCKCFG             (MMWAVE_ERRNO_BASE-32)

/**
 * @brief   Error Code: mmWave link HSI clock configuration failed
 */
#define MMWAVE_EHSICLKCFG                    (MMWAVE_ERRNO_BASE-33)

/**
 * @brief   Error Code: mmWave link CSI configuration failed
 */
#define MMWAVE_ECSI2CFG                      (MMWAVE_ERRNO_BASE-34)

/**
 * @brief   Error Code: mmWave link Lane configuration failed
 */
#define MMWAVE_ELANECFG                      (MMWAVE_ERRNO_BASE-35)

/**
 * @brief   Error Code: mmWave link data format configuration failed
 */
#define MMWAVE_EDATAFMTCFG                   (MMWAVE_ERRNO_BASE-36)

/**
 * @brief   Error Code: mmWave link internal configuration failed
 */
#define MMWAVE_EINTERNALCFG                   (MMWAVE_ERRNO_BASE-37)

/**
 * @brief   Error Code: mmWave link RF enable  failed
 */
#define MMWAVE_ERFEN                          (MMWAVE_ERRNO_BASE-38)

/**
 * @brief   Error Code: mmWave link Miscelaneous config  failed
 */
#define MMWAVE_EMISCCFG                       (MMWAVE_ERRNO_BASE-39)

 /**
  * @brief   Error Code: mmWave link chirp level phase shifter failed
  */
 #define MMWAVE_EPHASESHIFTCFG                (MMWAVE_ERRNO_BASE-40)

 /**
 * @brief   Error Code: RFS Boot Calibration Failure
 */
#define MMWAVE_ERFSBOOTCAL                    (MMWAVE_ERRNO_BASE-41)

 /**
 * @brief   Error Code: TX CLPC Calibration Failure
 */
#define MMWAVE_ETXCLPCCAL                    (MMWAVE_ERRNO_BASE-42)

/**
@}
*/
#define GPADCPIN1_ENABLE                    (1U)
#define GPADCPIN2_ENABLE                    (1U<<1U)

/** @brief Max usable xWRL6432AOP frequency */
#define MAX_AOP_FREQ_GHZ 63.5

#define MMWAVE_NBR_DEVICES                  (1U)

/** @addtogroup MMWAVE_EXTERNAL_DEFINITIONS
 @{ */

/**
 * @brief
 *  mmWave Supported max profiles which can be configured on the BSS
 */
#define   MMWAVE_MAX_PROFILE                (4U)

/**
 * @brief
 *  This is the ACK wait timeout in msec. This is the time for which the
 *  mmWave link module will wait for the reception on an ACK from the BSS. If
 *  this is set to 0 then the mmWave link will not wait for an ACK.
 */
#define   MMWAVE_ACK_TIMEOUT                (1000U)

/**
 * @brief 
 * This is the time required for RFS firmware
 * to process the Frame End Event.
 */
#define RFS_FRAME_END_TIME              (15)

/**
 * @brief 
 * This is the time required for RFS firmware
 * to process the Burst End event
 */
#define RFS_BURST_END_TIME              (50)

/**
 * @brief 
 * This is the time required for RFS firmware
 * to complete processing of Frame End and Burst End
 * Event.
 */
#define RFS_PROC_END_TIME              (RFS_FRAME_END_TIME+RFS_BURST_END_TIME)
/**
@}
*/           


#define     MINUS_ONE           -((int32_t)1)

#define CHANNEL0_ENABLE         (1U)
#define CHANNEL1_ENABLE         (1U<<1U)
/**
@}
*/

/** @addtogroup MMWAVE_EXTERNAL_DATA_STRUCTURE
 @{ */

/**
 * @brief
 *  mmWave Profile Handle
 */
typedef void*   MMWave_ProfileHandle;

/**
 * @brief
 *  mmWave Chirp Handle
 */
typedef void*   MMWave_ChirpHandle;


/**
 * @brief
 *  Error Level
 *
 * @details
 *  The mmWave module API can return different error levels. The enumeration
 *  describes different error levels. Please refer to the MMWave error decode
 *  function on the interpretation of this error level.
 *
 *  @sa
 *      MMWave_decodeError
 */
typedef enum MMWave_ErrorLevel_e
{
    /**
     * @brief   The mmWave API was successful. There were no errors detected.
     * There is no reason to perform any error decode here.
     */
    MMWave_ErrorLevel_SUCCESS   = 0,

    /**
     * @brief   The mmWave API reported a warning. Application can either ignore this
     * error message *OR* can perform the error decoding to get more information
     * on the actual reason.
     */
    MMWave_ErrorLevel_WARNING,

    /**
     * @brief   The mmWave API reported an error and applications should perform
     * error decoding to get the exact reason for the failure.
     */
    MMWave_ErrorLevel_ERROR
}MMWave_ErrorLevel;

/**
 * @brief
 *  Chirp Calibration configuration
 *
 * @details
 *  The structure is used to hold the information which is required
 *  to setup the calibration of the RF while operating in the Chirp
 *  mode
 */
typedef struct MMWave_ChirpCalibrationCfg_t
{
    /**
     * @brief   Flag which determines if calibration is to be enabled or
     * not.
     */
    bool            enableCalibration;

    /**
     * @brief   Flag which determines if periodic calibration is to be enabled or
     * not. The mmWave will always do one time calibration.
     */
    bool            enablePeriodicity;

    /**
     * @brief   This is valid only if periodicity is enabled and is the time in frames
     * when a calibration report is received by the application through an asynchrous
     * event.
     */
    uint16_t        periodicTimeInFrames;
}MMWave_ChirpCalibrationCfg;

/**
 * @brief
 *  Continuous Calibration configuration
 *
 * @details
 *  The structure is used to hold the information which is required
 *  to setup the calibration of the RF while operating in continuous
 *  mode
 */
typedef struct MMWave_ContCalibrationCfg_t
{
    /**
     * @brief   In continuous mode; only one shot calibration is supported
     * Set this flag to enable this feature.
     */
    bool            enableOneShotCalibration;
}MMWave_ContCalibrationCfg;

/**
 * @brief
 *  Calibration configuration
 *
 * @details
 *  The structure is used to hold the information which is required
 *  to setup the calibration of the RF
 */
typedef struct MMWave_CalibrationCfg_t
{
    /**
     * @brief   This should be configured if the DFE Data output mode
     * is configured to operate in frame or advanced frame mode
     */
    MMWave_ChirpCalibrationCfg  chirpCalibrationCfg;
}MMWave_CalibrationCfg;

/**
 * @brief
 *  Frame mode configuration
 *
 * @details
 *  The structure specifies the configuration which is required to configure
 *  the mmWave link to operate in frame mode
 */
typedef struct MMWave_FrameCfg_t
{
    /**
     * @brief   List of all the active profile handles which can be configured.
     * Setting to NULL indicates that the profile is skipped.
     */
    MMWave_ProfileHandle    profileHandle[MMWAVE_MAX_PROFILE];

    /**
     * @brief   Configuration which is used to setup Frame
     */
    T_RL_API_SENS_FRAME_CFG            frameCfg;

    /**
     * @brief   Configuration which is used to setup Temperature measurements
     */
    T_RL_API_FECSS_TEMP_MEAS_CMD       tempCfg;

}MMWave_FrameCfg;

/**
 * @brief
 *  Temperature measurements
 *
 * @details
 *  The structure is used to hold all the relevant temperature
 *  measurements - Rx, Tx, PM, DIG.
 */
typedef struct MMWave_temperatureStats_t
{
    /*! @brief      Temp meas status returned by the meas API */
    uint16_t       tempStatus;

    /*! @brief      Temp meas values returned by the meas API */
    int16_t        tempValue[4];
} MMWave_temperatureStats;

/**
 * @brief
 *  Control configuration
 *
 * @details
 *  The structure specifies the configuration which is required to configure
 *  and setup the BSS.
 */
typedef struct MMWave_CtrlCfg_t
{

    /**
     * @brief   Chirp configuration to be used: This is only applicable
     * if the data output mode is set to Chirp
     */
    MMWave_FrameCfg         frameCfg[MMWAVE_NBR_DEVICES];
}MMWave_CtrlCfg;

/**
 * @brief
 *  Open Configuration
 *
 * @details
 *  The structure specifies the configuration which is required to open the
 *  MMWave module. Once the MMWave module has been opened the mmWave link
 *  to the BSS is operational.
 */
typedef struct MMWave_OpenCfg_t
{
    T_RL_API_FECSS_RF_RUN_CAL_CMD             fecRFRunTimeCalCmd;

    T_RL_API_FECSS_RF_RUN_CAL_RSP             fecRFRunTimeCalRsp;

    bool                                      useRunTimeCalib;

    bool                                      useCustomCalibration;

    uint16_t                                  customCalibrationEnableMask;

    bool                                      runTxCLPCCalib;

    T_RL_API_FECSS_RUNTIME_TX_CLPC_CAL_CMD    *ptrfecTxclpcCalCmd;

    T_RL_API_FECSS_RUNTIME_TX_CLPC_CAL_RSP    fecTxclpcCalRsp;

    T_RL_API_FECSS_RDIF_CTRL_CMD              fecRDIFCtrlCmd;

}MMWave_OpenCfg;

/**
 * @brief
 *  Sensor Start Configuration
 *
 * @details
 *  The structure specifies the configuration which is required to start the
 *  sensor.
 */
typedef struct MMWave_StrtCfg_t
{
    /**
     * @brief Frame Trigger Mode.
     *
     */
    uint8_t frameTrigMode;

    /**
     * @brief  Chirp Timer (CT) start signal loopback enable control.
     *
     */
    uint8_t chirpStartSigLbEn;

    /**
     * @brief   Frame Live monitors enable control.
     *
     */
    uint8_t frameLivMonEn;

    /**
     * @brief Frame Trigger Timer Value
     *
     */
    uint8_t frameTrigTimerVal;

} MMWave_StrtCfg;

/**
 * @brief
 *  Synth Frequency cfg
 *
 * @details
 *  The structure specifies the configuration for Synth Frequency monitor.
 */
typedef struct MMWave_MonSynthFreq_cfg_t
{
    // Synth Frequency monitor start time.
    float chirpMonStartTime;

    // RF start frequency
    float rfFreqGhz;

}MMWave_MonSynthFreq_cfg;

/**
 * @brief
 *  TX Rx Loop Back cfg
 *
 * @details
 *  The structure specifies the configuration for TX RX Loop Back monitor.
 */
typedef struct MMWave_MonTxRxLb_cfg_t
{
    /* Monitors to be enabled
     * | Bit Field   | Definition  |
     * |---------|-----------  |
     * | Bit[0]  | TXn_RX_LB_MON enable bit. \n TX0 or TX1 to RX LB monitor with BPM=0deg enable control.
     * | Bit[1]  | TXn_BPM_MON enable bit. \n TX0 or TX1 to BPM monitor with BPM=180deg enable control. */
    uint8_t monenbl;

    // TX RX code selection
    uint8_t txrxCodeSel;

    //RX Gain code
    uint8_t rxGainCode;

    // TX channel Bias Code Override
    uint16_t txBiasCode;

    // RF start frequency
    float rfFreqGhz;

    // RF Freq Slope
    float rffreqSlopeMhz;

}MMWave_MonTxRxLb_cfg;


/**
 * @brief
 *  TX power monitor cfg
 *
 * @details
 *  The structure specifies the configuration for TX power monitor.
 */
typedef struct MMWave_MonTxnPow_cfg_t
{
    // TX bias code selection
    uint8_t txBiasSel;

    // TX channel Bias Code Override
    uint16_t txBiasCode;

    // RF start frequency
    float rfFreqGhz;

    // RF Freq Slope
    float rffreqSlopeMhz;

    // TX Backoff
    uint8_t txBackoff;

}MMWave_MonTxnPow_cfg;

/**
 * @brief
 *  TX DC Signal cfg
 *
 * @details
 *  The structure specifies the configuration for TX DC signal monitor.
 */
typedef struct MMWave_MonTxnDcSig_cfg_t
{
    // TX bias code selection
    uint8_t txBiasSel;

    // TX channel Bias Code Override
    uint16_t txBiasCode;

    // RF start frequency
    float rfFreqGhz;

    // RF Freq Slope
    float rffreqSlopeMhz;

}MMWave_MonTxnDcSig_cfg;

/**
 * @brief
 *  RX HPF DC Signal cfg
 *
 * @details
 *  The structure specifies the configuration for RX HPF DC signal monitor.
 */
typedef struct MMWave_MonRxHpfDcSig_cfg_t
{
    /* RF start frequency */
    float rfFreqGhz;

    /* RX_DC_SIG and HPF Monitor control.
     * | Value   | Definition  |
     * |---------|-----------  |
     * | 0      | Disabled  |
     * | 1      | Enabled   |
     * | Bit Field   | Definition  |
     * |---------|-----------  |
     * | Bit[0]  | RX_DC_MON enable bit.     |
     * | Bit[1]  | HPF_CUTOFF_MON enable bit.|*/
    uint8_t monenbl;

    /* HPF corner frequency
     * | Value   | Definition  |
     * |---------|-----------  |
     * | 0      | 175kHz HPF corner frequency  |
     * | 1      | 350kHz HPF corner frequency   |
     * | 2      | 700kHz HPF corner frequency   |
     * | 3      | 1400kHz HPF corner frequency   |
     * Valid Range: 0 to 3
     */
    uint8_t rxHpfSel;

}MMWave_MonRxHpfDcSig_cfg;

/**
 * @brief
 *  Synth Frequency Monitor result
 *
 * @details
 *  The structure is for holding result of Synth Frequency Monitor.
 */
typedef struct MMWave_MonSynthFreqRes_res_t
{
    /* Status flag indicating pass fail results corresponding to threshold checks under this
     * monitor.
     * | Value   | Definition  |
     * |---------|-----------  |
     * | 0      | Fail    |
     * | 1      | Pass     |
     *
     */
    uint8_t status;

    /* Max Synth Frequency error value */
    float maxSynthFreqErr;

    /* Max Synth Frequency error value */
    uint32_t freqErrFailCount;

    /* Monitor report Frame Count */
    uint32_t FrameCount;

}MMWave_MonSynthFreqRes_res;

/**
 * @brief
 *  Rx Saturation Live Monitor result
 *
 * @details
 *  The structure is for holding result of Rx Saturation Live Monitor.
 */
typedef struct MMWave_MonRxSatLive_res_t
{
    /*Pointer to the results of Rx Saturation Live Monitor */
    uint32_t *rxSatLivePtr;

}MMWave_MonRxSatLive_res;

/**
 * @brief
 *  PLL Control Voltage Monitor result
 *
 * @details
 *  The structure is for holding result of PLL Control Voltage Monitor.
 */
typedef struct MMWave_MonPllVolRes_res_t
{
    // APLL control voltage value
    float apllV;

    // SYNTH VCO Min frequency control voltage value
    float synthMinV;

    // SYNTH VCO Max frequency control voltage value.
    float synthMaxV;

    /* Status
    *  Bit[0]=  APLL Pass/Fail
    *  Bit[1]= Synth Min Pass/Fail
    *  Bit[2]= Synth Max Pass/Fail
    */
    uint8_t status;

}MMWave_MonPllVolRes_res;

/**
 * @brief

 *  TX RX Loop Back monitor result
 *
 * @details
 *  The structure is for holding result of TX RX Loop Back monitor.
 */
typedef struct MMWave_MonTxRxLb_res_t
{
    //Loop Back Input Power in dBm
    float lbInputPower;

    // Loop Back Power in dBm
    float lbPower[3];

    // Loop Back Phase
    float lbPhase[3];
    
    //Loop Back Noise
    float lbNoisedbm[3];
    
    // Loop Back Power with BPM ON in dBm
    float lbBpmPower[3];

    // Loop Back Phase with BPM ON
    float lbBpmPhase[3];
    
    //Loop Back Noise with BPM ON
    float lbBpmNoisedbm[3];

    //Loop Back BPM Gain error
    float lbBPMGainError[3];

    //Loop Back BPM Phase error
    float lbBPMPhaseError[3];

    //Loop Back Rx Gain Mismatch
    float lbRxGainMismatch[2];

    //Loop Back Rx Phase Mismatch
    float lbRxPhaseMismatch[2];

}MMWave_MonTxRxLb_res;

/**
 * @brief

 *  TX power Ball Break monitor result
 *
 * @details
 *  The structure is for holding result of TX power ball break monitor.
 */
typedef struct MMWave_MonTxnPowBB_res_t
{
    // TX power at incident PD
    float txIncPow;

    // TX power at reflected PD
    float txRefPow;

    // TX return Loss
    float txReturnLoss;

}MMWave_MonTxnPowBB_res;

/**
 * @brief

 *  RX HPF DC Sig monitor result
 *
 * @details
 *  The structure is for holding result of RX HPF DC Sig monitor.
 */
typedef struct MMWave_MonRxHpfDcSig_res_t
{
    /* The measured all RX channels supply and bias GPADC DC signals for selected monitor
     * configuration is compared with internal thresholds and result (pass/fail) will be sent out
     * for each signal type. \n
     * | Bit Field   | Definition  |
     * |-------------|-----------  |
     * | Bit[0]      | RX0_ADC_DIG_VOUT_SUPPLY Status      |
     * | Bit[1]      | RX0_ADC_DIG_VIN_SUPPLY Status     |
     * | Bit[2]      | RX0_IFA_VOUT_SUPPLY Status      |
     * | Bit[3]      | RX0_IFA_VIN_SUPPLY Status     |
     * | Bit[4]      | RX0_LNA_VDD_SUPPLY Status (Internal only)     |
     * | Bit[5]      | RX01_CLUSTER_VDD_SUPPLY Status     |
     * | Bit[6]      | RX1_ADC_DIG_VOUT_SUPPLY Status     |
     * | Bit[7]      | RX1_ADC_DIG_VIN_SUPPLY Status     |
     * | Bit[8]      | RX1_IFA_VOUT_SUPPLY Status     |
     * | Bit[9]      | RX1_IFA_VIN_SUPPLY Status     |
     * | Bit[10]  | RX1_LNA_VDD_SUPPLY Status (Internal only)     |
     * | Bit[11]  | RX2_ADC_DIG_VOUT_SUPPLY Status     |
     * | Bit[12]  | RX2_ADC_DIG_VIN_SUPPLY Status     |
     * | Bit[13]  | RX2_IFA_VOUT_SUPPLY Status     |
     * | Bit[14]  | RX2_IFA_VIN_SUPPLY Status     |
     * | Bit[15]  | RX2_LNA_VDD_SUPPLY Status     |
     * | Bit[16]  | RX23_CLUSTER_VDD_SUPPLY Status (Internal only)    |
     * | Bit[31:17]  | Reserved     | */
    uint32_t rxDcMonstat;

    // HPF Inband Power 
    float RxHpfInbandPwrdB[3];

    // HPF Cutoff Power 
    float RxHpfCutoffPwrdB[3];

    // HPF Cutoff Attenuation
    float RxHpfCutoffAtten[3];

    /* Status
    *  Bit[0]= Rx0 HPF Pass/Fail
    *  Bit[1]= Rx1 HPF Pass/Fail
    *  Bit[2]= Rx2 HPF Pass/Fail
    */
    uint8_t status;

}MMWave_MonRxHpfDcSig_res;

/**
 * @brief

 *  PM CLK DC Sig monitor result
 *
 * @details
 *  The structure is for holding result of PM CLK DC Sig monitor.
 */
typedef struct MMWave_MonPmClkDcSig_res_t
{
     /*
     * | Bit Field   | Definition  |
     * |-------------|-----------  |
     * | Bit[0]      | PM_RF_LDO_1P8V_1P2V_VIN Status      |
     * | Bit[1]      | PM_RF_LDO_1P8V_1P2V_VOUT Status     |
     * | Bit[2]      | PM_RF_LDO_1P2V_1P0V_VIN Status      |
     * | Bit[3]      | PM_RF_LDO_1P2V_1P0V_VOUT Status     |
     * | Bit[4]      | PM_1P22V_BG Status (Internal Only)     |
     * | Bit[5]      | CLK_VDD_VCO_1P8V Status      |
     * | Bit[6]      | CLK_VDD_20GCLK_1P8V Status     |
     * | Bit[7]      | CLK_LDO_APLL_IOBUFF_1P4V Status     |
     * | Bit[8]      | CLK_LDO_APLL_VCO_1P4V Status     |
     * | Bit[9]      | CLK_LDO_APLL_CP_1P0V Status      |
     * | Bit[10]  | CLK_LDO_SYNTH_SDM_1P4V Status  |
     * | Bit[11]  | CLK_LDO_SYNTH_VCO Status     |
     * | Bit[12]  | CLK_LDO_SYNTH_DIV Status     |
     * | Bit[13]  | CLK_LDO_SLICER_1P4V Status     |
     * | Bit[14]  | CLK_VDD_COM_CLUST_1P0V Status     |
     * | Bit[15]  | CLK_LDO_MULT_VOUT Status     |
     * | Bit[31:16]  | Reserved     |
     */
    uint32_t pmClkDcMonstat;

    // The REF1_0P45V Reference voltage GPADC measurement value.
    float volref1V;

    // The REF2_0P6V Reference voltage GPADC measurement value.
    float volref2V;

    // The The REF3_0P9V Reference voltage GPADC measurement value.
    float volref3V;

    // The REF4_VION_IN Reference voltage GPADC measurement value.
    float volref4V;

}MMWave_MonPmClkDcSig_res;


/**
 * @brief
 *  Calibration Configuration
 *
 * @details
 *  The structure specifies the various calibration data that RadarSS needs
 *  in case user desires to restore the calibration using factory values instead
 *  of requesting RadarSS to calculate them on-the-fly.
 */
typedef struct MMWave_CalibrationData_t
{

} MMWave_CalibrationData;

/**
 * @brief
 *  mmWave Handle
 */
typedef void*   MMWave_Handle;

/**
 * @brief
 *  Initial Configuration
 *
 * @details
 *  The structure specifies the configuration which is required to initialize
 *  and setup the mmWave module.
 */
typedef struct MMWave_InitCfg_t
{
    T_RL_API_FECSS_DEV_PWR_ON_CMD     fecDevPwrOnCmd;

    T_RL_API_FECSS_DEV_CLK_CTRL_CMD   fecDevClkCtrlCmd;

    T_RL_API_FECSS_RF_PWR_CFG_CMD     fecRFPwrCfgCmd;

    T_RL_API_FECSS_RF_STS_GET_RSP     fecRFStsGetRsp;

    bool                              iswarmstart; // For RPMF

}MMWave_InitCfg;

typedef struct MMWave_calibCfg_t
{
    T_RL_API_FECSS_RF_FACT_CAL_CMD    fecRFFactoryCalCmd;

    T_RL_API_FECSS_RF_FACT_CAL_RSP    fecRFFactoryCalRsp;

    T_RL_API_FECSS_RXTX_CAL_DATA      *ptrFactoryCalibData;

    uint8_t                           *ptrAteCalibration;

    bool                              isATECalibEfused;

    bool                              isFactoryCalEnabled;

}MMWave_calibCfg;

/**
@}
*/

/***********************************************************************************************
 * mmWave Exported API:
 ***********************************************************************************************/
extern MMWave_Handle MMWave_init (MMWave_InitCfg* ptrCtrlInitCfg, int32_t* errCode);
extern int32_t MMWave_deinit (MMWave_Handle mmWaveHandle, int32_t* errCode);
extern int32_t MMWave_open (MMWave_Handle mmWaveHandle, const MMWave_OpenCfg* ptrOpenCfg, int32_t* errCode);
extern int32_t MMWave_close(MMWave_Handle mmWaveHandle, int32_t* errCode);
extern int32_t MMWave_config (MMWave_Handle mmWaveHandle, MMWave_CtrlCfg* ptrControlCfg, int32_t* errCode);
extern int32_t MMWave_start (MMWave_Handle mmWaveHandle, const MMWave_CalibrationCfg* ptrCalibrationCfg, const MMWave_StrtCfg* ptrStrtcfg, int32_t* errCode);
extern int32_t MMWave_stop (MMWave_Handle mmWaveHandle, int32_t* errCode);
extern int32_t MMWave_execute (MMWave_Handle mmWaveHandle, int32_t* errCode);
extern int32_t MMWave_sync (MMWave_Handle mmWaveHandle, int32_t* errCode);
int32_t MMWave_factoryCalibConfig (MMWave_Handle mmWaveHandle, MMWave_calibCfg* ptrfactoryCalibCfg, int32_t* errCode);

/***********************************************************************************************
 * mmWave Monitor Exported API:
 ***********************************************************************************************/
int32_t MMWave_monitorsCfg (MMWave_Handle mmWaveHandle, uint64_t monEnable, T_DFP_PLT_ISR_HANDLER isrHandler);
int32_t MMWave_enableMonitors (MMWave_Handle mmWaveHandle);
int64_t MMWave_getMonitorStatus (MMWave_Handle mmWaveHandle);
uint32_t *MMWaveMon_getRxSatLiveMonres();
MMWave_MonSynthFreqRes_res MMWaveMon_getSynthFreqMonres();
MMWave_MonPllVolRes_res MMWaveMon_getPllVolMonres(uint8_t enamask);
float MMWaveMon_lbPhaseError(float val);
MMWave_MonTxRxLb_res MMWaveMon_getTxRxLbres(uint8_t txInstance);
float MMWaveMon_getTXnPow(uint8_t txInstance);
MMWave_MonTxnPowBB_res MMWaveMon_getTXnPowBB(uint8_t txInstance);
uint16_t MMWaveMon_getTXnDcSig(uint8_t txInstance);
void MMWaveMon_getRxHpfDcSig(MMWave_MonRxHpfDcSig_res* val);
void MMWaveMon_getPmClkDcMonres(MMWave_MonPmClkDcSig_res* val);
int32_t MMWaveMon_PllCtrlVolCfg(uint8_t enamask);
int32_t MMWaveMon_TxRxLbCfg (uint8_t txInstance, MMWave_MonTxRxLb_cfg* cfg);
int32_t MMWaveMon_TxnPowCfg (uint8_t txInstance, MMWave_MonTxnPow_cfg* cfg);
int32_t MMWaveMon_TxnPowBBCfg (uint8_t txInstance, MMWave_MonTxnPow_cfg* cfg);
int32_t MMWaveMon_TxnDcSigCfg (uint8_t txInstance, MMWave_MonTxnDcSig_cfg* cfg);
int32_t MMWaveMon_RxHpfDcSigCfg (MMWave_MonRxHpfDcSig_cfg* cfg);
int32_t MMWaveMon_PmClkDcSigCfg(float strtFreqGhz);
int32_t MMWaveMon_TxnSynthFreqCfg ();
int32_t MMWaveMon_RxSatLiveCfg () ;


/***********************************************************************************************
 * Configuration Management API: Available in FULL configuration mode
 ***********************************************************************************************/
extern MMWave_ChirpHandle MMWave_addChirp (MMWave_ProfileHandle profileHandle, const T_RL_API_SENS_PER_CHIRP_CFG* ptrChirpCfg, \
        const T_RL_API_SENS_PER_CHIRP_CTRL* ptrChirpCtrl, int32_t* errCode);
extern int32_t MMWave_delChirp(MMWave_ProfileHandle profileHandle, MMWave_ChirpHandle chirpHandle, int32_t* errCode);
extern int32_t MMWave_getChirpCfg(MMWave_ChirpHandle chirpHandle, T_RL_API_SENS_PER_CHIRP_CFG* ptrChirpCfg, \
        T_RL_API_SENS_PER_CHIRP_CTRL* ptrChirpCtrl, int32_t* errCode);
extern MMWave_ProfileHandle MMWave_addProfile (MMWave_Handle mmWaveHandle, const T_RL_API_SENS_CHIRP_PROF_COMN_CFG* ptrProfileCfg, \
        const T_RL_API_SENS_CHIRP_PROF_TIME_CFG* ptrProfileTimeCfg, int32_t* errCode);
extern int32_t MMWave_getNumProfiles(MMWave_Handle mmWaveHandle, uint32_t* numProfiles, int32_t* errCode);
extern int32_t MMWave_getProfileHandle(MMWave_Handle mmWaveHandle,uint8_t profileId, MMWave_ProfileHandle* profileHandle,int32_t* errCode);
extern int32_t MMWave_delProfile (MMWave_Handle mmWaveHandle,MMWave_ProfileHandle profileHandle, int32_t* errCode);
extern int32_t MMWave_getProfileCfg (MMWave_ProfileHandle profileHandle, T_RL_API_SENS_CHIRP_PROF_COMN_CFG* ptrProfileCfg, \
        T_RL_API_SENS_CHIRP_PROF_TIME_CFG* ptrProfileTimeCfg, int32_t* errCode);
extern int32_t MMWave_getNumChirps(MMWave_ProfileHandle profileHandle, uint32_t* numChirps, int32_t* errCode);
extern int32_t MMWave_getChirpHandle(MMWave_ProfileHandle profileHandle, uint32_t chirpIndex, MMWave_ChirpHandle* chirpHandle, int32_t* errCode);

extern int32_t MMWave_flushCfg(MMWave_Handle mmWaveHandle, int32_t* errCode);
extern void MMWave_getTemperatureReport (MMWave_temperatureStats* ptrTempStats);
extern int32_t MMWave_enableGPADC(uint8_t pinsEnabled);
extern void MMWave_readGPADC(float *val1 , float *val2);

/* Error Management API: */
extern void MMWave_decodeError (int32_t errCode, MMWave_ErrorLevel* errorLevel, int16_t* mmWaveError, int16_t* subSysError);

#ifdef __cplusplus
}
#endif

#endif /* MMWAVE_H */


