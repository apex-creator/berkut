/*
 *  Copyright (C) 2021 Texas Instruments Incorporated
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/**
 *  \file     hwa.h
 *
 *  \brief    HWA driver interface for HWA2.0
 *
 */
/** \defgroup DRV_HWA_MODULE APIs for HWA
 *  \ingroup DRV_MODULE
 *
 *  The HWA driver provides APIs to configure, trigger and obtain results from the
 *  hardware accelerator
 */
/**
 *  \defgroup HWA_DRIVER_EXTERNAL_FUNCTION            HWA Driver External Functions
 *  \ingroup DRV_HWA_MODULE
 *  \brief
 *   The section has a list of all the exported API which the applications need to
 *   invoke in order to use the driver
 */
/**
 *  \defgroup HWA_DRIVER_EXTERNAL_DATA_STRUCTURE      HWA Driver External Data Structures
 *  \ingroup DRV_HWA_MODULE
 *  \brief
 *   The section has a list of all the data structures which are exposed to the application
 */
/**
 *  \defgroup HWA_DRIVER_ERROR_CODE                   HWA Driver Error Codes
 *  \ingroup DRV_HWA_MODULE
 *  \brief
 *   The section has a list of all the error codes which are generated by the HWA Driver
 *   module
 */

#ifndef HWA_H_
#define HWA_H_

/* ========================================================================== */
/*                             Include Files                                  */
/* ========================================================================== */

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <drivers/hw_include/csl_complex_math_types.h>
#include <kernel/dpl/HwiP.h>
#include <kernel/nortos/dpl/m4/HwiP_armv7m.h>
#include <drivers/hw_include/cslr_hwa.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ========================================================================== */
/*                             Macros & Typedefs                              */
/* ========================================================================== */

#define HWA_RAM_WINDOW_SIZE_IN_BYTES                     (1024U*4U)     /**< Internal or Window RAM size in bytes. See \ref HWA_configRam */

/** \brief transfer the CPU address to HWA address */
#define HWADRV_ADDR_TRANSLATE_CPU_TO_HWA(x)  (uint32_t)((uint32_t)(x) & 0x000FFFFFU)

/** \addtogroup HWA_DRIVER_ERROR_CODE
 *
 * \brief  HWA driver Error Codes
 *
 * @{
 */
/** \brief HWA driver error base */
#define HWA_ERRNO_BASE                                  (-2800)
/** \brief Error Code: Invalid argument */
#define HWA_EINVAL                                      (HWA_ERRNO_BASE-1)
/** \brief Error Code: Operation cannot be done as HWA_init is not done */
#define HWA_ENOINIT                                     (HWA_ERRNO_BASE-2)
/** \brief Error Code: input argument out of range */
#define HWA_EOUTOFRANGE                                 (HWA_ERRNO_BASE-3)
/** \brief Error Code: out of memory */
#define HWA_EOUTOFMEM                                   (HWA_ERRNO_BASE-4)
/** \brief Error Code: feature not supported */
#define HWA_ENOTSUPP                                    (HWA_ERRNO_BASE-5)
/** \brief Error Code: channel or resource in use */
#define HWA_EINUSE                                      (HWA_ERRNO_BASE-6)
/** \brief Error Code: address is not aligned to the expected boundary */
#define HWA_ENOTALIGNED                                 (HWA_ERRNO_BASE-7)
/** \brief Error Code: Invalid argument: paramset Start/Stop Idx and numLoops in common register */
#define HWA_EINVAL_COMMON_REGISTER_PARAMSET             (HWA_ERRNO_BASE-8)
/** \brief Error Code: Invalid argument: paramset Start/Stop Idx and numLoops for context switching in common register */
#define HWA_EINVAL_COMMON_REGISTER_PARAMSET_ALT         (HWA_ERRNO_BASE-9)
/** \brief Error Code: Invalid argument: for FFT config in common register */
#define HWA_EINVAL_COMMON_REGISTER_FFTCONFIG            (HWA_ERRNO_BASE-10)
/** \brief Error Code: Invalid argument: for DC estimation in common register */
#define HWA_EINVAL_COMMON_REGISTER_DCEST                (HWA_ERRNO_BASE-11)
/** \brief Error Code: Invalid argument: for CFAR config in common register */
#define HWA_EINVAL_COMMON_REGISTER_CFAR                 (HWA_ERRNO_BASE-12)
/** \brief Error Code: Invalid argument: for interference localization/mitigation in common register */
#define HWA_EINVAL_COMMON_REGISTER_INTERFERENCE         (HWA_ERRNO_BASE-13)
/** \brief Error Code: Invalid argument: for complex multiply in common register */
#define HWA_EINVAL_COMMON_REGISTER_COMPLEXMULT          (HWA_ERRNO_BASE-14)
/** \brief Error Code: Invalid argument: for channel combine in common register */
#define HWA_EINVAL_COMMON_REGISTER_CHANCOMB             (HWA_ERRNO_BASE-15)
/** \brief Error Code: Invalid argument: for zero insert in common register */
#define HWA_EINVAL_COMMON_REGISTER_ZEROINSERT           (HWA_ERRNO_BASE-16)
/** \brief Error Code: Invalid argument: for advanced statistics in common register */
#define HWA_EINVAL_COMMON_REGISTER_ADVSTAT              (HWA_ERRNO_BASE-17)
/** \brief Error Code: Invalid argument: for compress/decompression in common register */
#define HWA_EINVAL_COMMON_REGISTER_COMPRESS             (HWA_ERRNO_BASE-18)
/** \brief Error Code: Invalid argument: for local maximum in common register */
#define HWA_EINVAL_COMMON_REGISTER_LOCALMAXIMUM         (HWA_ERRNO_BASE-19)
/** \brief Error Code: Invalid argument: general config in paramset  */
#define HWA_EINVAL_PARAMSET_GENERALCONFIG               (HWA_ERRNO_BASE - 20)
/** \brief Error Code: Invalid argument: source(input formatter) in paramset */
#define HWA_EINVAL_PARAMSET_SOURCE                      (HWA_ERRNO_BASE - 21)
/** \brief Error Code: Invalid argument: destination(output formatter) in paramset */
#define HWA_EINVAL_PARAMSET_DEST                        (HWA_ERRNO_BASE - 22)
/** \brief Error Code: Invalid argument: src and dst address in paramset */
#define HWA_EINVAL_PARAMSET_SRCDST_ADDRESS              (HWA_ERRNO_BASE - 23)
/** \brief Error Code: Invalid argument: FFT mode: general config in paramset */
#define HWA_EINVAL_PARAMSET_FFTMODE_GENERALCONFIG       (HWA_ERRNO_BASE - 24)
/** \brief Error Code: Invalid argument: FFT mode: FFT size in paramset */
#define HWA_EINVAL_PARAMSET_FFTMODE_SIZE                (HWA_ERRNO_BASE - 25)
/** \brief Error Code: Invalid argument: FFT mode: post processing in paramset */
#define HWA_EINVAL_PARAMSET_FFTMODE_POSTPROC            (HWA_ERRNO_BASE - 26)
/** \brief Error Code: Invalid argument: FFT mode: pre-processing in paramset */
#define HWA_EINVAL_PARAMSET_FFTMODE_PREPROC             (HWA_ERRNO_BASE - 27)
/** \brief Error Code: Invalid argument: FFT mode: pre-processing interference localization/statistics/mitigation in paramset */
#define HWA_EINVAL_PARAMSET_FFTMODE_PREPROC_INTERF      (HWA_ERRNO_BASE - 28)
/** \brief Error Code: Invalid argument: FFT mode: pre-processing complex multiply block in paramset */
#define HWA_EINVAL_PARAMSET_FFTMODE_PREPROC_COMPLEXMULT (HWA_ERRNO_BASE - 29)
/** \brief Error Code: Invalid argument: CFAR mode: general configuration in paramset */
#define HWA_EINVAL_PARAMSET_CFARMODE_GENERALCONFIG      (HWA_ERRNO_BASE - 30)
/** \brief Error Code: Invalid argument: CFAR mode: CFAR-OS configuration in paramset */
#define HWA_EINVAL_PARAMSET_CFARMODE_OSCONFIG           (HWA_ERRNO_BASE - 31)
/** \brief Error Code: Invalid argument: CFAR mode: CFAR-CA configuration in paramset */
#define HWA_EINVAL_PARAMSET_CFARMODE_CACONFIG           (HWA_ERRNO_BASE - 32)
/** \brief Error Code: Invalid argument: compress/decompress mode: compress/decompress configuration in paramset */
#define HWA_EINVAL_PARAMSET_COMPRESSMODE                (HWA_ERRNO_BASE - 33)
/** \brief Error Code: Invalid argument: local maxima mode: local maxima configuration in paramset */
#define HWA_EINVAL_PARAMSET_LOCALMAXMODE                (HWA_ERRNO_BASE - 34)
/** \brief Error Code: if paramset interrupt is enabled, polling should be disabled */
#define HWA_PARAMSET_POLLINGNOTALLOWED                  (HWA_ERRNO_BASE - 35)
/** \brief Error Code: Invalid argument: for CFAR config in common register - CFAR_DET_THR */
#define HWA_EINVAL_COMMON_REGISTER_CFAR_DET_THR         (HWA_ERRNO_BASE - 36)
/** @} */

/** \brief Number of RX channels in pre-processing block */
#define HWA_NUM_RXCHANNELS              (12U)
/** \brief Number of programmable array of window parameters in interference mitigation block */
#define HWA_NUM_INTERFMITG_WINARRAY     (5U)
/** \brief The length of BPM Pattern sequence in words */
#define HWA_BPMPATTERN_LENGTH_INWORDS   (8U)
/** \brief The length of channel combining vector in words */
#define HWA_CHANCOMB_LENGTH_INWORDS     (8U)
/** \brief The length of zero insert mask in words */
#define HWA_ZEROINSERT_LENGTH_INWORDS   (8U)
/** \brief  The number of RAM types in HWA */
#define HWA_NUM_RAMS                    (3U)
/** \brief  The maximum number of loops in HWA */
#define HWA_MAXNUM_LOOPS                (4095U)
/** \brief  The length of EGE compression/decompression K-paramseters array */
#define HWA_CMP_K_ARR_LEN               (8)

/** \addtogroup HWA_DRIVER_EXTERNAL_DATA_STRUCTURE
 @{ */
/**
 * \defgroup HWA_MACROS     HWA_MACROS
 * \brief Lists all the macros used in HWA driver
 * @{
 */
/**
 * \defgroup HWA_INTERRUPT_PRIORITY      HWA_INTERRUPT_PRIORITY
 * \brief HWA interrupt default priority, applied only to the processors, which support hardware priority.
 * @{
 */
/** \brief  Default HWA background thread done interrupt priority */
#define HWA_DONE_INTERRUPT_PRIORITY             (HwiP_MAX_PRIORITY - 1U)
/** \brief  Default HWA paramset done interrupt 1 priority */
#define HWA_PARAMSETDONE_INTERRUPT1_PRIORITY    (HwiP_MAX_PRIORITY - 1U)
/** \brief  Default HWA paramset done interrupt 2 priority */
#define HWA_PARAMSETDONE_INTERRUPT2_PRIORITY    (HwiP_MAX_PRIORITY - 1U)
/** @} */

/**
 * \defgroup HWA_FEATURE_BIT        HWA_FEATURE_BIT
 * \brief  General macro to use for enable/disable bits
 * @{
 */
#define HWA_FEATURE_BIT_ENABLE          ((uint8_t)1U)       /**<  Enable: use this macro to enable any feature bit */
#define HWA_FEATURE_BIT_DISABLE         ((uint8_t)0U)       /**<  Disable: use this macro to disable any feature bit */
/** @} */

/**
 * \defgroup HWA_SAMPLES_WIDTH      HWA_SAMPLES_WIDTH
 * \brief  Macros that define values for 16bit or 32bit width of input/output samples
 * @{
 */
#define HWA_SAMPLES_WIDTH_16BIT         ((uint8_t)0U)      /**<  sample width is 16 bit */
#define HWA_SAMPLES_WIDTH_32BIT         ((uint8_t)1U)      /**<  sample width is 32 bit */
/** @} */

/**
 * \defgroup HWA_SAMPLES_FORMAT     HWA_SAMPLES_FORMAT
 * \brief  Macros that define values for real/complex format of input/output samples
 * @{
 */
#define HWA_SAMPLES_FORMAT_COMPLEX      ((uint8_t)0U)      /**<  complex samples (I/Q) */
#define HWA_SAMPLES_FORMAT_REAL         ((uint8_t)1U)      /**<  real samples (I) */
/** @} */

/**
 * \defgroup HWA_SAMPLES_SIGN       HWA_SAMPLES_SIGN
 * \brief  Macros that define values for signed/unsigned property of input/output samples
 * @{
 */
#define HWA_SAMPLES_UNSIGNED            ((uint8_t)0U)      /**<  unsigned samples */
#define HWA_SAMPLES_SIGNED              ((uint8_t)1U)      /**<  signed samples */
/** @} */

/**
 * \defgroup HWA_WINDOW_SYMM        HWA_WINDOW_SYMM
 * \brief  Macros that define values for symmetric/non-symmetric property of the FFT window
 * @{
 */
#define HWA_FFT_WINDOW_NONSYMMETRIC     ((uint8_t)0U)      /**<  non-symmetric window for FFT windowing operation */
#define HWA_FFT_WINDOW_SYMMETRIC        ((uint8_t)1U)      /**<  symmetric window for FFT windowing operation
                                                                 Only the first half the window coefficients are expected
                                                                 to be present in the window RAM. The same coefficients are read in
                                                                 reverse direction for the second half. */
/** @} */

/**
 * \defgroup HWA_FFT_WINDOW_INTERPOLATE_MODE        HWA_FFT_WINDOW_INTERPOLATE_MODE
 * \brief  Macros that define values for interpolation property of the FFT window to
 *           achieve larger FFT size using stitching
 * @{
 */
#define HWA_FFT_WINDOW_INTERPOLATE_MODE_NONE    ((uint8_t)0U)      /**<  no window interpolation is enabled */
#define HWA_FFT_WINDOW_INTERPOLATE_MODE_4K      ((uint8_t)1U)      /**<  window interpolation to acheive 4K FFT*/
#define HWA_FFT_WINDOW_INTERPOLATE_MODE_2K      ((uint8_t)2U)      /**<  window interpolation to acheive 2K FFT*/
/** @} */

/**
 * \defgroup HWA_FFT_MODE_MAGNITUDE_LOG2        HWA_FFT_MODE_MAGNITUDE_LOG2
 * \brief  Macros that define values for enabling/disabling the magnitude and log2 computation in FFT block
 * @{
 */
#define HWA_FFT_MODE_MAGNITUDE_LOG2_DISABLED        ((uint8_t)0U)        /**<  magnitude disabled and log2 disabled */
#define HWA_FFT_MODE_MAGNITUDE_ONLY_ENABLED         ((uint8_t)2U)        /**<  magnitude enabled and log2 disabled */
#define HWA_FFT_MODE_MAGNITUDE_LOG2_ENABLED         ((uint8_t)3U)        /**<  magnitude and log2 enabled */
/** @} */

/**
 * \defgroup HWA_FFT_MODE_OUTPUT        HWA_FFT_MODE_OUTPUT
 * \brief  Macros that define values for the various outputs of the FFT block
 * @{
 */
#define HWA_FFT_MODE_OUTPUT_DEFAULT                 ((uint8_t)0U)    /**<  Default output (i.e., main data path output is sent out - eg. FFT or Log-Mag output) */
#define HWA_FFT_MODE_OUTPUT_MAX_STATS               ((uint8_t)2U)    /**<  Statistics output - Max statistics is sent out (Max value on the I arm, Max index on the Q arm) */
#define HWA_FFT_MODE_OUTPUT_SUM_STATS               ((uint8_t)3U)    /**<  Statistics output - Sum statistics is sent out */
/** @} */

/**
 * \defgroup HWA_NOISE_AVG_MODE_CFAR        HWA_NOISE_AVG_MODE_CFAR
 * \brief  Macros that define values for CFAR Noise Averaging mode
 * @{
 */
#define HWA_NOISE_AVG_MODE_CFAR_CA                  ((uint8_t)0U)      /**<  cumulative average of left+right */
#define HWA_NOISE_AVG_MODE_CFAR_CAGO                ((uint8_t)1U)      /**<  cumulative average of the side (left or right) that is greater */
#define HWA_NOISE_AVG_MODE_CFAR_CASO                ((uint8_t)2U)      /**<  cumulative average of the side (left or right) that is smaller */
#define HWA_NOISE_AVG_MODE_CFAR_OS                  ((uint8_t)3U)      /**<  CFAR OS */
/** @} */

/**
 * \defgroup HWA_TRIG_MODE      HWA_TRIG_MODE
 * \brief  Macros that define values for the trigger mode of HWA paramsets
 * @{
 */
#define HWA_TRIG_MODE_IMMEDIATE                     ((uint8_t)0U)      /**<  state machine reads and immediately executes that paramset */
#define HWA_TRIG_MODE_SOFTWARE                      ((uint8_t)1U)      /**<  state machine reads the paramset but waits for s/w trigger before executing that paramset */
#define HWA_TRIG_MODE_RESERVED1                     ((uint8_t)2U)      /**<  Reserved */
#define HWA_TRIG_MODE_DMA                           ((uint8_t)3U)      /**<  state machine reads the paramset but waits for DMA trigger before executing that paramset */
#define HWA_TRIG_MODE_HARDWARE                      ((uint8_t)4U)      /**<  Hardware based trigger #1 */
#define HWA_TRIG_MODE_RESERVED2                     ((uint8_t)5U)      /**<  Hardware based trigger #2 */
#define HWA_TRIG_MODE_RESERVED3                     ((uint8_t)6U)      /**<  Hardware based trigger #3 */
#define HWA_TRIG_MODE_M4CONTROL                     ((uint8_t)7U)      /**<  equivalent to software trigger, M4 Micro-controller based trigger */
/** @} */

/**
 * \defgroup HWA_ACCELMODE      HWA_ACCELMODE
 * \brief  Macros that define values for the operational/accelerator mode of HWA
 * @{
 */
#define HWA_ACCELMODE_FFT                           ((uint8_t)0U)      /**<  HWA operational mode is FFT */
#define HWA_ACCELMODE_CFAR                          ((uint8_t)1U)      /**<  HWA operational mode is CFAR */
#define HWA_ACCELMODE_COMPRESS                      ((uint8_t)2U)      /**<  HWA operational mode is compression/decompression */
#define HWA_ACCELMODE_NONE                          ((uint8_t)7U)      /**< HWA dummy operational mode: use this for waiting for multiple triggers */
/** @} */

/**
 * \defgroup HWA_CFAR_OPER_MODE     HWA_CFAR_OPER_MODE
 * \brief  Macros that define values for the combination of CFAR operational mode (log, mag, mag sqr)
 *           and input samples type (real, complex)
 *
 *
 *Value  |CFAR_LOG_MODE  |CFAR_INP_MODE  |CFAR_ABS_MODE |register bits|description
 *-------| --------------|---------------|--------------|-------------|-------------
 * 0     |              1|              1|dont care     | 1100        |input are real, log-magnitude samples and no operation is needed inside HWA
 * 1     |              1|              0|3             | 0111        |input are complex samples and HWA should perform log-magnitude operation
 * 2     |              0|              1|dont care     | 1000        |input are real, magnitude samples and no operation is needed inside HWA
 * 3     |              0|              0|2             | 0010        |input are complex samples and HWA should perform magnitude operation
 * 4     |              0|              1|dont care     | 1000        |input are real, magnitude-sqr samples and no operation is needed inside HWA
 * 5     |              0|              0|0             | 0000        |input are complex samples and HWA should perform magnitude-sqr operation
 * 6     |              0|              0|3             | 0110        |input are complex samples and HWA should perform log-magnitude with linear cfar operation
 * @{
 */
#define HWA_CFAR_OPER_MODE_LOG_INPUT_REAL                  0U     /**<  input are real samples in log scale and no operation is needed inside HWA */
#define HWA_CFAR_OPER_MODE_LOG_INPUT_COMPLEX               1U     /**<  input are complex samples and HWA should perform log-magnitude operation log cfar */
#define HWA_CFAR_OPER_MODE_MAG_INPUT_REAL                  2U     /**<  input are real, magnitude samples and no operation is needed inside HWA */
#define HWA_CFAR_OPER_MODE_MAG_INPUT_COMPLEX               3U     /**<  input are complex samples and HWA should perform magnitude operation */
#define HWA_CFAR_OPER_MODE_MAG_SQR_INPUT_REAL              4U     /**<  input are real, magnitude-sqr samples and no operation is needed inside HWA */
#define HWA_CFAR_OPER_MODE_MAG_SQR_INPUT_COMPLEX           5U     /**<  input are complex samples and HWA should perform magnitude-sqr operation */
#define HWA_CFAR_OPER_MODE_LOG_INPUT_COMPLEX_LINEARCFAR    6U     /**<  input are complex samples. and HWA should perform log-magnitude, linear cfar */
/** @} */

/**
 * \defgroup HWA_CFAR_OUTPUT_MODE       HWA_CFAR_OUTPUT_MODE
 * \brief  Macros that define values for the output of CFAR block
 *
 * @details
 *             Value  |CFAR_ADV_ | CFAR_OUT|  I channel                           | Q channel
                      | OUT_MODE | _MODE   |                                      |
 *             0      |  0       |  00     | Noise average values for all cells   | Cell under test
 *             1      |  0       |  01     | Noise average values for all cells   | Binary detection flag
 *             2      |  0       |  10     | Peak Index                           | Surrounding noise value
 *             3      |  0       |  11     | Peak Index                           | Cell under test value
 *             4      |  1       |  01     | Input Array(I channel)And'ed with    | Input Array (Q channel) And'ed
                                           | binary detection result flag         | with binary detection result flag
 * @{
 */
#define HWA_CFAR_OUTPUT_MODE_I_nAVG_ALL_Q_CUT                   ((uint8_t)0U)     /**<  I channel=Noise average values for all cells;
                                                                                    Q channel=Cell under test (CUT) */
#define HWA_CFAR_OUTPUT_MODE_I_nAVG_ALL_Q_DET_FLAG              ((uint8_t)1U)     /**<  I channel=Noise average values for all cells;
                                                                                      Q channel=Binary detection flag */
#define HWA_CFAR_OUTPUT_MODE_I_PEAK_IDX_Q_NEIGHBOR_NOISE_VAL    ((uint8_t)2U)     /**<  I channel=Peak Index;
                                                                                        Q channel=Surrounding noise value */
#define HWA_CFAR_OUTPUT_MODE_I_PEAK_IDX_Q_CUT                   ((uint8_t)3U)     /**<  I channel=Peak Index;
                                                                                      Q channel=Cell under test (CUT) */
                                                                                  /**<  Q channel = input Array (Q channel) And'ed with binary detection result */
/** @} */

/**
 * @defgroup HWA_COMPRESS_MODE       HWA_COMPRESS_MODE
 * @brief    Macros that define values for the selecting either the
 *           compression or the decompression mode of CMP_DCMP_Engine
 * @details
 *             Value  |  Mode
 *             ------ | ------------------
 *             0      |  Compression
 *             1      |  Decompression
 * @{
 */
#define HWA_CMP_DCMP_COMPRESS                ((uint8_t)0U)     /**< Compression mode. */
#define HWA_CMP_DCMP_DECOMPRESS               ((uint8_t)1U)     /**< Decompression mode. */
/** @}*/ /*HWA_COMPRESS_MODE*/


/**
 * @defgroup HWA_CMP_METHOD       HWA_CMP_METHOD
 * @brief    Macros that define the compression method
 * @details
 *             Value  |  Mode
 *             ------ | ------------------
 *             0      |  EGE Compression/Decompression
 *             1      |  BFP Block floating point algorithm
 * @{
 */
#define HWA_COMPRESS_METHOD_EGE                  ((uint8_t)0U)     /**< Exponential Golomb Encoder Compression. */
#define HWA_COMPRESS_METHOD_BFP                  ((uint8_t)1U)    /*!<  Block Floating point algorithm */
/** @}*/ /*HWA_CMP_METHOD*/

/**
 * @defgroup HWA_COMPRESS_PATHSELECT       HWA_COMPRESS_PATHSELECT
 * @brief    Macros that allow/disallow two pass operation for compression.
 *           the first pass (optimization step) finds the optimal parameters
 *           for compression and the second pass compresses the data and writes 
 *           it to the output buffer. 
 *           Both first and second passes should be enabled. 
 * @details
 *             Value  |  Mode
 *             ------ | ------------------
 *             3      |  1st and 2nd pass are enabled
 * @{
 */
#define HWA_COMPRESS_PATHSELECT_BOTHPASSES   ((uint8_t)3U)     /**< 1st and 2nd pass are enabled. */
/** @}*/ /*HWA_COMPRESS_PATHSELECT*/

/**
 * @defgroup HWA_RAM_TYPE       HWA_RAM_TYPE
 * @brief    Macros that define values for the ramType argument of HWA_configRam() function.
 * @{
 */
#define HWA_RAM_TYPE_WINDOW_RAM             ((uint8_t)0U)         /**< WINDOW RAM for windowing operation */
#define HWA_RAM_TYPE_INTERNAL_RAM           ((uint8_t)1U)         /**< Internal RAM for Vector Multiplication mode */
/** @}*/ /*HWA_RAM_TYPE*/

/**
 * @defgroup HWA_INTERFERENCE_ENABLE       HWA_INTERFERENCE_ENABLE
 * @brief    Enable/Disable for Interference zeroing-out 
 *           This register bit controls the enable/disable 
 *           for the interference zero-ing feature. 
 *           The feature is enabled if this register bit is set to 1.
 * @{
*/
#define HWA_INTERFERENCE_ENABLE             ((uint8_t)1U)
#define HWA_INTERFERENCE_DISABLE            ((uint8_t)0U)
/** @} */

/**
 * @defgroup HWA_INTERFERENCE_THRESH_MODE      HWA_INTERFERENCE_THRESH_MODE
 * @brief    Interference detection mode selection:
 *           This register is used to control the mode for interference detection in the Interference localization block.
 *           00 : Magnitude OR Magnitude difference
 *           01:  Only Magnitude difference
 *           10:  Only Magnitude
 *           11 : Magnitude AND Magnitude difference
 * @{
*/
#define HWA_INTERFERENCE_THRESH_MODE_MAG_OR_MAGDIFF             ((uint8_t)0U)
#define HWA_INTERFERENCE_THRESH_MODE_MAG                        ((uint8_t)1U)
#define HWA_INTERFERENCE_THRESH_MODE_MAGDIFF                    ((uint8_t)2U)
#define HWA_INTERFERENCE_THRESH_MODE_MAG_AND_MAGDIFF            ((uint8_t)3U)
/** @} */

/**
 * @defgroup  HWA_INTERFERENCE_THRESH_SELECT     HWA_INTERFERENCE_THRESH_SELECT
 * @brief     Select the source of interference threshold
 *            0 : User-defined threshold via INTERFTHRESH_MAG_SW and INTERFTHRESH_MAGDIFF_SW
 *            1 : Single threshold based on built-in interference statistics outputs using sum value across collected interference statistics 
 *            2 : Threshold based on built-in interference statistics outputs, with each statistic being used for corresponding iteration (RX channel)
 * @{
*/
#define HWA_INTERFERENCE_THRESH_SELECT_USER_DEFINED                        ((uint8_t)0U)
#define HWA_INTERFERENCE_THRESH_SELECT_BUILTIN_SUM_STATS                   ((uint8_t)1U)
#define HWA_INTERFERENCE_THRESH_SELECT_BUILTIN                             ((uint8_t)2U)
/** @} */ 

/**
 * @defgroup  HWA_INTERFERENCE_STATS_RESET     HWA_INTERFERENCE_STATS_RESET
 * @brief     Reset mode control for Interference statistics accumulators:
 *            Controls the reset behavior for all 12 magnitude and magdiff accumulators. 
 *            00 : Hold Accumulator state without updating
 *            01 : Free-running accumulator mode
 *            10 : Reset at start of parameter-set (i.e.,per-chirp accumulation). 
 *            11 : Reset at start of parameter-set only if loop counter is 0 (i.e., per-frame)
 * @{
*/
#define HWA_INTERFERENCE_STATS_RESET_HOLD                            ((uint8_t)0U)
#define HWA_INTERFERENCE_STATS_RESET_FREE_RUNNING                    ((uint8_t)1U)
#define HWA_INTERFERENCE_STATS_RESET_PER_CHIRP                       ((uint8_t)2U)
#define HWA_INTERFERENCE_STATS_RESET_PER_FRAME                       ((uint8_t)3U)
/** @} */

/**
 * \defgroup HWA_ACCUMULATORREG_TYPE       HWA_ACCUMULATORREG_TYPE
 * \brief  Macros that define values for different type of accumulator registers of HWA_readAccumulatorReg() function.
 * @{
*/
#define HWA_ACCUMULATORREG_TYPE_DC                      ((uint8_t)0U)         /**<  DC accumulator */
#define HWA_ACCUMULATORREG_TYPE_INTERF_MAG              ((uint8_t)1U)         /**<  interference magnitude accumulator */
#define HWA_ACCUMULATORREG_TYPE_INTERF_MAGDIFF          ((uint8_t)2U)         /**<  interference magnitude difference accumulator */
#define HWA_ACCUMULATORREG_TYPE_INTERF                  ((uint8_t)3U)          /**< for reset both INTERF_MAG and INTERF_MAGDIFF accumulators */
/** @} */

/**
 * \defgroup HWA_INTERFERENCE_THRESHOLD_TYPE       HWA_INTERFERENCE_THRESHOLD_TYPE
 * \brief  Macros that define values for different type of accumulator registers of HWA_readAccumulatorReg() function.
 * @{
 */
#define HWA_INTERFERENCE_THRESHOLD_TYPE_MAG             ((uint8_t)0U)         /**<  interference mag threshold register */
#define HWA_INTERFERENCE_THRESHOLD_TYPE_MAGDIFF         ((uint8_t)1U)         /**<  interference magdiff threshold register */
/** @} */

/**
 * \defgroup HWA_PARAMDONE_INTERRUPT_TYPE       HWA_PARAMDONE_INTERRUPT_TYPE
 * \brief  Macros that define values for the destination of interrupt (CPU or DMA)
             when the paramset is completed. The interrupt type HWA_PARAMDONE_INTERRUPT_TYPE_CPU
             may not be supported on all versions of the IP - see \ref HWA_Attrs::isConcurrentAccessAllowed.
 * @{
 */
#define HWA_PARAMDONE_INTERRUPT_TYPE_CPU              ((uint8_t)1U)   /**< Interrupt CPU when paramset is completed */
#define HWA_PARAMDONE_INTERRUPT_TYPE_DMA              ((uint8_t)2U)   /**< Trigger DMA when paramset is completed */
/** @} */

/**
 * \defgroup HWA_COMMONCONFIG_MASK      HWA_COMMONCONFIG_MASK
 * \brief  Macros that define values to use for \ref HWA_CommonConfig::configMask when specifying which values in
 *           the \ref HWA_CommonConfig are valid.
 * @{
 */
#define HWA_COMMONCONFIG_MASK_NUMLOOPS              0x00000001U      /**<  Use when \ref HWA_CommonConfig::numLoops is valid*/
#define HWA_COMMONCONFIG_MASK_PARAMSTARTIDX         0x00000002U      /**< Use when \ref HWA_CommonConfig::paramStartIdx is valid*/
#define HWA_COMMONCONFIG_MASK_PARAMSTOPIDX          0x00000004U      /**< Use when \ref HWA_CommonConfig::paramStopIdx is valid*/
#define HWA_COMMONCONFIG_MASK_FFT1DENABLE           0x00000008U      /**< Use when \ref HWA_CommonConfig::fft1DEnable is valid*/
#define HWA_COMMONCONFIG_MASK_BPMRATE               0x00000010U      /**< Use when \ref HWA_CommonConfig::bpmRate is valid*/
#define HWA_COMMONCONFIG_MASK_BPMPATTERN            0x00000020U      /**< Use when \ref HWA_CommonConfig::bpmPattern is valid*/
#define HWA_COMMONCONFIG_MASK_INTERFERENCETHRESHOLD 0x00000040      /**< Use when \ref HWA_CommonConfig::interferenceThreshold is valid*/
#define HWA_COMMONCONFIG_MASK_TWIDDITHERENABLE      0x00000080U      /**< Use when \ref HWA_CommonConfig::twidDitherEnable is valid*/
#define HWA_COMMONCONFIG_MASK_LFSRSEED              0x00000100U      /**< Use when \ref HWA_CommonConfig::lfsrSeed is valid*/
#define HWA_COMMONCONFIG_MASK_FFTSUMDIV             0x00000200U      /**< Use when \ref HWA_CommonConfig::fftSumDiv is valid*/
#define HWA_COMMONCONFIG_MASK_CFARTHRESHOLDSCALE    0x00000400U      /**< Use when \ref HWA_CommonConfig::cfarThresholdScale is valid*/
#define HWA_COMMONCONFIG_MASK_I_CMULT_SCALE         0x00000800U      /**< Use when \ref HWA_CommonConfig::i_cmult_scale is valid*/
#define HWA_COMMONCONFIG_MASK_Q_CMULT_SCALE         0x00001000U      /**< Use when \ref HWA_CommonConfig::q_cmult_scale is valid*/
#define HWA_COMMONCONFIG_MASK_DCEST_SCALESHIFT      0x00002000U      /**<  use when \ref HWA_CommonConfig::scale and\ref HWA_CommonConfig::shift are valid */
#define HWA_COMMONCONFIG_MASK_DCSUB_SWVAL           0x00004000U      /**<  use when \ref HWA_CommonConfig::swIVal and \ref HWA_CommonConfig::swQVal are valid */
#define HWA_COMMONCONFIG_MASK_INTERFMAG_THRESHOLD   0x00008000U      /**<  Use when \ref HWA_CommonConfig::thresholdMagSw is valid */
#define HWA_COMMONCONFIG_MASK_INTERFMAGDIFF_THRESHOLD  0x00010000U    /**<  Use when \ref HWA_CommonConfig::thresholdMagDiffSw is valid */
#define HWA_COMMONCONFIG_MASK_INTERFSUM_MAG            0x00020000U      /**<  Use when \ref HWA_CommonConfig::sumMagScale and \ref HWA_CommonConfig::sumMagShift are valid */
#define HWA_COMMONCONFIG_MASK_INTERFSUM_MAGDIFF        0x00040000U      /**<  Use when \ref HWA_CommonConfig::sumMagDiffScale and \ref HWA_CommonConfig::sumMagDiffShift are valid */
// #define HWA_COMMONCONFIG_MASK_COMPLEXMULT_SCALEARRAY   ((uint64_t)0x00004000U)      /**<  Use when \ref HWA_CommonConfig::Iscale and \ref HWA_CommonConfig::Qscale are valid,
//                                                                                        \ref HWA_ComplexMultiply::mode = HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT, or HWA_COMPLEX_MULTIPLY_MODE_VEC_MULT,
//                                                                                        and with HWA_ComplexMultiply:scaleCmultScaleEn = 1 or HWA_ComplexMultiply::cmultScaleEn=1 */
// #define HWA_COMMONCONFIG_MASK_COMPLEXMULT_SCALECONST   ((uint64_t)0x00008000U)      /**<  Use when \ref HWA_CommonConfig::Iscale and \ref HWA_CommonConfig::Qscale are valid,
//                                                                                         \ref HWA_ComplexMultiply::mode = HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT, or HWA_COMPLEX_MULTIPLY_MODE_VEC_MULT,
//                                                                                         and with \ref HWA_ComplexMultiply::scaleCmultScaleEn = 0 or \ref HWA_ComplexMultiply::cmultScaleEn = 0 */
// #define HWA_COMMONCONFIG_MASK_INTERF_MITG_WINDOW_PARAM  ((uint64_t)0x40000000U)      /**<  Use when \ref HWA_CommonConfig::mitigationWindowParam array is valid */
#define HWA_COMMONCONFIG_MASK_EGECOMRESS_KPARAM       0x00080000U      /**< Use when \ref HWA_CommonConfig::EGEKparam is valid*/
#define HWA_COMMONCONFIG_MASK_CFAR_DET_THR            0x00100000U    /**<  Use when \ref HWA_CommonConfig::cfarDetthreshold is valid */
/** @} */

/**
 * \defgroup HWA_COMPLEX_MULTIPLY_MODE      HWA_COMPLEX_MULTIPLY_MODE
 * \brief  Macros that define values for the various modes of the Complex multiply block
 * @{
 */
#define HWA_COMPLEX_MULTIPLY_MODE_DISABLE                   ((uint8_t)0U)    /**  0-disable */
#define HWA_COMPLEX_MULTIPLY_MODE_FREQ_SHIFTER              ((uint8_t)1U)    /**  1-Freq Shifter mode, see \ref HWA_ComplexMultiply::freqShiftTwiddleIncr  */
#define HWA_COMPLEX_MULTIPLY_MODE_SLOW_DFT                  ((uint8_t)2U)    /**  2-slow DFT mode, see \ref HWA_CommonConfig::modeCfg::slowDFT::startFreq */
#define HWA_COMPLEX_MULTIPLY_MODE_FFT_STITCHING             ((uint8_t)3U)    /**  3-FFT stitching mode, see \ref HWA_CommonConfig::modeCfg::FFTstitching::twiddlePattern and HWA_CommonConfig::modeCfg::FFTstitching::winInterpolateMode */
#define HWA_COMPLEX_MULTIPLY_MODE_MAG_SQUARED               ((uint8_t)4U)    /**  4-Magnitude Squared mode */
#define HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT               ((uint8_t)5U)    /**  5-Scalar Multiplication mode, see \ref HWA_CommonConfig::modeCfg::scalerMultiply::scaleCmultScaleEn */
#define HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT               ((uint8_t)6U)    /**  6-Vector Multiplication mode, see \ref HWA_CommonConfig::modeCfg::vectorMultiplyMode1::cmultScaleEn and HWA_CommonConfig::modeCfg::vectorMultiplyMode1::ramAddrOffset */
#define HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT_2             ((uint8_t)7U)    /**  7-Vector Multiplication mode 2, see \ref HWA_CommonConfig::modeCfg::vectorMultiplyMode2::ramAddrOffset */
/** @} */

/**
 * \defgroup HWA_DCEST_INTERFSUM_RESET_MODE     HWA_DCEST_INTERFSUM_RESET_MODE
 * \brief  Macros that define values for the various reset modes in pre-processing block,
 *           appied to DCESTRESET and INTERFSUMRESET
 * @{
 */
#define HWA_DCEST_INTERFSUM_RESET_MODE_NOUPDATE                     ((uint8_t)0U)     /**  Hold the internal accumulators without updating */
#define HWA_DCEST_INTERFSUM_RESET_MODE_SOFTWARERESET                ((uint8_t)1U)     /**  free-running without automatic reset, software can reset the accumulators by writing to either DC_EST_RESET_SW register for DC accumulator, or INTF_STATUS_RESET_SW for interference statistics */
#define HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET                   ((uint8_t)2U)     /**  Reset the internal accumulators at the start of parameter set (i.e per chirp accumulation) */
#define HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET_ZEROLPCONT        ((uint8_t)3U)     /**  Reset the internal accumulators at the start of parameter set only if loop counter is 0 (i.e per frame accumulation) */
/** @} */

/**
 * \defgroup HWA_DCSUB_SELECT     HWA_DCSUB_SELECT
 * \brief  Macros that define values for the various source select of threshold in pre-processing block
 * @{
 */
#define HWA_DCSUB_SELECT_DCSW                    ((uint8_t)0U)     /**  DC subtracted value comes from user defined through DC_I_SW[12] and DC_Q_SW[12] register */
#define HWA_DCSUB_SELECT_DCEST                   ((uint8_t)1U)     /**  DC subtracted value comes from built-in DC estimation hardware, DC_EST_I_VAL[12] and DC_EST_I_VAL[12] registers */
/** @} */

/**
 * \defgroup HWA_FFT_STITCHING_TWID_PATTERN     HWA_FFT_STITCHING_TWID_PATTERN
 * \brief  Macros that define values for the complex multiply block with FFT stitching mode. Useful for 4K and 8K
 *           FFT calculation, set the last 2 bits in TWIDINCR register, the rest 12 bits should be set to 0.
 * @{
 */
#define HWA_FFT_STITCHING_TWID_PATTERN_2K                   ((uint8_t)0U)     /** 2K fft stitching twid factor pattern */
#define HWA_FFT_STITCHING_TWID_PATTERN_4K                   ((uint8_t)1U)     /** 4K fft stitching twid factor pattern */
/** @} */

/** @} */

/* ========================================================================== */
/*                         Structures and Enums                               */
/* ========================================================================== */

/**
 *  \brief    A handle that is returned from a HWA_open() call.
 */
typedef void* HWA_Handle;

/**
 *  \brief  HWA Interrupt callback function after every paramset completion
 *
 *  HWA Interrupt callback function to be used with HWA_enableParamSetInterrupt() call
 *
 */
typedef void (*HWA_ParamDone_IntHandlerFuncPTR)(uint32_t paramSet, void * arg);

/**
 *  \brief  HWA Interrupt callback function after all paramsets completion
 *
 *  HWA Interrupt callback function to be used with HWA_enableDoneInterrupt() call
 *
 */
typedef void (*HWA_Done_IntHandlerFuncPTR)(void * arg);

/**
 *  \brief  HWA H/W Parameters
 *
 *  HWA parameters are used to with the HWA_open() call.
 *
 */
typedef struct HWA_Attrs_t {
    uint32_t                instanceNum;                /**<  HWA Instance num - this is related to actual H/W instance of this IP */
    volatile uint32_t       ctrlBaseAddr;               /**<  HWA Peripheral's base address for the control/common register space */
    volatile uint32_t       paramBaseAddr;              /**<  HWA Peripheral's base address for the paramset space */
    volatile uint32_t       ramBaseAddr;                /**<  HWA Peripheral's base address for the Window/Internal RAM space */
    volatile uint32_t       dssBaseAddr;                /**<  DSS base address for the common settings */
    uint32_t                numHwaParamSets;            /**<  Number of HWA paramsets in this instance */
    uint32_t                intNumParamSet;             /**< HWA Peripheral's interrupt vector for individual paramset completion*/
    uint32_t                intNumDone;                 /**<  HWA Peripheral's interrupt vector for completion of all programmed paramset in background thread */
    uint32_t                numDmaChannels;             /**<  Number of DMA channels available for HWA (src or dst) */
    volatile uint32_t       accelMemBaseAddr;           /**<  HWA Accelerator processing memory base address */
    uint32_t                accelMemSize;               /**<  HWA Accelerator processing memory size in bytes */
    bool                    isConcurrentAccessAllowed;  /**<  Flag to say if read access of Common Registers is allowed in hardware when
                                                             HWA is executing paramsets */
    bool                    isCompressionEnginePresent; /**< Flag to say if the compression engine is present in hardware.*/
} HWA_Attrs;

/**
 *  \brief  HWA RAM Parameters
 *
 *  HWA parameters are used to with the HWA_configRam() call.
 *
 */
typedef struct HWA_RAMAttrs_t
{
    uint32_t      ramBaseAddress;                     /**<  HWA RAM base address */
    uint32_t      ramSizeInBytes;                     /**<  HWA RAM size in bytes */
} HWA_RAMAttrs;

/**
 *  \brief  Source trigger DMA parameters
 *
 *  Source trigger DMA parameters that the user can use to configure a generic DMA channel to trigger the HWA
 *
 *  Note: source and destination addresses represent CPU view of HWA address.
 *        Depending on the SOC and the dma engine which is used for transfer, they may need to be translated by caller.
 *
 *  Example: SOC_translateAddr API with SOC_TranslateAddr_Dir_TO_EDMA should be used
 *           when passing it to EDMA API for configuration.
 */
typedef struct HWA_SrcDMAConfig_t {
    uint32_t       srcAddr;             /**<  source Address for the DMA programming */
    uint32_t       destAddr;            /**<  destination Address for the DMA programming */
    uint16_t       aCnt;                /**<  A count for the DMA programming */
    uint16_t       bCnt;                /**<  B count for the DMA programming */
    uint16_t       cCnt;                /**<  C count for the DMA programming */
} HWA_SrcDMAConfig;

/**
 *  \brief  HWA Common Config
 *
 *  HWA common config parameters that are used with the HWA_ConfigCommon() call.
 *
 */
typedef struct HWA_CommonConfig_t {
    uint32_t            configMask;             /**< See \ref HWA_COMMONCONFIG_MASK macros for correct values.
                                                     Set this to specify which of the fields are valid when calling 
                                                     HWA_ConfigCommon API. */
    uint16_t            numLoops;               /**< number of loops to run from paramStartIdx to paramStopIdx 
                                                     valid value (12 bits): 0-4094; 4095 for infinitie. 
                                                     Sets the NUMLOOPS */
    uint8_t             paramStartIdx;          /**< start index of paramset through which state machine loops through 
                                                     valid value: 5bits (0-31)
                                                     Sets the PARAMSTART */
    uint8_t             paramStopIdx;           /**< stop index of paramset through which state machine loops through 
                                                     valid value: 5bits (0-31)
                                                     Sets the PARAMSTOP */

    struct {
        uint8_t         fft1DEnable;            /**< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                        Setting to 1 enables HWA in FFT1D mode - ACCEL_MEM0 and ACCEL_MEM1 
                                                        are assumed to be shared with the ping-pong ADC buffers.
                                                        At the end of the active transmission portion of a frame, this bit can be reset,
                                                        so that the accelerator has access to all the four local memories independently.
                                                     Sets FFT1DEN bit of HWACCREG1 */
        uint16_t        bpmRate;                /**< 10 bit value: specifies the number of input samples corresponding to each BPM chip.
                                                        value of 0 is invalid
                                                     Sets BPMRATE bits in HWACCREG7 */
        uint32_t        bpmPattern[2];          /**< 64-bit value: specifies a Binary Phase Modulation (BPM) pattern to be removed on 
                                                        the input samples prior to FFT
                                                     Sets HWACCREG5 (MSB,bpmPattern[1])  and HWACCREG6 (LSB,bpmPattern[0]) registers */
        uint32_t        interferenceThreshold;  /**< 24-bit value: Interference zero-out threshold - is used to zero-out sample(s), 
                                                        whose magnitude (24-bit absolute value of the 24-bit complex input)
                                                        is very high, prior to computing the FFT 
                                                        The HWA_AccelModeFFT_t::interfZeroOutEn field should be enabled
                                                        in the intended paramset for this threshold to be used*/ 
        uint8_t         twidDitherEnable;       /**< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                        Setting to 1 Enable Dithering for Twiddle Factors 
                                                        It is recommended to keep this register bit always set to 1 
                                                        (i.e., dithering enabled)
                                                     Sets the DITHERTWIDEN bit in HWACCREG7 register */
        uint32_t        lfsrSeed;               /**< 29-bit value: LFSR seed. Sets the LFSRSEED bits in HWACCREG11 */
        uint8_t         fftSumDiv;              /**< 5-bit value: specifies the number of bits to right-shift the sum statistic (36-bit)
                                                        before it is written to destination memory (24-bit)
                                                     Sets the FFTSUMDIV bits in HWACCREG8 register */
    } fftConfig;
    
    struct {
        uint16_t        scale;                 /**<  9 bit value: scale applied to 12 accumulators. multiplies the
                                                      accumulator outputs by dcEstScale/256. default value is 256, giving a scale of 1.0
                                                      if \ref HWA_PreProcessing::dcEstResetMode is set to HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET
                                                      or HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET_ZEROLPCONT
                                                      sets DC_EST_SCALE in DC_EST CTRL register */

        uint8_t         shift;                 /**<  4 bit value: applied to all 12 accumulator outputs, can not
                                                    bypassed, the accumulator outputs are scaled by 2^(8+2+ \ref HWA_CommonConfig::shift).
                                                    if \ref HWA_PreProcessing::dcEstResetMode is set to HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET
                                                    or HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET_ZEROLPCONT
                                                    sets DC_EST_SHIFT in DC_EST_CTRL register */
    } dcEstimateConfig;

    struct
    {
        int32_t    swIVal[HWA_NUM_RXCHANNELS];        /**<  24 bit value: SW programmed DC values used in subtraction
                                                                if \ref HWA_PreProcessing::dcSubEnable is enabled and
                                                                \ref HWA_PreProcessing::dcSubSelect is set to HWA_DCSUB_SELECT_DCSW.
                                                                sets DC_SW_I_n_val in DC_SW_I_n register */

        int32_t    swQVal[HWA_NUM_RXCHANNELS];        /**<  24 bit value: SW programmed DC values used in subtraction,
                                                                 if \ref HWA_PreProcessing::dcSubEnable is enabled and
                                                                 \ref HWA_PreProcessing::dcSubSelect is set to HWA_DCSUB_SELECT_DCSW.
                                                                 sets DC_SW_Q_n_val bits in DC_SW_Q_n register */
    } dcSubtractConfig;


    struct {

        uint32_t  thresholdMagSw[6U];              /**<  Software Interference threshold for Magnitude
                                                        These registers are used to specify the user-programmed threshold 
                                                        for nulling out samples affected by interference in the Interference localization block.  
                                                        The magnitude of each incoming samples is compared with this
                                                        threshold to decide whether it is corrupted by interference or not. */

        uint32_t  thresholdMagDiffSw[6U];          /**<  Software Interference threshold for Magnitude of backward difference
                                                            These registers are used to specify the user-programmed threshold 
                                                            for nulling samples affected by interference in the Interference localization block.
                                                            The magnitude of backward difference of incoming samples is compared with this 
                                                            threshold to decide whether it is corrupted by interference or not. */



        uint8_t         sumMagScale;               /**<  8 bits value:unsigned 8 bits, 5 integer bits, and 3 fractional bits,
                                                        applied to INTERSUM_MAGn from interference statistics block,
                                                        default value is 8, corresponding to scale 1.0
                                                        if the \ref HWA_PreProcessing::resetMode is set
                                                        to HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET or HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET_ZEROLPCONT
                                                        sets INTERFSUM_MAG_SCALE in INTERFSTATS_CTRL register */

        int8_t          sumMagShift;               /**<  4 bits: right shift after scaling, the shift value is 2^(3+6+interfsumMagShift)
                                                       if the \ref HWA_PreProcessing::resetMode is set
                                                      to HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET or HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET_ZEROLPCONT
                                                       sets INTERFSUM_MAG_SHIFT in  INTERFSTATS_CTRL register */

        uint8_t         sumMagDiffScale;           /**<  8 bits: similar to interfsumMagScale, applied to INTERSUM_MAGDIFFn from interference statistics block,
                                                        if the \ref HWA_PreProcessing::resetMode is set
                                                        to HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET or HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET_ZEROLPCONT
                                                        sets INTERFSUM_MAGDIFF_SCALE in INTERFSTATS_CTRL register */

        int8_t          sumMagDiffShift;           /**<  4 bits: right shift after scaling, similar to interfsumMagShift
                                                       if the \ref HWA_PreProcessing::resetMode is set
                                                       to HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET or HWA_DCEST_INTERFSUM_RESET_MODE_PARAMRESET_ZEROLPCONT
                                                      sets INTERFSUM_MAGDIFF_SHIFT in INTERFSTATS_CTRL register */
     } interfConfig;


    struct {

        int32_t         Iscale[HWA_NUM_RXCHANNELS];     /**<  21 bits: complex scalars used in \ref HWA_ComplexMultiply::mode =  HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT,
                                                               HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT or HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT_2
                                                               sets the ICMULT_SCALEn bits in ICMULT_SCALn registers */

        int32_t         Qscale[HWA_NUM_RXCHANNELS];     /**<  21 bits: complex scalars used in \ref HWA_ComplexMultiply::mode =  HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT,
                                                               HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT or HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT_2
                                                               sets the ICMULT_SCALEn bits in ICMULT_SCALn registers */

        int16_t          twiddleDeltaFrac;              /**<  signed 10 bit value: only applied to if \ref HWA_ComplexMultiply::mode is set to
                                                                HWA_COMPLEX_MULTIPLY_MODE_FREQSHIFT_FREQINCRE, frequency shifter with frequency increment mode, \ref HWA_ComplexMultiply::twidIncrement
                                                                specifies how much the frequency could change for each successive input sample.
                                                                additionally, twiddleDeltaFrac can be added to the derotation frequency to compensate for doppler induced phase shifts,
                                                                it is reset at the start of paramset execution and again after the paramsets are executed.
                                                                for other modes, it is ignored.
                                                                sets the TWID_INCR_DELTA_FRAC bits in the TWID_INCR_DELTA_FRAC register */

        uint8_t         recWindowReset;                 /**<  1 bit value: resets the param set counter used in Recursive window mode, applied to
                                                                \ref HWA_ComplexMultiply::mode is set to HWA_COMPLEX_MULTIPLY_MODE_RECURSIVE_WIN,
                                                                sets the RECWIN_RESET_SW_RECWIN_RESET_SW bits in the RECWIN_RESET_SW register */
    } complexMultiplyConfig;


    struct {
        uint32_t        cfarThresholdScale;             /**<    18-bit value: specifies the threshold scale factor that is used to
                                                                either multiply or add to the 'surrounding noise average' to determine 
                                                                the threshold used for detection of the present cell under test
                                                                in log mode, this value should be represented as 7.11.
                                                                in mag/mag-sqr mode, this value should be represented as 14.4.
                                                                Sets the CFAR_THRESH bits in HWACCREG13 register */
    } cfarConfig;
    struct {
    uint32_t        cfarDetthreshold;          /**<  24-bit value: specifies the detection threshold value used to
                                                    compare with cell under test. The detection threshold value is
                                                    held constant, independent of surrounding noise level and CFAR_THRESH.
                                                    This configuration is applicable only in constant threshold mode of CFAR
                                                    (i.e. only in CFAR-CA mode and only if CFAR_AVG_LEFT = CFAR_AVG_RIGHT = 0).) */
    } cfarDetThresConfig;
    struct {
        uint32_t    i_cmult_scale[6U];                      /**<    21 bit value: real part of the scalar complex number used for scalar mult mode
                                                                i.e. \ref HWA_ComplexMultiply::mode = HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT
                                                                Sets the ICMULT_SCALE bits of HWACCREG9 */
        uint32_t    q_cmult_scale[6U];                      /**<    21 bit value: imaginary part of the scalar complex number used for scalar mult mode
                                                                i.e. \ref HWA_ComplexMultiply::mode = HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT
                                                                Sets the ICMULT_SCALE bits of HWACCREG10 */
    } scalarMult;

    struct {
        uint8_t EGEKparam[HWA_CMP_K_ARR_LEN];           /**<    An Array of length 8 consisting of 5 bit values: list of k-parameters to be optimized during EGE compression. 
                                                                  Sets the ICMULT_SCALE bits of HWACCREG9 */
    } compressMode;

} HWA_CommonConfig;

/**
 *  \brief  HWA Paramset Config for Input Formatter/Source block
 *
 *  HWA paramset config parameters for the Input Formatter/Source block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call.
 *
 */
typedef struct HWA_SourceConfig_t {
    uint16_t    srcAddr;                    /**< 16 bit value:  specifies the starting address of the input samples
                                                    in the accelerator memory. Value of 0x0000 points to the 
                                                    first byte of accelerator memory and 16-bit value covers 
                                                    the entire address space of the four memories (4x16KB=64 KB)
                                                 Sets the SRCADDR bits of PARAM1_1 */
    uint16_t    srcAcnt;                    /**< 12 bit value: specifies the number of samples (minus 1) from the source memory 
                                                    to process for every iteration. 
                                                    Note: The unit is samples and not bytes.
                                                 Sets the SRCACNT bits of PARAM1_2 */
    int16_t     srcAIdx;                    /**< 16 bit value: specifies the number of bytes separating successive samples 
                                                    in the source memory
                                                 Sets the SRCAINDX bits of PARAM1_3 */
    uint16_t    srcBcnt;                    /**< 12 bit value: specifies the number of times (minus 1) the processing should be iterated
                                                 Sets the BCNT bits of PARAM1_5 */
    int16_t     srcBIdx;                    /**< 16 bit value: Specifies the number of bytes separating the start 
                                                    address of samples for successive iterations in the 
                                                    source memory (in bytes, signed value)
                                                Sets the SRCBIDX bits in PARAM1_4  */
    uint16_t    srcShift;                   /**< 12 bit value: CIRCIRSHIFT specifies the circular shift (offset in samples) that should 
                                                    be applied on the sequence of input samples before feeding them 
                                                    to the Core Computational unit
                                                 Sets the CIRCIRSHIFT bits of PARAM1_7 */
    uint8_t     srcCircShiftWrap;           /**< 4 bit value: indicates at what number (power-of-2) the sample count value should wraparound, 
                                                    when using circular shift.
                                                 Sets the CIRCSHIFTWRAP bits of PARAM1_7 */
    uint8_t     srcRealComplex;             /**< 1 bit value: See \ref HWA_SAMPLES_FORMAT macros for correct values.
                                                    Real or Complex data in the source memory.
                                                 Sets the SRCREAL bits in PARAM1_2*/
    uint8_t     srcWidth;                   /**< 1 bit value: SRC16b32b See \ref HWA_SAMPLES_WIDTH macros for correct values.
                                                    16-bit or 32-bit data width in source memory.
                                                 Sets the SRC16b32b bits in PARAM1_2 */
    uint8_t     srcSign;                    /**< 1 bit value: SRCSIGNED See \ref HWA_SAMPLES_SIGN macros for correct values.
                                                    Signed or Unsigned data in the source memory. 
                                                    This setting is only relevant for srcWidth=0 (16 bits), 
                                                    because that is when sign-extension 
                                                    may be required to convert to internal 24-bit width.
                                                 Sets the SRCSIGNED bits in PARAM1_2 */
    uint8_t     srcConjugate;               /**< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    Enable/Disable Conjugation of the input samples.
                                                        0: No conjugation
                                                        1: Enable conjugation
                                                    This register only makes sense for srcRealComplex=0 (complex). 
                                                    It is useful in conjunction with DSTCONJ to derive an IFFT 
                                                    mode (by conjugating at both input and output)
                                                 Sets the SRCCONJ bit of PARAM1_2 */
    uint8_t     srcScale;                   /**< 4 bit value: REG_SRCSCAL Specifies a programmable scaling, via right bit-shift,
                                                    from 0 bits to 8 bits, for the input samples.
                                                 Sets the SRCSCAL bits of PARAM1_5 (0-8).
                                                 if HWA_SourceConfig::srcWidth = HWA_SAMPLES_WIDTH_16BIT, the 24-bit sample is 
                                                 generated by padding (8-SRCSCAL) zeros at the LSB and SRCSCAL redundant MSBs 
                                                 (sign-extended based on \ref srcSign).
                                                 if HWA_SourceConfig::srcWidth = HWA_SAMPLES_WIDTH_32BIT, the 24-bit sample is 
                                                 generated by dropping SRCSCAL bits at the LSB and clipping (8-SRCSCAL) bits 
                                                 at the MSB */
    uint8_t     bpmEnable;                  /**< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    Enable/Disable for BPM removal operation
                                                        0: disable
                                                        1: enable
                                                 Sets the BPM_EN bits of PARAM1_0*/
    uint8_t     bpmPhase;                   /**< 4 bit value: Specifies the starting phase of the BPM pattern 
                                                    to be applied
                                                 Sets the BPMPHASE bits of PARAM1_6*/
} HWA_SourceConfig;

/**
 *  @brief    HWA Paramset Config for Output Formatter/Destination block
 *
 *  HWA paramset config parameters for the Output Formatter/Destination block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call. 
 *
 */
typedef struct HWA_DestConfig_t {
    uint16_t    dstAddr;                    /**< 16 bit value:  specifies the starting address of the output samples
                                                    in the accelerator memory. Value of 0x0000 points to the 
                                                    first byte of accelerator memory and 16-bit value covers 
                                                    the entire address space of the four memories (4x16KB=64 KB)
                                                 Sets the DSTADDR bits of PARAM1_1 */
    uint16_t    dstAcnt;                    /**< 12 bit value: specifies the number of samples (minus 1) from the destination
                                                    memory to process for every iteration. 
                                                    Note: The unit is samples and not bytes.
                                                 Sets the DSTACNT bits of PARAM1_2 */
    int16_t     dstAIdx;                    /**< 16 bit value: specifies the number of bytes separating successive samples 
                                                    in the destination memory
                                                 Sets the DSTAINDX bits of PARAM1_3 */
    int16_t     dstBIdx;                    /**< 16 bit value: Specifies the number of bytes separating the start 
                                                    address of samples for successive iterations in the 
                                                    destination memory (in bytes, signed value)
                                                 Sets the DSTBIDX bits in PARAM1_4  */
    uint8_t     dstRealComplex;             /**< 1 bit value: See \ref HWA_SAMPLES_FORMAT macros for correct values.
                                                    Real or Complex data in the destination memory.
                                                 Sets the DSTREAL bits in PARAM1_2*/
    uint8_t     dstWidth;                   /**< 1 bit value: See \ref HWA_SAMPLES_WIDTH macros for correct values.
                                                    16-bit or 32-bit alignment of data in destination memory.
                                                 Sets the DST16b32b bits in PARAM1_2 */
    uint8_t     dstSign;                    /**< 1 bit value: See \ref HWA_SAMPLES_SIGN macros for correct values.
                                                    Signed or Unsigned data in the destination memory. 
                                                    This setting is only relevant for dstWidth=0, 
                                                    because that is when sign-extension 
                                                    may be required to convert to internal 24-bit width.
                                                 Sets the DSTSIGNED bits in PARAM1_2 */
    uint8_t     dstConjugate;               /**< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    Enable/Disable Conjugation of the output samples.
                                                        0: No conjugation
                                                        1: Enable conjugation
                                                    This register only makes sense for dstRealComplex=0. 
                                                    It is useful in conjunction with DSTCONJ to derive an IFFT 
                                                    mode (by conjugating at both output and output)
                                                 Sets the DSTCONJ bit of PARAM1_2 */
    uint8_t     dstScale;                   /**< 4 bit value: Specifies a programmable scaling, via right bit-shift,
                                                    from 0 bits to 8 bits, for the output samples.
                                                 Sets the DSTSCAL bits of PARAM1_5 (0-8) The 24-bit complex samples
                                                 are first converted to 32-bit complex samples by zero padding 8 LSBs.
                                                 Then, based on the REG_DSTSCAL register value, a right bit-shift of 0
                                                 to 8 bits is applied (with MSB sign filling, if required).*/
    uint16_t    dstSkipInit;                /**<10 bit value: Number of samples to skip in the beginning (for each 
                                                    iteration) before writing samples to the destination 
                                                    memory.
                                                 Sets the DST_SKIP_INIT bits of PARAM1_5*/
}HWA_DestConfig;

/**
 *  @brief    HWA Paramset Config for FFT block
 *
 *  HWA paramset config parameters for the FFT block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call. 
 *
 */
typedef struct HWA_AccelModeFFT_t{
    uint8_t      fftEn;                     /**< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    Enable/Disable for FFT computation
                                                        0 - FFT disabled (Pipelined FFT sub-block bypassed)
                                                        1 - FFT enabled  (Pipelined FFT sub-block enabled)
                                                Sets the FFT_EN bits of PARAM1_0 */
    uint8_t      fftSize;                   /**< 4 bit value: Specifies FFT size. Actual FFT size is equal to 2^(fftSize)
                                                    Supported values are [1..10], which correspond to FFT sizes [2..1024].
                                                    The actual FFT size should be equal to or larger than srcAcnt
                                                Sets the FFTSIZE bits of PARAM1_6 */
    uint16_t     butterflyScaling;          /**< 10 bit value: 1 bit per butterfly stage. LSB is for last stage and MSB is for the first stage 
                                                    for each bit, 
                                                        0 - MSB is saturated
                                                        1 - convergent rounded at LSB (divide by 2)
                                                    Number of valid bits in this field depends on the fftSize.
                                                Sets the BFLY_SCALING bits of PARAM1_6 */
    uint8_t      interfZeroOutEn;          /**< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    Enable/Disable for interference zeroing out
                                                    HWA_COMMONCONFIG::interferenceThreshold field 
                                                    should be set to a valid value if this field is enabled.
                                                Sets the INTERF_THRESH_EN bits of PARAM1_6 */
    uint8_t      windowEn;                  /**< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    Enable/Disable for Windowing operation
                                                Sets the WINDOW_EN bits of PARAM1_0 */
    uint16_t     windowStart;               /**< 10 bit value: (0-1023) Specifies the offset from the actual Window RAM base address
                                                    and represents the starting address of the window function 
                                                    in the Window RAM. A value of 0x0 means the starting address 
                                                    is the first 32-bit word in the Window RAM, 0x1 is the second 32-bit word and so on.
                                                Sets the WINDOW_START bits of PARAM1_6 */
    uint8_t      winSymm;                   /**< 1 bit value: See \ref HWA_WINDOW_SYMM macros for correct values.
                                                    Indicates whether the window function is symmetric or not
                                                Sets the WINSYMM bits of PARAM1_6 */
    uint8_t      winInterpolateMode;        /**< 2 bit value: See \ref HWA_FFT_WINDOW_INTERPOLATE_MODE macros for correct values.
                                                    Configures linear interpolation for the window coefficients, which is 
                                                    relevant for large-size FFT computation (i.e., FFT sizes of 2K, 4K) that 
                                                    is obtained via stitching multiple smaller-size FFTs.
                                                    (Note: winSymm should be set to 0 when using 4K or 2K mode(
                                                Sets the WINDOW_INTERP_FRACTION bits of PARAM1_7 */
    uint8_t       magLogEn;                  /**< 2 bit value: See \ref HWA_FFT_MODE_MAGNITUDE_LOG2 macros for correct values.
                                                    Enable/Disable for Magnitude and Log2 computation
                                                Sets the ABS_EN, LOG2EN bits of PARAM1_0 */ 
    uint8_t       fftOutMode;                /**< 2 bit value: See \ref HWA_FFT_MODE_OUTPUT macros for correct values.
                                                    Configures the output mode of the FFT Engine path
                                                    For stats mode, following parameters will be overriden in 
                                                    \ref HWA_DestConfig of that paramset
                                                      dstAcnt=4095, dstAIdx=dstBIdx=8, dstWidth=1, dstRealComplex=0.
                                                Sets the FFT_OUTPUT_MODE bits of PARAM1_0 */
} HWA_AccelModeFFT;

/**
 *  @brief    HWA Paramset Config for Compression/Decompression block
 *
 *  HWA paramset config parameters for the FFT block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call.
 *  Some registers (notably EGEkIdx) are not made visible, as they are primarily meant for debu. 
 *
 */
typedef struct HWA_AccelModeCompress_t{
    uint8_t      compressDecompress;                    /**< 1 bit value: See \ref HWA_COMPRESS_MODE macros for correct values.
                                                    Compression/Decompression selection.
                                                        0 - Compression.
                                                        1 - Decompression.
                                                Sets the CMP_DCMP bitl of PARAM1_0 */
    uint8_t      method;                     /**< 3 bit value: Specifies the compression method.
                                                    See \ref HWA_CMP_METHOD macros for correct value.
                                                        0 - EGE Compression/Decompression.
                                                Sets the CMP_METHOD bits of PARAM1_0 */
    uint8_t     ditherEnable;                   /**< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    Enable/Disable for dither in the compression engine.
                                                Sets the CMP_DITHER_EN bit of PARAM1_0 */
    uint8_t      passSelect;                    /**< 2 bit value: See \ref HWA_COMPRESS_PATHSELECT macros for correct values.
                                                    Enable/Disables the different passes in the compression engine.
                                                Sets the CMP_PASS_SEL bits of PARAM1_6 */
    uint8_t     headerEnable;                   /**< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    Enable/Disable for populating the header in the compression engine.
                                                    For decompression, it indicates whether the header is present in the 
						                            compressed input.
                                                Sets the CMP_HEADER_EN bit of PARAM1_6 */

    uint8_t     scaleFactorBW;                 /**< 4 bit value: (0-15) Specifies the size of scale factor (block exponent).
					      	                        In general, to be set to 4 for 16 bit input (Real or complex), and 5 for 32-bit
						                            input. 
                                                    Sets the CMP_SCALEFAC_BW bits of PARAM1_6 */
    uint8_t     BFPMantissaBW;                 /**<  5 bits value: specify the number of bits for mantissa, applied to
                                                     \ref HWA_AccelModeCompress::method is set to HWA_COMPRESS_METHOD_BFP only
                                                     sets the CMP_BFP_MANTISSA_BW bits of register CMPDCMP in paramset */
    uint8_t     scaleFactor;                   /**<  5 bits values: hard coded scale factor for BFP, only if first pass is disabled.,
                                                     sets the CMP_SCALEFAC bits of register CMPDCMP in paramset */
                                                     
    uint8_t     EGEKarrayLength;                 /**< 4 bit value: (0-3) Specifies the size of 'K parameter' array. 
                                                Sets the CMP_EGE_K_ARR_LEN bits of PARAM1_6 */
                                                
} HWA_AccelModeCompress;

/**
 *  @brief    HWA Paramset Config for ComplexMultiply block
 *
 *  HWA paramset config parameters for the ComplexMultiply block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call. 
 *
 */
typedef struct HWA_ComplexMultiply_t {
    uint8_t      mode;                      /**< 3 bit value: See \ref HWA_COMPLEX_MULTIPLY_MODE macros for correct values.
                                                Configuration for the Complex Multiplier block
                                                Sets the CMULT_MODE bits of PARAM1_0 */
    union {
        uint16_t    twidIncrement;          /**< 14 bit value: used when \ref HWA_ComplexMultiply::mode
                                                is HWA_COMPLEX_MULTIPLY_MODE_FREQ_SHIFTER and specifies how the LUT read index
                                                is incremented for every successive input sample and hence it controls
                                                the de-rotation frequency
                                                Sets the TWIDINCR bits of PARAM1_7 */
        struct {
            uint16_t    startFreq;          /**< 14 bit value: used when \ref HWA_ComplexMultiply::mode = HWA_COMPLEX_MULTIPLY_MODE_SLOW_DFT
                                                and specifies starting frequency for the DFT computation
                                                Sets the TWIDINCR bits of PARAM1_7 */
            uint8_t     freqIncrement;      /**< 4 bit value: used when \ref HWA_ComplexMultiply::mode = HWA_COMPLEX_MULTIPLY_MODE_SLOW_DFT
                                                and specifies the increment value by which the frequency increments in every iteration.
                                                Supported values are [0..14]
                                                The true increment value is 2^(14-freqIncrement).
                                                Sets the FFTSIZE bits of PARAM1_6 */
        } dft;
        uint8_t     twidFactorPattern;      /**< 2 bit value: See \ref HWA_FFT_STITCHING_TWID_PATTERN macros for correct values.
                                                    This field is used when \ref HWA_ComplexMultiply::mode = HWA_COMPLEX_MULTIPLY_MODE_FFT_STITCHING
                                                    and conveys the twid factor pattern to be used.
                                                    0: 2K (2x1024) size FFT stitching twiddle factor pattern
                                                    1: 4K (4x1024) size FFT stitching twiddle factor pattern
                                                    other values are invalid
                                                Sets the TWIDINCR bits of PARAM1_7 */
    }cmpMulArgs;
}HWA_ComplexMultiply;

/**
*  \brief  HWA Paramset Config for pre-processing block
*
*  HWA paramset config parameters for the preprocessing block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call.
*
*/
typedef struct HWA_PreProcessing_t {

    uint8_t      dcEstResetMode;            /**<  controls the reset behavior for all 12 accumulators,
                                               see \ref HWA_DCEST_INTERFSUM_RESET_MODE macros for correct values.
                                               set into HWA_DCEST_INTERFSUM_RESET_MODE_NOUPDATE to bybass DC estimation.
                                               sets the bits DCEST_RESET_MODE in register PREPROC in paramset */

    uint8_t      dcSubEnable;               /**<  enable/bypass DC subtraction, see \ref HWA_FEATURE_BIT macros for correct values.
                                                  set into HWA_FEATURE_BIT_DISABLE to disable the DC subtraction.
                                                  sets the bits DCSUB_EN of the register PREPROC in paramset */

    uint8_t      dcSubSelect;               /**<  see \ref HWA_DCSUB_SELECT macros for the correct values
                                                  sets bits DCSUB_SELECT of the register PREPROC in paramset */

    struct {
        uint8_t      thresholdEnable;       /**<  enable/disable interference marking out, see \ref HWA_FEATURE_BIT macros for correct values
                                                   if set into  HWA_FEATURE_BIT_DISABLE to disable the interference localization.
                                                   sets the bits INTERFTHRESH_EN of the register PREPROC in paramset */

        uint8_t      thresholdMode;         /**<  specifies interference threshold mode, see \ref HWA_INTERFERENCE_THRESH_MODE macros
                                                   for the correct values
                                                   sets the bits INTERFTHRESH_MODE of the register PREPROC in paramset */

        uint8_t      thresholdSelect;       /**<  select the source of the threshold, see \ref HWA_INTERFERENCE_THRESH_SELECT macros
                                                  for the correct values
                                                  sets bits INTERFTHRESH_SELECT of the register PREPROC in paramset */


    } interfLocalize;

    struct {
       uint8_t      resetMode;              /**<  control reset behavior for all mag sum and magdiff sum accumulators,
                                                   if it is set to HWA_DCEST_INTERFSUM_RESET_MODE_NOUPDATE, it is bypassed.
                                                   see \ref HWA_DCEST_INTERFSUM_RESET_MODE macros for the correct values
                                                   sets the INTERFSUM_MAG_RESET bits of the register PREPROC in paramset */

    } interfStat;

    // struct {

    //     uint8_t      enable;                  /**<  enable/disable interference mitigation path, see \ref HWA_FEATURE_BIT macros
    //                                             for the correct values
    //                                             sets the bits INTF_MITG_EN of register PRE_PROCESSING in paramset */

    //     uint8_t      countThreshold;          /**<  5 bits value: the number of non-zero IIB within the hysteresis window
    //                                             should exceed the threshold for the CUT to be considered to be affected
    //                                             by interference. valid values are from 0 to 31.
    //                                             sets the bits INTF_MITG_CNTTHRESH of the register PRE_PROCESSING in paramset */

    //     uint8_t      pathSelect;              /**<  see \ref HWA_INTERFMITIGATION_PATH_SELECT macros for the correct values, select
    //                                              one of the three paths in the interference mitigation module
    //                                              sets the bits INFT_MITG_PATH_SEL of register PRE_PROCESSING in paramset */

    //     uint8_t      leftHystOrder;           /**<  4 bits value: the length of the IIB array considered on the left side of the CUT,
    //                                              valid values from 0 to 15.
    //                                              sets the bits INTF_MITG_LEFT_HYST_ORD of the register PRE_PROCESSING in paramset */

    //     uint8_t      rightHystOrder;          /**<  4 bits value: he length of the IIB array considered on the right side of the CUT,
    //                                               valid values from 0 to 15.
    //                                               sets the bits INTF_MITG_RIGHT_HYST_ORD of the register PRE_PROCESSING in paramset */

    // } interfMitigation;

    // uint8_t     chanCombEn;                   /**<  enable/disable synthetic channel combining, see \ref HWA_FEATURE_BIT
    //                                               macros for the correct values. if set into HWA_FEATURE_BIT_DISABLE to disable
    //                                               the channel combining.
    //                                               sets the bits CHANCOMB_EN of the register PREPROC in paramset */

    // uint8_t      zeroInsertEn;              /**<  enable/disable zero-insertion, fill the zeros at arbitrary
    //                                         locations in the A-dimension, prior to windowing and FFT, only applied to FFTSIZE
    //                                         upto 256. see \ref HWA_FEATURE_BIT macros for the correct values
    //                                         sets the bits ZEROINSERT_EN of register BFLYFFT in paramset */

    //HWA_ComplexMultiply     complexMultiply;  /**<  Complex multiply related params used when \ref HWA_ParamConfig::accelMode
    //                                               is not \ref HWA_ACCELMODE_CFAR */
} HWA_PreProcessing;

/**
 *  @brief    HWA Paramset Config for CFAR block
 *
 *  HWA paramset config parameters for the CFAR block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call. 
 *
 */
typedef struct HWA_AccelModeCFAR_t{
    uint8_t      numNoiseSamplesLeft;       /**< 6 bit value: specify the number of samples used for noise averaging
                                                    to the left of the cell under test.
                                                    Note: The actual number of samples used for noise averaging in H/W is equal 
                                                    to the value of this field multiplied by 2
                                                Sets the CFAR_AVG_LEFT (add note of factor of 2) bits of PARAM1_7 */
    uint8_t      numNoiseSamplesRight;      /**< 6 bit value: specify the number of samples used for noise averaging
                                                    to the right of the cell under test.
                                                    Note: The actual number of samples used for noise averaging in H/W is equal 
                                                    to the value of this field multiplied by 2
                                                Sets the CFAR_AVG_RIGHT (add note of factor of 2) bits of PARAM1_7 */
    uint8_t      numGuardCells;             /**< 3 bit value: specifies the number of guard cells to ignore on either side of the cell under test
                                                Sets the CFAR_GUARD_INT bits of PARAM1_6 */
    uint8_t      nAvgDivFactor;             /**< 4 bit value: specifies the division factor by which the noise sum calculated from the 
                                                    left and right noise windows are divided by in order to get the final 
                                                    surrounding noise average value.
                                                    The division factor is equal to 2^nAvgDivFactor
                                                    Valid values: 0-8
                                                Sets the CFAR_NOISEDIV (add note) bits of PARAM1_6 */
    uint8_t      nAvgMode;                  /**< 2 bit value: See \ref HWA_NOISE_AVG_MODE_CFAR macros for correct values.
                                                    configures the noise averaging mode in the CFAR detector
                                              Sets the CFAR_CA_MODE bits of PARAM1_7 */
    uint8_t     cfarOsKvalue;               /**<  7 bit value: specifies ordered statistics, in CFAR-OS mode, maximum is 127
                                                 sets the CFAR_OS_KVAL bits of CFAR_CFG register in paramset */
    uint8_t     cfarOsEdgeKScaleEn;         /**<  1 bits: enable scaling of K value for the edge samples in non-cyclic CFAR-OS mode;
                                                 only used in CFAR-oS in non-cyclic mode.
                                                 sets the CFAR_OS_KVAL bits of CFAR_CFG register in paramset */
    uint8_t      operMode;                  /**< See \ref HWA_CFAR_OPER_MODE macros for correct values.
                                                Sets the CFAR_LOG_MODE, CFAR_INP_MODE, CFAR_ABS_MODE bits of PARAM1_0 */
    uint8_t      outputMode;                /**< 2 bit value: See \ref HWA_CFAR_OUTPUT_MODE macros for correct values.
                                                    select the output mode of the CFAR engine
                                                Sets the CFAR_OUT_MODE  bits of PARAM1_7 */
    uint8_t     cfarAdvOutMode;             /**<  Reserved */
    uint8_t      peakGroupEn;               /**< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    specifies whether peak grouping should be enabled
                                                      HWA_FEATURE_BIT_DISABLE - peak grouping is disabled, which means that a peak is declared as detected 
                                                          as long as the cell under test exceeds the threshold
                                                      HWA_FEATURE_BIT_ENABLE - peak is declared as detected only if it the cell under test exceeds the threshold,
                                                          as well as, if the cell under test exceeds the two neighboring cells to its immediate 
                                                          left and right
                                                Sets the CFAR_GROUPING_EN bits of PARAM1_0 */
    uint8_t      cyclicModeEn;              /**< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    specifies whether the CFAR-CA detector needs to work in cyclic mode or in non-cyclic mode
                                                              HWA_FEATURE_BIT_DISABLE=non-cyclic mode
                                                              HWA_FEATURE_BIT_ENABLE=cyclic mode
                                                Sets the CFAR_CYCLIC  bits of PARAM1_0 */
}HWA_AccelModeCFAR;

/**
 *  @brief    HWA Paramset Config
 *
 *  HWA paramset config parameters that are used with the HWA_ConfigParamSet() call. 
 *
 */
typedef struct HWA_ParamConfig_t {
    uint8_t             triggerMode;                /**< See \ref HWA_TRIG_MODE macros for correct values.
                                                         Sets the TRIGMODE bits of PARAM1_0*/
    uint8_t             dmaTriggerSrc;              /**< DMA channel number to be monitored for dma based trigger mode.
                                                            this field is used only when \ref HWA_ParamConfig::triggerMode
                                                            is set to \ref HWA_TRIG_MODE_DMA
                                                         Sets the DMA2ACC_CHANNEL_TRIGSRC bits in PARAM1_0*/
    uint8_t             accelMode;                  /**< 2 bit value: See \ref HWA_ACCELMODE macros for correct values.
                                                            Configures the mode of operation of the accelerator for 
                                                            the current parameter-set.
                                                         Sets the ACCEL_MODE bits of PARAM1_0*/
    HWA_SourceConfig    source;                     /**< Source related params */
    HWA_DestConfig      dest;                       /**< Dest related params */
    union {
        HWA_AccelModeFFT    fftMode;                /**< FFT mode related params */
        HWA_AccelModeCFAR   cfarMode;               /**< CFAR mode related params */
        HWA_AccelModeCompress    compressMode;                /**< Compression/Decompression mode related params */
    }accelModeArgs;
    
    HWA_ComplexMultiply     complexMultiply;        /**< Complex multiply related params */
    
    HWA_PreProcessing       preProcCfg;           /**< pre-processing block config */
}HWA_ParamConfig;

/**
 *  \brief  HWA Interrupt Config
 *
 *  HWA interrupt config parameters that are used with the HWA_enableParamSetInterrupt() call.
 *
 */
typedef struct HWA_InterruptConfig_t {
    uint8_t             interruptTypeFlag;      /**<  Flag to specify whether Interrupt to CPU and/or DMA
                                                     is desired on completion of paramset.
                                                     Defines for \ref HWA_PARAMDONE_INTERRUPT_TYPE can be ORed to
                                                     specify this flag.
                                                     Interrupt types HWA_PARAMDONE_INTERRUPT_TYPE_CPU may not be supported on all
                                                     versions of the IP - see \ref HWA_Attrs::isConcurrentAccessAllowed */
    struct {
        HWA_ParamDone_IntHandlerFuncPTR   callbackFn;       /**<  Callback function to be called when interrupt destination is CPU */
        void                             *callbackArg;      /**<  Callback function argument */
           } cpu;
    struct {
        uint8_t                           dstChannel;     /**<  DMA channel number to be triggered on paramset completion
                                                               if interrupt destination to DMA is desired */
    } dma;
} HWA_InterruptConfig;

/**
 *  \brief  HWA Statistics from the STATISTICS block
 *
 *  HWA statistics - MAX and SUM - that are output from the statistics block.
 *
 */
typedef struct HWA_Stats_t {
    uint32_t             maxValue;      /**<  24 bits value from MAXnVALUE register */
    uint16_t             maxIndex;      /**<  24 bits value from MAXnINDEX register */
    uint8_t              iSumMSB;       /**<  upper 4 bits of 36-bit value of iSUM; read from ISUMnMSB */
    uint8_t              qSumMSB;       /**<  upper 4 bits of 36-bit value of qSUM; read from QSUMnMSB */
    uint32_t             iSumLSB;       /**<  lower 32 bits of 36-bit value of iSUM; read from ISUMnLSB */
    uint32_t             qSumLSB;       /**<  lower 32 bits of 36-bit value of qSUM; read from QSUMnLSB */
} HWA_Stats;

/**
 *  @brief    HWA Debug statistics 
 *
 *  HWA debug - current paramset, loopcount, trigger status - that are output from the statistics block. 
 *
 */
typedef struct HWA_DebugStats_t {
    uint8_t             currentParamSet;        /**< Index of the current paramset that is under execution.
                                                   useful for debug, where parameter-sets can be executed 
                                                   one-by-one using SW trigger mode for each of them.  In 
                                                   such a debug, this register indicates which parameter-set
                                                   is currently waiting for the SW trigger*/
    uint16_t            currentLoopCount;       /**< the loop count that is presently running */

    uint16_t            dmaTrigStatus;          /**< indicates whether a trigger was received via DMA trigger method */
    uint8_t             dfePingPongStatus;      /**< the status of DFE ping-pong trigger */
    uint8_t             swTrigStatus;           /**< the status of software trigger */
}HWA_DebugStats;

/**
 *  @brief    HWA Local memory Information
 *
 *  HWA Local processing memory info - base address and Size.
 *
 */
typedef struct HWA_MemInfo_t {
    uint32_t    baseAddress;        /**< Base Address of HWA Local memory */
    uint16_t    bankSize;           /**< Total size in bytes of one bank */
    uint16_t    numBanks;           /**< number of banks can be used of HWA Local memory */
}HWA_MemInfo;

/**
 *  \brief  HWA interrupt priority for HWA background thread done, ALT thread done,  paramset done interrupt 1 and paramset done 2 interrupt
 *
 */
typedef struct HWA_InterruptPriority_t {

    uint32_t    backgroundDone;                /**<  \brief HWA interrupt priority for the background thread done */
    //TO DO: CLEAN uint32_t    ALTDone;                       /**<  \brief HWA interrupt priority for the ALT thread done */
    uint32_t    paramsetDone1;                 /**<  \brief HWA interrupt priority for paramset done interrupt 1 */
    uint32_t    paramsetDone2;                 /**<  \brief HWA interrupt priority for paramset done interrupt 2 */

} HWA_InterruptPriority;

/**
 *  \brief  HWA configuration structure, which describes the configuration information, needed for hwa handle open
 *
 */
typedef struct HWA_OpenConfig_t {

    HWA_InterruptPriority    interruptPriority ;  /**<  \brief structure holds the HWA interrupt priorities. This structure is applicable
                                                        for processors that support a hardware priority, e.g R5F.
                                                        In HWA, even though the four interrupts can not be generated at the same time,
                                                        during the ISR execution of a HWA interrupt say L, if another HWA interrupt event H happens
                                                        of a higher priority because of HWA progressing in its execution flow during this time,
                                                        then the L's ISR will be preempted by H's ISR and the corresponding user provided call
                                                        back function of L can therefore also get preempted by H's ISR or H's callback.
                                                        User needs to keep this in mind in the design and implementation of the call back
                                                        functions that were intended to benefit from such prioritization.
                                                        In most use cases, it is not expected that such prioritization will be beneficial
                                                        and so it is recommended to leave these settings to the default state of same
                                                        priority level for all HWA interrupts. */

} HWA_OpenConfig;

/** @} */   /* end of HWA_DRIVER_EXTERNAL_DATA_STRUCTURE*/

/* ========================================================================== */
/*                  Internal/Private Structure Declarations                   */
/* ========================================================================== */

/**
 * \brief
 *  HWA Interrupt context structure for paramset done interrupt
 *
 * @details
 *  HWA interrupt context structure per paramSet.
 *
 */
typedef struct HWA_InterruptCtx_t {
    HWA_ParamDone_IntHandlerFuncPTR     callbackFn;      /**< HWA interrupt callback function */
    void                                *callbackArg;    /**< HWA interrupt callback function argument */
} HWA_InterruptCtx;

/**
 * \brief
 *  HWA Interrupt context structure for done interrupt
 *
 * @details
 *  HWA interrupt context structure for done interrupt which is triggered when all paramsets are executed
 *
 */
typedef struct HWA_DoneInterruptCtx_t {
    bool                                bIsEnabled;      /**< boolean to store enable/disable status of HWA interrupt */
    HWA_Done_IntHandlerFuncPTR          callbackFn;      /**< HWA interrupt callback function */
    void                                *callbackArg;    /**< HWA interrupt callback function argument */
} HWA_DoneInterruptCtx;

/**
 *  \brief  HWA driver internal Config
 */
typedef struct HWA_Driver_t {
    /**
     * \brief HWA instance number
     */
    uint32_t                        instanceNum;
    /**
     * \brief HWA instance reference (open) count
     */
    uint32_t                        refCnt;
    /**
     * \brief HWA instance config is in progress.
     *          Protects Common register acccess in HWA_configCommon() and HWA_configRam().
     */
    uint8_t                        configInProgress;
    /**
     * \brief HWA paramset config is in progress [used as bitmap].
     *          Protects Paramset register access in HWA_configParamSet(),
     *          HWA_enableParamSetInterrupt() and HWA_disableParamSetInterrupt()
     */
    uint16_t                       paramSetMapInProgress;
    /**
     * \brief HWA Hardware related params
     */
    HWA_Attrs          const       *hwAttrs;

    /**
     * \brief Registered Interrupt Handler for each paramset completion
     */
    HwiP_Object                     hwiHandleParamSet;

    /**
     * \brief Registered Interrupt Handler for interrupt at the end of group of paramsets
     */
    HwiP_Object                     hwiHandleDone;

    /**
     * \brief Registered Interrupt Handler for each paramset completion in the ALT thread
     */
    //TO DO: CLEAN HwiP_Object                     hwiHandleParamSetALT;

    /**
     * \brief Registered Interrupt Handler for interrupt at the end of group of paramsets in the ALT thread
     */
    //TO DO: CLEAN HwiP_Object                     hwiHandleDoneALT;


    /**
     * \brief interrupt context for each paramset
     */
    HWA_InterruptCtx                *interruptCtxParamSet; /*[NUM_HWA_PARAMSETS_PER_INSTANCE];*/
    
    /**
     * \brief interrupt enable mask for background thread
     */
    uint64_t                        interrupt1ParamSetMask;

    /**
     * @brief   interrupt context for all paramset done interrupt
     */
    HWA_DoneInterruptCtx             interruptCtxDone; 
} HWA_Object;

/** \brief Externally defined driver configuration array */
extern HWA_Attrs        gHwaAttrs[];
/** \brief Externally defined driver RAM configuration array */
extern HWA_RAMAttrs     gHwaRamCfg[HWA_NUM_RAMS];
/** \brief Externally defined driver object */
extern HWA_Object       gHwaObject[];
/** \brief Externally defined driver object pointer */
extern HWA_Object      *gHwaObjectPtr[];
/** \brief Externally defined driver configuration array size */
extern uint32_t         gHwaConfigNum;

/* ========================================================================== */
/*                         Global Variables Declarations                      */
/* ========================================================================== */

/* None */

/* ========================================================================== */
/*                          Function Declarations                             */
/* ========================================================================== */

/** \addtogroup HWA_DRIVER_EXTERNAL_FUNCTION
 @{ */

/**
 *  \brief  Function to initialize the HWA module
 *
 *  @pre    This function must be called once per system and before
 *          any other HWA driver APIs. It resets the HWA H/W instances in the system.
 *
 */
extern void HWA_init(void);

/**
 *  \brief  Function to deinitialize the HWA module
 */
extern void HWA_deinit(void);

/**
 *  \brief  Function to initialize HWA specified by the
 *  particular index value.
 *
 *  @pre    HWA_init() has been called
 *
 *  @param  index         HWA instance number
 *  @param  hwaCfg        pointer to HWA configuration, it is only applied to the processors, which support the hardware interrupt priority, e.g R5F.
 *                        for other processors, set it to NULL. For the processors, which support the hardware interrupt priority, setting to NULL
 *                        uses the default interrupt priorities, otherwise, the interrupt priorities are provided through hwaCfg.
 *  @param  errCode       [out] valid errorCode if NULL handle returned.
 *
 *  @return A HWA_Handle upon success. NULL if an error occurs.
 *
 *  @sa     HWA_init()
 *  @sa     HWA_close()
 */
extern HWA_Handle HWA_open(uint32_t index, HWA_OpenConfig * hwaCfg, int32_t* errCode);

/**
 *  \brief  Function to close a HWA peripheral specified by the HWA handle
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle      A HWA_Handle returned from HWA_open()
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_close(HWA_Handle handle);

/**
 *  \brief  Function to reset the internal state machine of the HWA
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_reset(HWA_Handle handle);


/**
 *  \brief  Function to returns the HWA common control base address
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *
 *  @return Common control base address upon success else NULL on failure
 *
 *  @sa     HWA_open()
 */
extern DSSHWACCRegs *HWA_getCommonCtrlAddr(HWA_Handle handle);

/**
 *  \brief  Function to returns the HWA paramSet base address
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  paramsetIdx     A valid paramSet index for which the base address is returned.
 *
 *
 *  @return Param set address upon success else NULL on failure
 *
 *  @sa     HWA_open()
 */
extern DSSHWACCPARAMRegs *HWA_getParamSetAddr(HWA_Handle handle, uint8_t paramsetIdx);

/**
 *  \brief  Function to set the common HWA configuration parameters
 *          needed for the next operations/iterations/paramsets of HWA
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  commonConfig    HWA Common Config Parameters
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_configCommon(HWA_Handle handle, HWA_CommonConfig *commonConfig);

/**
 *  \brief  Function to set the HWA configuration parameters for a given paramSet
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  paramsetIdx     A valid paramSet index for which the paramConfig is provided.
 *
 *  @param  paramConfig     HWA ParamSet Config Parameters
 *
 *  @param  dmaConfig       [out] This parameter is set by the driver with values that user
 *                                should use to program the source trigger DMA. user should provide
 *                                a valid buffer here if the triggerMode is set to DMA in paramConfig
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_configParamSet(HWA_Handle handle, uint8_t paramsetIdx, HWA_ParamConfig *paramConfig, HWA_SrcDMAConfig *dmaConfig);

/**
*  \brief  Function to get the config to program the DMA for a given DMA Trigger channel.
*          Application should use the returned config to program the DMA so that it can then
*          in turn trigger the paramset. Application should make sure that the channel provided
*          here in dmaTriggerSrc should match the \ref HWA_ParamConfig::dmaTriggerSrc passed
*          to HWA_configParamSet()
*
*  @pre    HWA_open() has been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  dmaTriggerSrc   Same as \ref HWA_ParamConfig::dmaTriggerSrc of the paramset for
*                          whom this DMA is getting configured
*
*  @param  dmaConfig       [out]This parameter is set by the driver with values that user
*                               should use to program the source trigger DMA. user should provide
*                               a valid buffer here if the triggerMode is set to DMA in paramConfig
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_getDMAconfig(HWA_Handle handle, uint8_t dmaTriggerSrc, HWA_SrcDMAConfig *dmaConfig);
/**
 *  @brief  Function to get the address of CFAR Peak Count register
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  peakCntAddr    [out]This parameter is set by the driver with the
 *                          address of FFTPEAKCNT register which contains the number of CFAR detections.
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_getCfarPeakCntRegAddress(HWA_Handle handle, uint32_t *peakCntAddr);


/**
 *  \brief  Function to set the HWA RAM : HWA_RAM_TYPE_WINDOW_RAM, HWA_RAM_TYPE_VECTORMULTIPLY_RAM, HWA_RAM_TYPE_LUT_FREQ_DEROTATE_RAM or HWA_RAM_TYPE_SHUFFLE_RAM
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  ramType         Use defines \ref HWA_RAM_TYPE
 *
 *  @param  data            data pointer that needs to be copied to RAM
 *
 *  @param  dataSize        Size of data to be copied in size of bytes
 *
 *  @param  startIdx        start index (in terms of bytes) within RAM where data needs to be copied
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_configRam(HWA_Handle handle, uint8_t ramType, uint8_t *data, uint32_t dataSize, uint32_t startIdx);

/**
 *  \brief  Function to enable the CPU and/or DMA interrupt after a paramSet completion.
 *          The CPU interrupt for every paramset completion may not be supported on all
 *          devices - see \ref HWA_Attrs::isConcurrentAccessAllowed
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  paramsetIdx     A valid paramSet index for which the intrConfig is provided.
 *
 *  @param  intrConfig      HWA Interrupt Config Parameters
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_enableParamSetInterrupt(HWA_Handle handle, uint8_t paramsetIdx, HWA_InterruptConfig *intrConfig);


/**
 *  \brief  Function to enable the CPU interrupt after all programmed paramSets have been completed in the background or ALT thread.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  callbackFn      user defined callback function to be called when this interrupt is generated
 *
 *  @param  callbackArg     user defined callback arg for the callback function
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_enableDoneInterrupt(HWA_Handle handle, HWA_Done_IntHandlerFuncPTR callbackFn, void * callbackArg);

/**
 *  \brief  Function to disable the CPU and/or DMA interrupt after a paramSet completion.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle              A HWA_Handle returned from HWA_open()
 *
 *  @param  paramsetIdx         A valid paramSet index for which the interrupt is to be disabled
 *
 *  @param  interruptTypeFlag   Flag to indicate if CPU and/or DMA interrupts are to be disabled
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_disableParamSetInterrupt(HWA_Handle handle, uint8_t paramsetIdx, uint8_t interruptTypeFlag);

/**
 *  \brief  Function to disable the CPU interrupt after all programmed paramSets have been completed.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_disableDoneInterrupt(HWA_Handle handle);

/**
 *  \brief  Function to enable the state machine of the HWA. This should be called after
 *          paramset and RAM have been programmed
 *
 *  @pre    HWA_open() HWA_ConfigCommon() HWA_ConfigParamSet HWA_ConfigRam has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  flagEnDis       Enable/Disable Flag: 0-disable, 1-enable
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_enable(HWA_Handle handle, uint8_t flagEnDis);


/**
*  \brief  Function to manually trigger the execution of the state machine via software,
*           the software trigger through either FW2HWA_TRIG_0 or FW2HWA_TRIG_1 register
*           if the trigger is set to HWA_TRIG_MODE_SOFTWARE from DSP, trigger is done through FW2HWA_TRIG_0
*           if the trigger is set to HWA_TRIG_MODE_M4CONTROL from M4, trigger is done through FW2HWA_TRIG_1
*
*  @pre    HWA_open() has been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_setSoftwareTrigger(HWA_Handle handle);


/**
 *  \brief  Function to manually trigger the execution of the state machine waiting on DMA via software
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  idx            DMA channel number for whom software should simulate the trigger
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_setDMA2ACCManualTrig(HWA_Handle handle, uint8_t idx);

/**
*  \brief  Function to set the source address for one paramset
*
*  @pre    HWA_open() has been called.
*
*  @param  handle             A HWA_Handle returned from HWA_open()
*
*  @param  paramIdx           the paramset index
*
*  @param  sourceAddress      source address
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_setSourceAddress(HWA_Handle handle, uint16_t paramIdx, uint32_t sourceAddress);

/**
 *  \brief  Function to read the 4 sets of 'MAX' statistics register
 *
 *  @pre    HWA_open() has been called and HWA is not executing paramsets.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  pStats          pointer to a memory of type HWA_Stats where value of all the
 *                          Max and statistics Registers would be copied
 *
 *  @param  numIter         number of iterations to read. Value 1-4 should be provided.
 *                          User is expected to provide enough space for the pStats to hold 'numIter' worth of HWA_Stats
 *                          Ex: HWA_Stats appHWAStats[3]; HWA_readStatsReg(appHWAhandle,appHWAStats,3);
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
 */
extern int32_t HWA_readStatsReg(HWA_Handle handle, HWA_Stats *pStats, uint8_t numIter);

/**
 *  \brief  Function to read the PEAKCNT register
 *
 *  @pre    HWA_open() has been called and HWA is not executing paramsets.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  pbuf            pointer to a memory where value of the
 *                          PEAKCNT Registers would be copied
 *
 *  @param  size            size (in bytes) of the pbuf register provided.
 *                          It should be atleast 2 bytes.
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
 */
extern int32_t HWA_readCFARPeakCountReg(HWA_Handle handle, uint8_t *pbuf, uint8_t size);

/**
 *  \brief  Function to read the debug registers (paramcurr, loopcou, acc_trig_in_stat)
 *
 *  @pre    HWA_open() has been called and HWA is not executing paramsets.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  pStats          pointer to a memory of type HWA_debugStats where value of the
 *                          RDSTATUS and HWACCREG12 Registers would be copied
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
 */
extern int32_t HWA_readDebugReg(HWA_Handle handle, HWA_DebugStats *pStats);

/**
 *  \brief  Function to clear the debug registers (acc_trig_in_clr)
 *
 *  @pre    HWA_open() has been called and HWA is not executing paramsets.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
 */
extern int32_t HWA_clearDebugReg(HWA_Handle handle);

/**
 *  \brief  Function to get HWA processing Memory information including address,
 *          size and number of banks.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  memInfo         Pointer to save HWA processing memory information
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_getHWAMemInfo(HWA_Handle handle, HWA_MemInfo *memInfo);

/**
 *  \brief  Function to get the dma destination index with a given EDMA channel number
 *          This function assumes the EDMA channel number is from the first EDMA instance.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  edmaChanId      EDMA channell id
 *
 *  @param  hwaDestChan     Pointer to save destination channel index
 *
 *  @return     =0          Success
 *              <0          Error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_getDMAChanIndex(HWA_Handle handle, uint8_t edmaChanId, uint8_t *hwaDestChan);

/**
 *  \brief  Function to get the edma EDMA channel number from a given HWA paramset destination channel.
 *          This function assumes the EDMA channel number is from the first EDMA instance.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  hwaDMAdestChan  Destination channle id set in a paramset
 *
 *  @return     >=0         Upon success, EDMA channel number
 *              <0          Error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_getEDMAChanId(HWA_Handle handle, uint8_t hwaDMAdestChan);

/**
*  \brief  Function to read the DC_EST_I/Q register
*
*  @pre    HWA_open() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  pbuf            pointer to a memory where value of the
*                          DC_EST_I/Q Registers would be copied, even element is I value, and odd element is Q value
*
*  @param  startIdx        The estimated DC results for the first RX channel Idx, must be less than 11.
*
*  @param  size            The number of Rx channels needed to be read.
*                          It should be less than 12.
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
*/
extern int32_t HWA_readDCEstimateReg(HWA_Handle handle, cmplx32ImRe_t *pbuf, uint8_t startIdx, uint8_t size);

/**
*  \brief  Function to read the interference threshold MAG or MAGDIFF Accumulator register
*
*  @pre    HWA_open() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  accBuf          pointer to the accumulator result buffer for MAG or MAGDIFF
*
*  @param  type            see \ref HWA_INTERFERENCE_THRESHOLD_TYPE macro for the either MAG or MAGDIFF accumulator .
*
*  @param  startIdx        The first accumulator channel needs to be read, must be less than 11.
*
*  @param  size            The number of channels needed to be read.
*                          It should be less than 12.
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
*/
extern int32_t HWA_readIntfAccReg(HWA_Handle handle, uint64_t *accBuf, uint8_t type, uint8_t startIdx, uint8_t size);

/**
*  \brief  Function to read the DC estimation accumulator register,
*
*  @pre    HWA_open() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  accbuf           pointer to a memory for accumulator results.
*
*  @param  startIdx        The first accumulator channel needs to be read, must be less than 11.
*
*  @param  size            The number of channels needed to be read.
*                          It should be less than 12.
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
*/
extern int32_t HWA_readDCAccReg(HWA_Handle handle, cmplx64ImRe_t *accbuf,  uint8_t startIdx, uint8_t size);

/**
*  \brief  Function to read the number of samples that exceeded the threshold in a chirp
*
*  @pre    HWA_open() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  numInterfSamplesChirp       number of samples that exceeded the interference threshold in a chirp
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
*/
extern int32_t HWA_readInterfChirpCountReg(HWA_Handle handle, uint16_t *numInterfSamplesChirp);

/**
*  \brief  Function to read the number of samples that exceeded the threshold in a frame
*
*  @pre    HWA_open() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  numInterfSamplesFrame    number of samples exceeded the interference threshold in a frame
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
*/
extern int32_t HWA_readInterfFrameCountReg(HWA_Handle handle, uint32_t *numInterfSamplesFrame);

/**
*  \brief  Function to read the interference statistics INTF_LOC_THRESH_MAG_VAL or INTF_LOC_THRESH_MAG_VAL registers
*
*  @pre    HWA_open() has been called and HWA is not executing paramsets.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  pbuf            pointer to a memory where the register values are copied into
*
*  @param  startIdx        The first channel index needs to be read, must be less than 11.
*
*  @param  size            The number of channels needed to be read.
*                          It should be less than 12.
*  @param  type            see \ref HWA_INTERFERENCE_THRESHOLD_TYPE for correct values
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open(), HWA_Attrs::isConcurrentAccessAllowed
*/
extern int32_t HWA_readInterfThreshReg(HWA_Handle handle, uint32_t *pbuf, uint8_t startIdx, uint8_t size, uint8_t type);

/*!
*  @brief  Function for software to reset the DC accumulators or interference statistics accumulators
*
*  @pre    HWA_open() has been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*  @param  accumulatortype  see maros \ref HWA_ACCUMULATORREG_TYPE, takes value either HWA_ACCUMULATORREG_TYPE_DC
*                           or HWA_ACCUMULATORREG_TYPE_INTERF
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
int32_t HWA_softwareResetAccumulators(HWA_Handle handle, uint8_t accumulatortype);

/** @} */  /* end of addgroup HWA_DRIVER_EXTERNAL_FUNCTION*/

#ifdef __cplusplus
}
#endif

#endif /* HWA_H_ */


