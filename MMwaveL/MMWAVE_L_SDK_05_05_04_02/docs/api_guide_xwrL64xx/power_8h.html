<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>xWRL6432 MMWAVE-L-SDK: power.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="xWRL6432 MMWAVE-L-SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xWRL6432 MMWAVE-L-SDK
   &#160;<span id="projectnumber">05.05.04.02</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('power_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">power.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="power_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPower__NotifyObj.html">Power_NotifyObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power notify object structure.  <a href="structPower__NotifyObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga98c91c03b469de0cf4f53b89a867ee19"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Notify__Response.html#ga98c91c03b469de0cf4f53b89a867ee19">Power_NOTIFYDONE</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:ga98c91c03b469de0cf4f53b89a867ee19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98066f45fce59fd38d8edcb6f2ac96fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Notify__Response.html#ga98066f45fce59fd38d8edcb6f2ac96fd">Power_NOTIFYERROR</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="separator:ga98066f45fce59fd38d8edcb6f2ac96fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92eed670a5d7e3d43f612ca0da9d3fe2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:ga92eed670a5d7e3d43f612ca0da9d3fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed2f92a8c72bfa183e14d10a2e35789f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Status.html#gaed2f92a8c72bfa183e14d10a2e35789f">Power_EFAIL</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="separator:gaed2f92a8c72bfa183e14d10a2e35789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga200ab87d1e0ffbc4eb3864d18646e0f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Status.html#ga200ab87d1e0ffbc4eb3864d18646e0f7">Power_EINVALIDINPUT</a>&#160;&#160;&#160;(-2)</td></tr>
<tr class="separator:ga200ab87d1e0ffbc4eb3864d18646e0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d24bacb087e8282be2e4394503a429a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Status.html#ga0d24bacb087e8282be2e4394503a429a">Power_EINVALIDPOINTER</a>&#160;&#160;&#160;(-3)</td></tr>
<tr class="separator:ga0d24bacb087e8282be2e4394503a429a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e7b580b1c9c026036bf53befe5723b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Status.html#gaa4e7b580b1c9c026036bf53befe5723b">Power_ECHANGE_NOT_ALLOWED</a>&#160;&#160;&#160;(-4)</td></tr>
<tr class="separator:gaa4e7b580b1c9c026036bf53befe5723b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3132904395c5631392bd6301d9a2181e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Status.html#ga3132904395c5631392bd6301d9a2181e">Power_EBUSY</a>&#160;&#160;&#160;(-5)</td></tr>
<tr class="separator:ga3132904395c5631392bd6301d9a2181e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01074d8221d330077fbe040b9143e183"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Transition__State.html#ga01074d8221d330077fbe040b9143e183">Power_ACTIVE</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="separator:ga01074d8221d330077fbe040b9143e183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80f1e5ccb298b7edc72d87f0ce4ddd5a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Transition__State.html#ga80f1e5ccb298b7edc72d87f0ce4ddd5a">Power_ENTERING_DEEPSLEEP</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="separator:ga80f1e5ccb298b7edc72d87f0ce4ddd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcc280d772d2c76471bd7455d35cebc8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Transition__State.html#gadcc280d772d2c76471bd7455d35cebc8">Power_EXITING_DEEPSLEEP</a>&#160;&#160;&#160;(3U)</td></tr>
<tr class="separator:gadcc280d772d2c76471bd7455d35cebc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6038b3877b09c908834af7d46595b989"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Transition__State.html#ga6038b3877b09c908834af7d46595b989">Power_ENTERING_SLEEP</a>&#160;&#160;&#160;(4U)</td></tr>
<tr class="separator:ga6038b3877b09c908834af7d46595b989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ea41cdfb6fb053eaed2792c4edf886d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Transition__State.html#ga1ea41cdfb6fb053eaed2792c4edf886d">Power_EXITING_SLEEP</a>&#160;&#160;&#160;(5U)</td></tr>
<tr class="separator:ga1ea41cdfb6fb053eaed2792c4edf886d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga866c419baa163493b3fd2f0cf3787c1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Transition__State.html#ga866c419baa163493b3fd2f0cf3787c1e">Power_ENTERING_IDLE</a>&#160;&#160;&#160;(6U)</td></tr>
<tr class="separator:ga866c419baa163493b3fd2f0cf3787c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga695a70b235ac515e1aab0cc2638633f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Transition__State.html#ga695a70b235ac515e1aab0cc2638633f1">Power_EXITING_IDLE</a>&#160;&#160;&#160;(7U)</td></tr>
<tr class="separator:ga695a70b235ac515e1aab0cc2638633f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b7d4ba49a9418af10c84132a8cbf108"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Transition__State.html#ga2b7d4ba49a9418af10c84132a8cbf108">Power_CHANGING_PERF_LEVEL</a>&#160;&#160;&#160;(8U)</td></tr>
<tr class="separator:ga2b7d4ba49a9418af10c84132a8cbf108"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a435fdeb71d13ea6be86f599c9b6a0d78"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#a435fdeb71d13ea6be86f599c9b6a0d78">Power_PolicyInitFxn</a>) (void)</td></tr>
<tr class="memdesc:a435fdeb71d13ea6be86f599c9b6a0d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power policy initialization function pointer.  <a href="power_8h.html#a435fdeb71d13ea6be86f599c9b6a0d78">More...</a><br /></td></tr>
<tr class="separator:a435fdeb71d13ea6be86f599c9b6a0d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7eca3f57d333d9c1a1ca02639674100"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#aa7eca3f57d333d9c1a1ca02639674100">Power_PolicyFxn</a>) (unsigned long long sleepTimeus)</td></tr>
<tr class="memdesc:aa7eca3f57d333d9c1a1ca02639674100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power policy function pointer.  <a href="power_8h.html#aa7eca3f57d333d9c1a1ca02639674100">More...</a><br /></td></tr>
<tr class="separator:aa7eca3f57d333d9c1a1ca02639674100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c365f54d37429c5bd32181e5dbf463"><td class="memItemLeft" align="right" valign="top">typedef int_fast16_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#ad6c365f54d37429c5bd32181e5dbf463">Power_NotifyFxn</a>) (uint_fast16_t eventType, uintptr_t eventArg, uintptr_t clientArg)</td></tr>
<tr class="memdesc:ad6c365f54d37429c5bd32181e5dbf463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power notify callback function used with the <a class="el" href="power_8h.html#aa89d120c82d4f23e6d4a337720b6300e" title="Register a function to be called upon a specific power event.">Power_registerNotify()</a>  <a href="power_8h.html#ad6c365f54d37429c5bd32181e5dbf463">More...</a><br /></td></tr>
<tr class="separator:ad6c365f54d37429c5bd32181e5dbf463"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac4adad4afc132d490d94dd2dd050f259"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Latency__Type.html#gac4adad4afc132d490d94dd2dd050f259">Power_LatencyType</a> { <a class="el" href="group__Power__Latency__Type.html#ggac4adad4afc132d490d94dd2dd050f259ae8e471ed04f94133e76d7bff348f73a9">Power_TOTAL_LATENCY</a>, 
<a class="el" href="group__Power__Latency__Type.html#ggac4adad4afc132d490d94dd2dd050f259a17a659eb75b426aa854c353fc8958260">Power_RESUME_LATENCY</a>
 }</td></tr>
<tr class="separator:gac4adad4afc132d490d94dd2dd050f259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc41f572a2bdc1427dbe71a7a25698ae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Power__Sleep__Type.html#gabc41f572a2bdc1427dbe71a7a25698ae">Power_SleepState</a> { <a class="el" href="group__Power__Sleep__Type.html#ggabc41f572a2bdc1427dbe71a7a25698aea1d7be49ad41d6db56bfd19e4f73b4bea">POWER_LPDS</a>, 
<a class="el" href="group__Power__Sleep__Type.html#ggabc41f572a2bdc1427dbe71a7a25698aeabeb8a46d9a9e78ca47260292125db60e">POWER_SLEEP</a>, 
<a class="el" href="group__Power__Sleep__Type.html#ggabc41f572a2bdc1427dbe71a7a25698aea004fcb2093a19f9d663986e737ff507b">POWER_IDLE</a>, 
<a class="el" href="group__Power__Sleep__Type.html#ggabc41f572a2bdc1427dbe71a7a25698aead8431f9907963f0981e730d59a3d01b1">POWER_NONE</a>
 }</td></tr>
<tr class="separator:gabc41f572a2bdc1427dbe71a7a25698ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acf9706c39bd0fa07ec977dd643e5dd2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#acf9706c39bd0fa07ec977dd643e5dd2a">Power_disablePolicy</a> (void)</td></tr>
<tr class="memdesc:acf9706c39bd0fa07ec977dd643e5dd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the configured power policy from running when the CPU is idle.  <a href="power_8h.html#acf9706c39bd0fa07ec977dd643e5dd2a">More...</a><br /></td></tr>
<tr class="separator:acf9706c39bd0fa07ec977dd643e5dd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d6092a8fb35b6db52a69a35fcc327f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#ae8d6092a8fb35b6db52a69a35fcc327f">Power_enablePolicy</a> (void)</td></tr>
<tr class="memdesc:ae8d6092a8fb35b6db52a69a35fcc327f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the configured power policy to run when the CPU is idle.  <a href="power_8h.html#ae8d6092a8fb35b6db52a69a35fcc327f">More...</a><br /></td></tr>
<tr class="separator:ae8d6092a8fb35b6db52a69a35fcc327f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a014bc499484e3340eed32b2aad9b56"><td class="memItemLeft" align="right" valign="top">uint_fast32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#a5a014bc499484e3340eed32b2aad9b56">Power_getConstraintMask</a> (void)</td></tr>
<tr class="memdesc:a5a014bc499484e3340eed32b2aad9b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the constraints that have been declared with Power.  <a href="power_8h.html#a5a014bc499484e3340eed32b2aad9b56">More...</a><br /></td></tr>
<tr class="separator:a5a014bc499484e3340eed32b2aad9b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4f3e678659b683126eef65aef4400b"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#a3c4f3e678659b683126eef65aef4400b">Power_getDependencyCount</a> (uint_fast16_t resourceId)</td></tr>
<tr class="memdesc:a3c4f3e678659b683126eef65aef4400b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current dependency count for a resource.  <a href="power_8h.html#a3c4f3e678659b683126eef65aef4400b">More...</a><br /></td></tr>
<tr class="separator:a3c4f3e678659b683126eef65aef4400b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33830ca68bc594b1f24c7285a62f0475"><td class="memItemLeft" align="right" valign="top">uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#a33830ca68bc594b1f24c7285a62f0475">Power_getPerformanceLevel</a> (void)</td></tr>
<tr class="memdesc:a33830ca68bc594b1f24c7285a62f0475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current performance level.  <a href="power_8h.html#a33830ca68bc594b1f24c7285a62f0475">More...</a><br /></td></tr>
<tr class="separator:a33830ca68bc594b1f24c7285a62f0475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89354d8745e8c96f3f06b4a953fe000"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#ad89354d8745e8c96f3f06b4a953fe000">Power_getTransitionLatency</a> (<a class="el" href="group__Power__Sleep__Type.html#gabc41f572a2bdc1427dbe71a7a25698ae">Power_SleepState</a> sleepState, <a class="el" href="group__Power__Latency__Type.html#gac4adad4afc132d490d94dd2dd050f259">Power_LatencyType</a> type)</td></tr>
<tr class="memdesc:ad89354d8745e8c96f3f06b4a953fe000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hardware transition latency for a sleep state.  <a href="power_8h.html#ad89354d8745e8c96f3f06b4a953fe000">More...</a><br /></td></tr>
<tr class="separator:ad89354d8745e8c96f3f06b4a953fe000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896cabb29f6332f6617b81dc16761139"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#a896cabb29f6332f6617b81dc16761139">Power_setTransitionLatency</a> (<a class="el" href="group__Power__Sleep__Type.html#gabc41f572a2bdc1427dbe71a7a25698ae">Power_SleepState</a> sleepState, <a class="el" href="group__Power__Latency__Type.html#gac4adad4afc132d490d94dd2dd050f259">Power_LatencyType</a> type, uint32_t latencyTime)</td></tr>
<tr class="separator:a896cabb29f6332f6617b81dc16761139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9b1f18784cddc57e107320d61a04d6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#a4a9b1f18784cddc57e107320d61a04d6">Power_getThresholds</a> (<a class="el" href="group__Power__Sleep__Type.html#gabc41f572a2bdc1427dbe71a7a25698ae">Power_SleepState</a> sleepState)</td></tr>
<tr class="separator:a4a9b1f18784cddc57e107320d61a04d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51a4420daf316cfc040a0258d24b683"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#af51a4420daf316cfc040a0258d24b683">Power_setThresholds</a> (<a class="el" href="group__Power__Sleep__Type.html#gabc41f572a2bdc1427dbe71a7a25698ae">Power_SleepState</a> sleepState, uint32_t latencyTime)</td></tr>
<tr class="separator:af51a4420daf316cfc040a0258d24b683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f232cdc5889b4e6d893c889ce433b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Power__Sleep__Type.html#gabc41f572a2bdc1427dbe71a7a25698ae">Power_SleepState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#ad1f232cdc5889b4e6d893c889ce433b4">Power_getLowPowModeTaken</a> ()</td></tr>
<tr class="separator:ad1f232cdc5889b4e6d893c889ce433b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9d72adbe5e61eb977179d516c0a04a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#a5d9d72adbe5e61eb977179d516c0a04a">Power_setLowPowModeTaken</a> (<a class="el" href="group__Power__Sleep__Type.html#gabc41f572a2bdc1427dbe71a7a25698ae">Power_SleepState</a> mode)</td></tr>
<tr class="separator:a5d9d72adbe5e61eb977179d516c0a04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20509b474f5e68c9d36832199d167b9b"><td class="memItemLeft" align="right" valign="top">uint_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#a20509b474f5e68c9d36832199d167b9b">Power_getTransitionState</a> (void)</td></tr>
<tr class="memdesc:a20509b474f5e68c9d36832199d167b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current transition state of the Power Manager.  <a href="power_8h.html#a20509b474f5e68c9d36832199d167b9b">More...</a><br /></td></tr>
<tr class="separator:a20509b474f5e68c9d36832199d167b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ee1a7156dcd02b7d5d41877e1afc81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#a33ee1a7156dcd02b7d5d41877e1afc81">Power_idleFunc</a> (unsigned long long sleepTimeus)</td></tr>
<tr class="memdesc:a33ee1a7156dcd02b7d5d41877e1afc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power function to be added to the application idle loop.  <a href="power_8h.html#a33ee1a7156dcd02b7d5d41877e1afc81">More...</a><br /></td></tr>
<tr class="separator:a33ee1a7156dcd02b7d5d41877e1afc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4e1eab2809636848b2758fb201707c"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#a3c4e1eab2809636848b2758fb201707c">Power_init</a> (void)</td></tr>
<tr class="memdesc:a3c4e1eab2809636848b2758fb201707c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power initialization function.  <a href="power_8h.html#a3c4e1eab2809636848b2758fb201707c">More...</a><br /></td></tr>
<tr class="separator:a3c4e1eab2809636848b2758fb201707c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89d120c82d4f23e6d4a337720b6300e"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#aa89d120c82d4f23e6d4a337720b6300e">Power_registerNotify</a> (<a class="el" href="structPower__NotifyObj.html">Power_NotifyObj</a> *pNotifyObj, uint_fast16_t eventTypes, <a class="el" href="power_8h.html#ad6c365f54d37429c5bd32181e5dbf463">Power_NotifyFxn</a> notifyFxn, uintptr_t clientArg)</td></tr>
<tr class="memdesc:aa89d120c82d4f23e6d4a337720b6300e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a function to be called upon a specific power event.  <a href="power_8h.html#aa89d120c82d4f23e6d4a337720b6300e">More...</a><br /></td></tr>
<tr class="separator:aa89d120c82d4f23e6d4a337720b6300e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3b76add2f8fadd70bb747d7dd0f8e8"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#acc3b76add2f8fadd70bb747d7dd0f8e8">Power_releaseConstraint</a> (uint_fast16_t constraintId)</td></tr>
<tr class="memdesc:acc3b76add2f8fadd70bb747d7dd0f8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously declared constraint.  <a href="power_8h.html#acc3b76add2f8fadd70bb747d7dd0f8e8">More...</a><br /></td></tr>
<tr class="separator:acc3b76add2f8fadd70bb747d7dd0f8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f45b58c200fa042614e4a892f58a2d"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#a74f45b58c200fa042614e4a892f58a2d">Power_releaseDependency</a> (uint_fast16_t resourceId)</td></tr>
<tr class="memdesc:a74f45b58c200fa042614e4a892f58a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously declared dependency.  <a href="power_8h.html#a74f45b58c200fa042614e4a892f58a2d">More...</a><br /></td></tr>
<tr class="separator:a74f45b58c200fa042614e4a892f58a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bde4b6fc658e81dc70701e8bdc947a"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#a45bde4b6fc658e81dc70701e8bdc947a">Power_setConstraint</a> (uint_fast16_t constraintId)</td></tr>
<tr class="memdesc:a45bde4b6fc658e81dc70701e8bdc947a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare an operational constraint.  <a href="power_8h.html#a45bde4b6fc658e81dc70701e8bdc947a">More...</a><br /></td></tr>
<tr class="separator:a45bde4b6fc658e81dc70701e8bdc947a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f2b780b7ea1ff1f515115fe1c2f519"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#a25f2b780b7ea1ff1f515115fe1c2f519">Power_setDependency</a> (uint_fast16_t resourceId)</td></tr>
<tr class="memdesc:a25f2b780b7ea1ff1f515115fe1c2f519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare a dependency upon a resource.  <a href="power_8h.html#a25f2b780b7ea1ff1f515115fe1c2f519">More...</a><br /></td></tr>
<tr class="separator:a25f2b780b7ea1ff1f515115fe1c2f519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40483e9ed7c626a02399996d3a7878a"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#ae40483e9ed7c626a02399996d3a7878a">Power_setPerformanceLevel</a> (uint_fast16_t level)</td></tr>
<tr class="memdesc:ae40483e9ed7c626a02399996d3a7878a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MCU performance level.  <a href="power_8h.html#ae40483e9ed7c626a02399996d3a7878a">More...</a><br /></td></tr>
<tr class="separator:ae40483e9ed7c626a02399996d3a7878a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4af0d238813058bf6146df6021df8cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#aa4af0d238813058bf6146df6021df8cc">Power_setPolicy</a> (<a class="el" href="power_8h.html#aa7eca3f57d333d9c1a1ca02639674100">Power_PolicyFxn</a> policy)</td></tr>
<tr class="memdesc:aa4af0d238813058bf6146df6021df8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new Power policy.  <a href="power_8h.html#aa4af0d238813058bf6146df6021df8cc">More...</a><br /></td></tr>
<tr class="separator:aa4af0d238813058bf6146df6021df8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e1e0f3168cc39a2309fce40c3e271d"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#a45e1e0f3168cc39a2309fce40c3e271d">Power_sleep</a> (uint_fast16_t sleepState)</td></tr>
<tr class="memdesc:a45e1e0f3168cc39a2309fce40c3e271d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition the device into a sleep state.  <a href="power_8h.html#a45e1e0f3168cc39a2309fce40c3e271d">More...</a><br /></td></tr>
<tr class="separator:a45e1e0f3168cc39a2309fce40c3e271d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32c17ce6da099da97957f08ddb000b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="power_8h.html#ac32c17ce6da099da97957f08ddb000b4">Power_unregisterNotify</a> (<a class="el" href="structPower__NotifyObj.html">Power_NotifyObj</a> *pNotifyObj)</td></tr>
<tr class="memdesc:ac32c17ce6da099da97957f08ddb000b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister previously registered notifications.  <a href="power_8h.html#ac32c17ce6da099da97957f08ddb000b4">More...</a><br /></td></tr>
<tr class="separator:ac32c17ce6da099da97957f08ddb000b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a435fdeb71d13ea6be86f599c9b6a0d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435fdeb71d13ea6be86f599c9b6a0d78">&#9670;&nbsp;</a></span>Power_PolicyInitFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* Power_PolicyInitFxn) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power policy initialization function pointer. </p>

</div>
</div>
<a id="aa7eca3f57d333d9c1a1ca02639674100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7eca3f57d333d9c1a1ca02639674100">&#9670;&nbsp;</a></span>Power_PolicyFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* Power_PolicyFxn) (unsigned long long sleepTimeus)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power policy function pointer. </p>

</div>
</div>
<a id="ad6c365f54d37429c5bd32181e5dbf463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c365f54d37429c5bd32181e5dbf463">&#9670;&nbsp;</a></span>Power_NotifyFxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int_fast16_t(* Power_NotifyFxn) (uint_fast16_t eventType, uintptr_t eventArg, uintptr_t clientArg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power notify callback function used with the <a class="el" href="power_8h.html#aa89d120c82d4f23e6d4a337720b6300e" title="Register a function to be called upon a specific power event.">Power_registerNotify()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eventType</td><td>The eventTypes parameter identifies the type of power event for which the notify callback function was called.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eventArg</td><td>An optional <code>eventType</code> specific argument.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clientArg</td><td>Pointer to a custom argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__Power__Notify__Response.html#ga98c91c03b469de0cf4f53b89a867ee19">Power_NOTIFYDONE</a></td><td>if the client processed the notification successfully</td></tr>
    <tr><td class="paramname"><a class="el" href="group__Power__Notify__Response.html#ga98066f45fce59fd38d8edcb6f2ac96fd">Power_NOTIFYERROR</a></td><td>if an error occurred during notification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="power_8h.html#aa89d120c82d4f23e6d4a337720b6300e" title="Register a function to be called upon a specific power event.">Power_registerNotify()</a> </dd>
<dd>
<a class="el" href="power_8h.html#ac32c17ce6da099da97957f08ddb000b4" title="Unregister previously registered notifications.">Power_unregisterNotify()</a> </dd>
<dd>
<a class="el" href="structPower__NotifyObj.html" title="Power notify object structure.">Power_NotifyObj</a> </dd>
<dd>
<a class="el" href="group__Power__Latency__Type.html#ti_drivers_Power_Examples_notify">Using power notify</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acf9706c39bd0fa07ec977dd643e5dd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9706c39bd0fa07ec977dd643e5dd2a">&#9670;&nbsp;</a></span>Power_disablePolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Power_disablePolicy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the configured power policy from running when the CPU is idle. </p>
<p>Calling this function clears the flag that controls whether the configured power policy function is invoked on each pass through the Idle loop. This function call will override both a 'true' setting of the "enablePolicy" setting in the Power Manager configuration object, as well as a previous runtime call to the <a class="el" href="power_8h.html#ae8d6092a8fb35b6db52a69a35fcc327f" title="Enable the configured power policy to run when the CPU is idle.">Power_enablePolicy()</a> function.</p>
<dl class="section return"><dt>Returns</dt><dd>The old value of "enablePolicy".</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="power_8h.html#ae8d6092a8fb35b6db52a69a35fcc327f" title="Enable the configured power policy to run when the CPU is idle.">Power_enablePolicy()</a> </dd>
<dd>
<a class="el" href="group__Power__Latency__Type.html#ti_drivers_Power_Examples_enable">Enabling power policy</a> </dd>
<dd>
<a class="el" href="group__Power__Latency__Type.html#ti_drivers_Power_Examples_disable">Disabling power policy</a> </dd></dl>

</div>
</div>
<a id="ae8d6092a8fb35b6db52a69a35fcc327f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d6092a8fb35b6db52a69a35fcc327f">&#9670;&nbsp;</a></span>Power_enablePolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Power_enablePolicy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the configured power policy to run when the CPU is idle. </p>
<p>Calling this function sets a flag that will cause the configured power policy function to be invoked on each pass through the Idle loop. This function call will override both a 'false' setting of the "enablePolicy" setting in the Power Manager configuration object, as well as a previous runtime call to the <a class="el" href="power_8h.html#acf9706c39bd0fa07ec977dd643e5dd2a" title="Disable the configured power policy from running when the CPU is idle.">Power_disablePolicy()</a> function.</p>
<p>For some processor families, automatic power transitions can make initial application development more difficult, as well as being at odds with basic debugger operation. This convenience function allows an application to be initially configured, built, and debugged, without automatic power transitions during idle time. When the application is found to be working, this function can be called (typically in main()) to enable the policy to run, without having to change the application configuration.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="power_8h.html#acf9706c39bd0fa07ec977dd643e5dd2a" title="Disable the configured power policy from running when the CPU is idle.">Power_disablePolicy()</a> </dd>
<dd>
<a class="el" href="group__Power__Latency__Type.html#ti_drivers_Power_Examples_enable">Enabling power policy</a> </dd>
<dd>
<a class="el" href="group__Power__Latency__Type.html#ti_drivers_Power_Examples_disable">Disabling power policy</a> </dd></dl>

</div>
</div>
<a id="a5a014bc499484e3340eed32b2aad9b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a014bc499484e3340eed32b2aad9b56">&#9670;&nbsp;</a></span>Power_getConstraintMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint_fast32_t Power_getConstraintMask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the constraints that have been declared with Power. </p>
<p>This function returns a bitmask indicating the constraints that are currently declared to the Power Manager (via previous calls to <a class="el" href="power_8h.html#a45bde4b6fc658e81dc70701e8bdc947a" title="Declare an operational constraint.">Power_setConstraint()</a>). For each constraint that is currently declared, the corresponding bit in the bitmask will be set. For example, if two clients have independently declared two different constraints, the returned bitmask will have two bits set.</p>
<p>Constraint identifiers are device specific, and defined in the device-specific Power include file. For example, the constraints for MSP432 are defined in PowerMSP432.h. The corresponding bit in the bitmask returned by this function can be derived by a left-shift using the constraint identifier. For example, for MSP432, for the corresponding bit for the PowerMSP432_DISALLOW_SLEEP constraint, the bit position is determined by the operation: (1 &lt;&lt; PowerMSP432_DISALLOW_SLEEP)</p>
<dl class="section return"><dt>Returns</dt><dd>A bitmask of the currently declared constraints.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="power_8h.html#a45bde4b6fc658e81dc70701e8bdc947a" title="Declare an operational constraint.">Power_setConstraint()</a> </dd>
<dd>
<a class="el" href="group__Power__Latency__Type.html#ti_drivers_Power_Examples_constraint">Using power constraints</a> </dd></dl>

</div>
</div>
<a id="a3c4f3e678659b683126eef65aef4400b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4f3e678659b683126eef65aef4400b">&#9670;&nbsp;</a></span>Power_getDependencyCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t Power_getDependencyCount </td>
          <td>(</td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>resourceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current dependency count for a resource. </p>
<p>This function returns the number of dependencies that are currently declared upon a resource.</p>
<p>Resource identifiers are device specific, and defined in the device-specific Power include file. For example, the resources for 64XX are defined in Power64XX.h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">resourceId</td><td>resource id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of dependencies declared for the resource.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__Power__Status.html#ga200ab87d1e0ffbc4eb3864d18646e0f7">Power_EINVALIDINPUT</a></td><td>if the <code>resourceId</code> is invalid or this function is not supported by the device specific implementation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="power_8h.html#a25f2b780b7ea1ff1f515115fe1c2f519" title="Declare a dependency upon a resource.">Power_setDependency()</a> </dd>
<dd>
<a class="el" href="group__Power__Latency__Type.html#ti_drivers_Power_Examples_dependency">Using power dependency</a> </dd></dl>

</div>
</div>
<a id="a33830ca68bc594b1f24c7285a62f0475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33830ca68bc594b1f24c7285a62f0475">&#9670;&nbsp;</a></span>Power_getPerformanceLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint_fast16_t Power_getPerformanceLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current performance level. </p>
<p>This function returns the current device performance level in effect.</p>
<p>If performance scaling is not supported for the device, this function will always indicate a performance level of zero.</p>
<dl class="section return"><dt>Returns</dt><dd>The current performance level.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="power_8h.html#ae40483e9ed7c626a02399996d3a7878a" title="Set the MCU performance level.">Power_setPerformanceLevel()</a> </dd></dl>

</div>
</div>
<a id="ad89354d8745e8c96f3f06b4a953fe000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89354d8745e8c96f3f06b4a953fe000">&#9670;&nbsp;</a></span>Power_getTransitionLatency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Power_getTransitionLatency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Power__Sleep__Type.html#gabc41f572a2bdc1427dbe71a7a25698ae">Power_SleepState</a>&#160;</td>
          <td class="paramname"><em>sleepState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Power__Latency__Type.html#gac4adad4afc132d490d94dd2dd050f259">Power_LatencyType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the hardware transition latency for a sleep state. </p>
<p>This function reports the minimal hardware transition latency for a specific sleep state. The reported latency is that for a direct transition, and does not include any additional latency that might occur due to software-based notifications.</p>
<p>Sleep states are device specific, and defined in the device-specific Power include file. For example, the sleep states for 64XX are defined in Power64XX.h.</p>
<p>This function is typically called by the power policy function. The latency is reported in units of microseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sleepState</td><td>the sleep state</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td><a class="el" href="group__Power__Latency__Type.html">Power_Latency_Type</a> (Power_TOTAL or Power_RESUME)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The latency value, in units of microseconds.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Power__Latency__Type.html#ti_drivers_Power_Examples_transistion">Power transitions</a> </dd></dl>

</div>
</div>
<a id="a896cabb29f6332f6617b81dc16761139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896cabb29f6332f6617b81dc16761139">&#9670;&nbsp;</a></span>Power_setTransitionLatency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Power_setTransitionLatency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Power__Sleep__Type.html#gabc41f572a2bdc1427dbe71a7a25698ae">Power_SleepState</a>&#160;</td>
          <td class="paramname"><em>sleepState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Power__Latency__Type.html#gac4adad4afc132d490d94dd2dd050f259">Power_LatencyType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>latencyTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a9b1f18784cddc57e107320d61a04d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9b1f18784cddc57e107320d61a04d6">&#9670;&nbsp;</a></span>Power_getThresholds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Power_getThresholds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Power__Sleep__Type.html#gabc41f572a2bdc1427dbe71a7a25698ae">Power_SleepState</a>&#160;</td>
          <td class="paramname"><em>sleepState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af51a4420daf316cfc040a0258d24b683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51a4420daf316cfc040a0258d24b683">&#9670;&nbsp;</a></span>Power_setThresholds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Power_setThresholds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Power__Sleep__Type.html#gabc41f572a2bdc1427dbe71a7a25698ae">Power_SleepState</a>&#160;</td>
          <td class="paramname"><em>sleepState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>latencyTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f232cdc5889b4e6d893c889ce433b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f232cdc5889b4e6d893c889ce433b4">&#9670;&nbsp;</a></span>Power_getLowPowModeTaken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Power__Sleep__Type.html#gabc41f572a2bdc1427dbe71a7a25698ae">Power_SleepState</a> Power_getLowPowModeTaken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d9d72adbe5e61eb977179d516c0a04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9d72adbe5e61eb977179d516c0a04a">&#9670;&nbsp;</a></span>Power_setLowPowModeTaken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Power_setLowPowModeTaken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Power__Sleep__Type.html#gabc41f572a2bdc1427dbe71a7a25698ae">Power_SleepState</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a20509b474f5e68c9d36832199d167b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20509b474f5e68c9d36832199d167b9b">&#9670;&nbsp;</a></span>Power_getTransitionState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint_fast16_t Power_getTransitionState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current transition state of the Power Manager. </p>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="group__Power__Transition__State.html">Power_Transition_State</a>.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__Power__Transition__State.html#ga01074d8221d330077fbe040b9143e183">Power_ACTIVE</a></td><td>returned when no transitions are in progress.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__Power__Transition__State.html#ga6038b3877b09c908834af7d46595b989">Power_ENTERING_SLEEP</a></td><td>returned during the transition to sleep, before sleep has occurred.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__Power__Transition__State.html#ga1ea41cdfb6fb053eaed2792c4edf886d">Power_EXITING_SLEEP</a></td><td>returned after wakeup, as the device is being transitioned back to <a class="el" href="group__Power__Transition__State.html#ga01074d8221d330077fbe040b9143e183">Power_ACTIVE</a>.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__Power__Transition__State.html#ga2b7d4ba49a9418af10c84132a8cbf108">Power_CHANGING_PERF_LEVEL</a></td><td>returned when a change is being made to the performance level.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Power__Latency__Type.html#ti_drivers_Power_Examples_transistion">Power transitions</a> </dd></dl>

</div>
</div>
<a id="a33ee1a7156dcd02b7d5d41877e1afc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ee1a7156dcd02b7d5d41877e1afc81">&#9670;&nbsp;</a></span>Power_idleFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Power_idleFunc </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>sleepTimeus</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power function to be added to the application idle loop. </p>
<p>This function should be added to the application idle loop. (The method to do this depends upon the operating system being used.) This function will invoke the configured power policy function when appropriate. The specific policy function to be invoked is configured as the 'policyFxn' in the application-defined Power configuration object. </p>

</div>
</div>
<a id="a3c4e1eab2809636848b2758fb201707c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4e1eab2809636848b2758fb201707c">&#9670;&nbsp;</a></span>Power_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t Power_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Power initialization function. </p>
<p>This function initializes Power Manager internal state.</p>
<dl class="section warning"><dt>Warning</dt><dd>The application is responsible for ensuring this function is called prior to any other Power API. Additionally, this function must be be called prior to any other TI-Driver's APIs. This function is normally called prior to any operating system initialization.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a> </dd></dl>

</div>
</div>
<a id="aa89d120c82d4f23e6d4a337720b6300e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89d120c82d4f23e6d4a337720b6300e">&#9670;&nbsp;</a></span>Power_registerNotify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t Power_registerNotify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPower__NotifyObj.html">Power_NotifyObj</a> *&#160;</td>
          <td class="paramname"><em>pNotifyObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>eventTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="power_8h.html#ad6c365f54d37429c5bd32181e5dbf463">Power_NotifyFxn</a>&#160;</td>
          <td class="paramname"><em>notifyFxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>clientArg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a function to be called upon a specific power event. </p>
<p>This function registers a function to be called when a Power event occurs. Registrations and the corresponding notifications are processed in first-in-first-out (FIFO) order. The function registered must behave as described later, below.</p>
<p>The pNotifyObj parameter is a pointer to a pre-allocated, opaque object that will be used by Power to support the notification. This object could be dynamically allocated, or declared as a global object. This function will properly initialized the object's fields as appropriate; the caller just needs to provide a pointer to this pre-existing object.</p>
<p>The eventTypes parameter identifies the type of power event(s) for which the notify function being registered is to be called. (Event identifiers are device specific, and defined in the device-specific Power include file. For example, the events for MSP432 are defined in PowerMSP432.h.) The eventTypes parameter for this function call is treated as a bitmask, so multiple event types can be registered at once, using a common callback function. For example, to call the specified notifyFxn when both the entering deepsleep and awake from deepsleep events occur, eventTypes should be specified as: PowerMSP432_ENTERING_DEEPSLEEP | PowerMSP432_AWAKE_DEEPSLEEP</p>
<p>The notifyFxn parameter specifies a callback function to be called when the specified Power event occurs. The notifyFxn must implement the following signature: status = notifyFxn(eventType, eventArg, clientArg);</p>
<p>Where: eventType identifies the event being signaled, eventArg is an optional event-specific argument, and clientArg is an arbitrary argument specified by the client at registration. Note that multiple types of events can be specified when registering the notification callback function, but when the callback function is actually called by Power, only a single eventType will be specified for the callback (i.e., the current event). The status returned by the client notification function must be one of the following constants: Power_NOTIFYDONE if the client processed the notification successfully, or Power_NOTIFYERROR if an error occurred during notification.</p>
<p>The clientArg parameter is an arbitrary, client-defined argument to be passed back to the client upon notification. This argument may allow one notify function to be used by multiple instances of a driver (that is, the clientArg can be used to identify the instance of the driver that is being notified).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNotifyObj</td><td><a class="el" href="structPower__NotifyObj.html" title="Power notify object structure.">Power_NotifyObj</a> preallocated by caller</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eventTypes</td><td>event type or types</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notifyFxn</td><td>client's <a class="el" href="power_8h.html#ad6c365f54d37429c5bd32181e5dbf463" title="Power notify callback function used with the Power_registerNotify()">Power_NotifyFxn</a> function</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clientArg</td><td>client-specified argument to pass with notification</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a></td><td>on success.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__Power__Status.html#ga0d24bacb087e8282be2e4394503a429a">Power_EINVALIDPOINTER</a></td><td>if either <code>pNotifyObj</code> or <code>notifyFxn</code> are NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="power_8h.html#ac32c17ce6da099da97957f08ddb000b4" title="Unregister previously registered notifications.">Power_unregisterNotify()</a> </dd>
<dd>
<a class="el" href="group__Power__Latency__Type.html#ti_drivers_Power_Examples_notify">Using power notify</a> </dd></dl>

</div>
</div>
<a id="acc3b76add2f8fadd70bb747d7dd0f8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3b76add2f8fadd70bb747d7dd0f8e8">&#9670;&nbsp;</a></span>Power_releaseConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t Power_releaseConstraint </td>
          <td>(</td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>constraintId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a previously declared constraint. </p>
<p>This function releases a constraint that was previously declared with <a class="el" href="power_8h.html#a45bde4b6fc658e81dc70701e8bdc947a" title="Declare an operational constraint.">Power_setConstraint()</a>. For example, if a device driver is starting an I/O transaction and wants to prohibit activation of a sleep state during the transaction, it uses <a class="el" href="power_8h.html#a45bde4b6fc658e81dc70701e8bdc947a" title="Declare an operational constraint.">Power_setConstraint()</a> to declare the constraint, before starting the transaction. When the transaction completes, the driver calls this function to release the constraint, to allow the Power manager to once again allow transitions to sleep.</p>
<p>Constraint identifiers are device specific, and defined in the device-specific Power include file. For example, the constraints for MSP432 are defined in PowerMSP432.h.</p>
<p>Only one constraint can be specified with each call to this function; to release multiple constraints this function must be called multiple times.</p>
<p>It is critical that clients call <a class="el" href="power_8h.html#acc3b76add2f8fadd70bb747d7dd0f8e8" title="Release a previously declared constraint.">Power_releaseConstraint()</a> when operational constraints no longer exists. Otherwise, Power may be left unnecessarily restricted from activating power savings.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="power_8h.html#a45bde4b6fc658e81dc70701e8bdc947a" title="Declare an operational constraint.">Power_setConstraint()</a> must have been called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">constraintId</td><td>constraint id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>CC26XX/CC13XX only</b>: <a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a>. To minimize code size asserts are used internally to check that the constraintId is valid,valid, and that the constraint count is not already zero; the function always returns <a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a>.</dd>
<dd>
<b>All other devices</b>: <a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a> on success, <a class="el" href="group__Power__Status.html#ga200ab87d1e0ffbc4eb3864d18646e0f7">Power_EINVALIDINPUT</a> if the constraintId is invalid, and <a class="el" href="group__Power__Status.html#gaed2f92a8c72bfa183e14d10a2e35789f">Power_EFAIL</a> if the constraint count is already zero.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="power_8h.html#a45bde4b6fc658e81dc70701e8bdc947a" title="Declare an operational constraint.">Power_setConstraint()</a> </dd>
<dd>
<a class="el" href="group__Power__Latency__Type.html#ti_drivers_Power_Examples_constraint">Using power constraints</a> </dd></dl>

</div>
</div>
<a id="a74f45b58c200fa042614e4a892f58a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f45b58c200fa042614e4a892f58a2d">&#9670;&nbsp;</a></span>Power_releaseDependency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t Power_releaseDependency </td>
          <td>(</td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>resourceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a previously declared dependency. </p>
<p>This function releases a dependency that had been previously declared upon a resource (by a call to <a class="el" href="power_8h.html#a25f2b780b7ea1ff1f515115fe1c2f519" title="Declare a dependency upon a resource.">Power_setDependency()</a>).</p>
<p>Resource identifiers are device specific, and defined in the device-specific Power include file. For example, the resources for 64XX are defined in Power64XX.h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">resourceId</td><td>resource id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>CC26XX/CC13XX only</b>: <a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a>. To minimize code size asserts are used internally to check that the resourceId is valid, and that the resource reference count is not already zero; the function always returns <a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a>.</dd>
<dd>
<b>All other devices</b>: <a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a> on success, <a class="el" href="group__Power__Status.html#ga200ab87d1e0ffbc4eb3864d18646e0f7">Power_EINVALIDINPUT</a> if the resourceId is invalid, and <a class="el" href="group__Power__Status.html#gaed2f92a8c72bfa183e14d10a2e35789f">Power_EFAIL</a> if the resource reference count is already zero.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="power_8h.html#a25f2b780b7ea1ff1f515115fe1c2f519" title="Declare a dependency upon a resource.">Power_setDependency()</a> </dd>
<dd>
<a class="el" href="group__Power__Latency__Type.html#ti_drivers_Power_Examples_dependency">Using power dependency</a> </dd></dl>

</div>
</div>
<a id="a45bde4b6fc658e81dc70701e8bdc947a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bde4b6fc658e81dc70701e8bdc947a">&#9670;&nbsp;</a></span>Power_setConstraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t Power_setConstraint </td>
          <td>(</td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>constraintId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare an operational constraint. </p>
<p>Before taking certain actions, the Power Manager checks to see if the requested action would conflict with a client-declared constraint. If the action does conflict, Power will not proceed with the request. This is the function that allows clients to declare their constraints with Power.</p>
<p>Constraint identifiers are device specific, and defined in the device-specific Power include file. For example, the constraints for MSP432 are defined in PowerMSP432.h.</p>
<p>Only one constraint can be specified with each call to this function; to declare multiple constraints this function must be called multiple times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">constraintId</td><td>constraint id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>CC26XX/CC13XX only</b>: <a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a>. To minimize code size an assert is used internally to check that the constraintId is valid; the function always returns <a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a>.</dd>
<dd>
<b>All other devices</b>: <a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a> on success, <a class="el" href="group__Power__Status.html#ga200ab87d1e0ffbc4eb3864d18646e0f7">Power_EINVALIDINPUT</a> if the constraintId is invalid.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="power_8h.html#acc3b76add2f8fadd70bb747d7dd0f8e8" title="Release a previously declared constraint.">Power_releaseConstraint()</a> </dd>
<dd>
<a class="el" href="group__Power__Latency__Type.html#ti_drivers_Power_Examples_constraint">Using power constraints</a> </dd></dl>

</div>
</div>
<a id="a25f2b780b7ea1ff1f515115fe1c2f519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f2b780b7ea1ff1f515115fe1c2f519">&#9670;&nbsp;</a></span>Power_setDependency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t Power_setDependency </td>
          <td>(</td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>resourceId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare a dependency upon a resource. </p>
<p>This function declares a dependency upon a resource. For example, if a UART driver needs a specific UART peripheral, it uses this function to declare this to the Power Manager. If the resource had been inactive, then Power will activate the peripheral during this function call.</p>
<p>What is needed to make a peripheral resource 'active' will vary by device family. For some devices this may be a simple enable of a clock to the specified peripheral. For others it may also require a power on of a power domain. In either case, the Power Manager will take care of these details, and will also implement reference counting for resources and their interdependencies. For example, if multiple UART peripherals reside in a shared serial power domain, the Power Manager will power up the serial domain when it is first needed, and then automatically power the domain off later, when all related dependencies for the relevant peripherals are released.</p>
<p>Resource identifiers are device specific, and defined in the device-specific Power include file. For example, the resources for 64XX are defined in Power64XX.h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">resourceId</td><td>resource id</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>CC26XX/CC13XX only</b>: <a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a>. To minimize code size an assert is used internally to check that the resourceId is valid; the function always returns <a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a>.</dd>
<dd>
<b>All other devices</b>: <a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a> on success, <a class="el" href="group__Power__Status.html#ga200ab87d1e0ffbc4eb3864d18646e0f7">Power_EINVALIDINPUT</a> if the reseourceId is invalid.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="power_8h.html#a74f45b58c200fa042614e4a892f58a2d" title="Release a previously declared dependency.">Power_releaseDependency()</a> </dd>
<dd>
<a class="el" href="group__Power__Latency__Type.html#ti_drivers_Power_Examples_dependency">Using power dependency</a> </dd></dl>

</div>
</div>
<a id="ae40483e9ed7c626a02399996d3a7878a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40483e9ed7c626a02399996d3a7878a">&#9670;&nbsp;</a></span>Power_setPerformanceLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t Power_setPerformanceLevel </td>
          <td>(</td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the MCU performance level. </p>
<p>This function manages a transition to a new device performance level. Before the actual transition is initiated, notifications will be sent to any clients who've registered with <a class="el" href="power_8h.html#aa89d120c82d4f23e6d4a337720b6300e" title="Register a function to be called upon a specific power event.">Power_registerNotify()</a> for a 'start change performance level' notification. The event name is device specific, and defined in the device-specific Power include file. For example, for MSP432, the event is "PowerMSP432_START_CHANGE_PERF_LEVEL", which is defined in PowerMSP432.h. Once notifications have been completed, the change to the performance level is initiated. After the level change is completed, there is a comparable event that can be used to signal a client that the change has completed. For example, on MSP432 the "PowerMSP432_DONE_CHANGE_PERF_LEVEL" event can be used to signal completion.</p>
<p>This function will not return until the new performance level is in effect. If performance scaling is not supported for the device, or is prohibited by an active constraint, or if the specified level is invalid, then an error status will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>the new performance level</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a></td><td>on success.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__Power__Status.html#ga200ab87d1e0ffbc4eb3864d18646e0f7">Power_EINVALIDINPUT</a></td><td>if the specified performance level is out of range of valid levels.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__Power__Status.html#ga3132904395c5631392bd6301d9a2181e">Power_EBUSY</a></td><td>if another transition is already in progress, or if a single constraint is set to prohibit any change to the performance level.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__Power__Status.html#gaa4e7b580b1c9c026036bf53befe5723b">Power_ECHANGE_NOT_ALLOWED</a></td><td>if a level-specific constraint prohibits a change to the requested level.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__Power__Status.html#gaed2f92a8c72bfa183e14d10a2e35789f">Power_EFAIL</a></td><td>if performance scaling is not supported, if an error occurred during initialization, or if an error occurred during client notifications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="power_8h.html#a33830ca68bc594b1f24c7285a62f0475" title="Get the current performance level.">Power_getPerformanceLevel()</a> </dd></dl>

</div>
</div>
<a id="aa4af0d238813058bf6146df6021df8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4af0d238813058bf6146df6021df8cc">&#9670;&nbsp;</a></span>Power_setPolicy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Power_setPolicy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="power_8h.html#aa7eca3f57d333d9c1a1ca02639674100">Power_PolicyFxn</a>&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new Power policy. </p>
<p>This function allows a new <a class="el" href="power_8h.html#aa7eca3f57d333d9c1a1ca02639674100" title="Power policy function pointer.">Power_PolicyFxn</a> function to be selected at runtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">policy</td><td>the new <a class="el" href="power_8h.html#aa7eca3f57d333d9c1a1ca02639674100" title="Power policy function pointer.">Power_PolicyFxn</a> function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45e1e0f3168cc39a2309fce40c3e271d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e1e0f3168cc39a2309fce40c3e271d">&#9670;&nbsp;</a></span>Power_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t Power_sleep </td>
          <td>(</td>
          <td class="paramtype">uint_fast16_t&#160;</td>
          <td class="paramname"><em>sleepState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition the device into a sleep state. </p>
<p>This function is called from the power policy when it has made a decision to put the device in a specific sleep state. This function returns to the caller (the policy function) once the device has awoken from sleep.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function must be called with interrupts disabled, and should not be called directly by the application, or by any drivers. This function does not check declared constraints; the policy function must check constraints before calling this function to initiate sleep.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sleepState</td><td>the sleep state</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__Power__Status.html#ga92eed670a5d7e3d43f612ca0da9d3fe2">Power_SOK</a></td><td>on success, the device has slept and is awake again.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__Power__Status.html#gaed2f92a8c72bfa183e14d10a2e35789f">Power_EFAIL</a></td><td>if an error occurred during client notifications, or if a general failure occurred.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__Power__Status.html#ga200ab87d1e0ffbc4eb3864d18646e0f7">Power_EINVALIDINPUT</a></td><td>if the <code>sleepState</code> is invalid.</td></tr>
    <tr><td class="paramname"><a class="el" href="group__Power__Status.html#ga3132904395c5631392bd6301d9a2181e">Power_EBUSY</a></td><td>if another transition is already in progress. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac32c17ce6da099da97957f08ddb000b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32c17ce6da099da97957f08ddb000b4">&#9670;&nbsp;</a></span>Power_unregisterNotify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Power_unregisterNotify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPower__NotifyObj.html">Power_NotifyObj</a> *&#160;</td>
          <td class="paramname"><em>pNotifyObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister previously registered notifications. </p>
<p>This function unregisters for event notifications that were previously registered with <a class="el" href="power_8h.html#aa89d120c82d4f23e6d4a337720b6300e" title="Register a function to be called upon a specific power event.">Power_registerNotify()</a>. The caller must specify a pointer to the same notification object used during registration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNotifyObj</td><td>The <a class="el" href="structPower__NotifyObj.html" title="Power notify object structure.">Power_NotifyObj</a> used with the original call to <a class="el" href="power_8h.html#aa89d120c82d4f23e6d4a337720b6300e" title="Register a function to be called upon a specific power event.">Power_registerNotify()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="power_8h.html#aa89d120c82d4f23e6d4a337720b6300e" title="Register a function to be called upon a specific power event.">Power_registerNotify()</a> </dd>
<dd>
<a class="el" href="group__Power__Latency__Type.html#ti_drivers_Power_Examples_notify">Using power notify</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="dir_abc9ad036f51ba48b607241e5ebbccbe.html">drivers</a></li><li class="navelem"><a class="el" href="power_8h.html">power.h</a></li>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
