<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>xWRL6432 MMWAVE-L-SDK: Ripple Demo</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="xWRL6432 MMWAVE-L-SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xWRL6432 MMWAVE-L-SDK
   &#160;<span id="projectnumber">05.05.04.02</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('EXAMPLES_RIPPLE_DEMO.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Ripple Demo </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md906">Ripple Overview</a></li>
<li class="level1"><a href="#autotoc_md907">TI Ripple Architecture</a></li>
<li class="level1"><a href="#autotoc_md908">Directory Structure</a></li>
<li class="level1"><a href="#autotoc_md909">Supported Ripple HAL Layer APIs</a></li>
<li class="level1"><a href="#autotoc_md910">How to Build the Demo</a></li>
<li class="level1"><a href="#autotoc_md911">How to Run the Demo</a></li>
<li class="level1"><a href="#autotoc_md912">Setting up ADC data capture via SPI</a></li>
<li class="level1"><a href="#autotoc_md913">Post Processing of ADC data</a></li>
<li class="level1"><a href="#autotoc_md914">Limitations</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_examples_examples_ripple_demo"></a></p>
<h1><a class="anchor" id="autotoc_md906"></a>
Ripple Overview</h1>
<p>Ripple is an open radar API standard that enables hardware and software interoperability, accelerating the growth of applications for general-purpose consumer radar. This standard was developed by the Ripple Technical Project Group of the Consumer Technology Association (CTA). Ripple APIs offer several benefits, including standardized calls and a software library that can function across various radar hardware implementations, ensuring reusability and easier firmware upgrades. An open API standard makes it easier for integrators to begin, develop, and distribute radar solutions. Standardized software that works across all radar applications simplifies experimentation and prototyping, making radar more accessible to students, startups, academics, and researchers. </p>
<p>Ripple will enable developers to create specialized extensions so that they can build on the standard to support their own differentiated use cases. These extensions can be incorporated as official interfaces in future versions of the standard. </p>
<h1><a class="anchor" id="autotoc_md907"></a>
TI Ripple Architecture</h1>
<p> <style>div.image img[src="ripple_architecture.png"]{width:40%}</style> </p><div class="image">
<img src="ripple_architecture.png" alt=""/>
<div class="caption">
TI Ripple Architecture</div></div>
 <p>Ripple Demo on xWRL6432 provides a Hardware Abstraction Layer (HAL) of API library and test application that follows the standards defined in Ripple Radar Sensor API Version 1.1, CTA Specification as of June 2022.</p>
<p>Ripple Demo Consists of the following Layers: </p><ul>
<li>
<p class="startli"></p>
<p class="endli"><b>Ripple HAL Layer:</b> A Hardware Abstraction Layer that consist of an API Library that has APIs that follow ripple standards and can be used to configure and collect ADC data from xwrL6432 TI radar. These APIs are only supported on Linux or Raspberry PI OS. These APIs take user input for configurations and converts it into radar device understood CLI commands.  </p>
</li>
<li>
<p class="startli"></p>
<p class="endli"><b>Ripple HAL Demo:</b> Simple test application that uses APIs from Ripple HAL Layer to Configure the radar.  </p>
</li>
<li>
<p class="startli"></p>
<p class="endli"><b>Ripple Demo:</b> Application that needs to be running on the radar’s system to support the APIs called from ripple HAL layer. This application reads the CLI commands coming from HAL Layer and make the corresponding firmware calls to configure the radar’s frontend. When the user starts data streaming, this application writes raw ADC data to SPI after each chirp.  </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md908"></a>
Directory Structure</h1>
<table class="doxtable">
<tr>
<th>Directory</th><th>Description </th></tr>
<tr>
<td>ripple_demo</td><td>Package that contains both linux level library and corresponding device application  </td></tr>
<tr>
<td>HAL-Demo</td><td>A test application that uses Ripple APIs from HAL-Lib. It configures the radar for a predefined configuration </td></tr>
<tr>
<td>HAL-Lib</td><td>The library that contains definitions to the Ripple defined APIs  </td></tr>
<tr>
<td>ripple_cli</td><td>Contains code for command line interface of device application  </td></tr>
<tr>
<td>ripple_flash</td><td>Contains code for flash interface of device application  </td></tr>
<tr>
<td>ripple_link</td><td>Contains code for control library of device application, this library makes the firmware calls  </td></tr>
<tr>
<td>ripple_pwr</td><td>Contains code for power management framework of device application, it helps to set device power modes </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md909"></a>
Supported Ripple HAL Layer APIs</h1>
<table class="doxtable">
<tr>
<th><b>API:</b> </th><th>RadarHandle* radarCreate(int32_t id)   </th></tr>
<tr>
<td><b>Description:</b>  </td><td>This API creates and allocates the internal structure(s) required to manage the radar and return a handle for other functions in this API to use to access a specific radar’s capabilities.   </td></tr>
<tr>
<td><b>Implementation:</b>  </td><td>This function opens the device serial com ports returns a pointer to a structure that contains serial port file descriptors. This function also sets the default values for vendor specific operating Parameters.   </td></tr>
<tr>
<th><b>API:</b> </th><th>RadarReturnCode radarDestroy(RadarHandle* handle)   </th></tr>
<tr>
<td><b>Description:</b>  </td><td>The API provides function to destroy a previously created radar instance.  </td></tr>
<tr>
<td><b>Implementation:</b>  </td><td><p class="starttd">This function closes device serial ports and clears the radar handle structure created by radar create API. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<th><b>API:</b> </th><th>RadarReturnCode radarSetMainParam(RadarHandle* handle, uint32_t slot_id, RadarMainParam id, uint32_t value)   </th></tr>
<tr>
<td><b>Description:</b> </td><td>The API provides a function to configure main operating parameters.  </td></tr>
<tr>
<td><b>Implementation:</b>  </td><td><p class="starttd">This function takes main configuration parameters and store the configuration in various structures on the HAL level. The following are the main parameters that should be set: </p><table class="doxtable">
<tr>
<td><b>Id </b> </td><td><b>Radar Main Param </b> </td><td><b>Description </b> </td><td><b>CLI Config Command</b>  </td></tr>
<tr>
<td>0 </td><td>RADAR_PARAM_UNDEFINED </td><td>A default undefined value that should be used at initialization. </td><td>-  </td></tr>
<tr>
<td>1 </td><td>RADAR_PARAM_AFTERBURST_POWER_MODE </td><td>Power mode for after the burst period. 1 means after burst low power mode is enabled. 0 Means Desabled </td><td>lowPowerCfg  </td></tr>
<tr>
<td>2 </td><td>RADAR_PARAM_INTERCHIRP_POWER_MODE </td><td>Power mode for the period between chirps. <br  />
 </td><td>Not Supported  </td></tr>
<tr>
<td>3 </td><td>RADAR_PARAM_BURST_PERIOD_US <br  />
 </td><td>Duration between the start times of two consecutive bursts. <br  />
 </td><td>FrameCfg "framePeriodicity"  </td></tr>
<tr>
<td>4 </td><td>RADAR_PARAM_CHIRP_PERIOD_US </td><td>Duration between the start times of two consecutive chirps </td><td>"idleTime" + "rampEndTime"  </td></tr>
<tr>
<td>5 </td><td>RADAR_PARAM_CHIRPS_PER_BURST </td><td>Number of chirps within the burst. <br  />
 </td><td>FrameCfg "NumberOfLoops"  </td></tr>
<tr>
<td>6 </td><td>RADAR_PARAM_SAMPLES_PER_CHIRP </td><td>The number of ADC sample values captured for each chirp. <br  />
 </td><td>chirpComnConfig "numAdcSamples"  </td></tr>
<tr>
<td>7 </td><td>RADAR_PARAM_LOWER_FREQ_MHZ </td><td>The lower frequency at what TX antenna starts emitting the signal. </td><td>chirpTimingCfg "startFreq"  </td></tr>
<tr>
<td>8 </td><td>RADAR_PARAM_UPPER_FREQ_MHZ </td><td>The upper frequency at what TX antenna stops emitting the signal. </td><td>"upperFreq" = ("rampEndTime"*"slope") + "startFreq"  </td></tr>
<tr>
<td>9 </td><td>RADAR_PARAM_TX_ANTENNA_MASK </td><td>Bit mask for enabled TX antennas. </td><td>channelCfg "txChannelEn"  </td></tr>
<tr>
<td>10 </td><td>RADAR_PARAM_RX_ANTENNA_MASK </td><td>Bit mask for enabled RX antennas </td><td>channelCfg "rxChannelEn"  </td></tr>
<tr>
<td>11 </td><td>RADAR_PARAM_UNUSED_0 </td><td>Unused parameter. </td><td>-  </td></tr>
<tr>
<td>12 </td><td>RADAR_PARAM_ADC_SAMPLING_HZ </td><td>ADC sampling frequency. </td><td>chirpComnCfg "digOutSampleRate"  </td></tr>
</table>
<p class="endtd"></p>
</td></tr>
<tr>
<th><b>API:</b> </th><th>RadarReturnCode radarGetMainParam(RadarHandle* handle, uint8_t slot_id, RadarMainParam id,    uint32_t* value)   </th></tr>
<tr>
<td><b>Description:</b>  </td><td>The API provides a function to retrieve main operating parameters.  </td></tr>
<tr>
<td><b>Implementation:</b>  </td><td>the function returns main operating parameter values stored in the local structures.  </td></tr>
<tr>
<th><b>API:</b> </th><th>RadarReturnCode radarSetTxParam(RadarHandle* handle, uint8_t slotid, uint32_t antenna_mask, RadarTxParam id ,uint32_t value)  </th></tr>
<tr>
<td><b>Description:</b> </td><td>The API provides a function to configure TX antenna specific operating parameters.  </td></tr>
<tr>
<td><b>Implementation:</b>  </td><td>This function takes TX antenna specific operating parameters and store the configuration in various structures on the HAL level. The following are the TX antenna specific operating parameters that should be set: <table class="doxtable">
<tr>
<td><b>Id</b> </td><td><b>Radar Tx Param</b> </td><td><b>Description</b> </td><td><b>CLI Configuration command</b>  </td></tr>
<tr>
<td>0 </td><td>TX_PARAM_UNDEFINED </td><td>A default undefined value that should be used at initialization. </td><td>-  </td></tr>
<tr>
<td>1 </td><td>TX_PARAM_POWER_DB </td><td>A TX antenna’s emitting power in dB. </td><td>factoryCalibCfg "txOutPower"  </td></tr>
</table>
</td></tr>
<tr>
<th><b>API:</b> </th><th>RadarReturnCode radarGetTxParam(RadarHandle* handle, uint8_t slot_id, uint32_t antenna_mask, RadaRxParam id, uint32_t* value)  </th></tr>
<tr>
<td><b>Description:</b></td><td>The API provides a function to retrieve TX antenna specific operating parameters.  </td></tr>
<tr>
<td><b>Implementation</b> </td><td>The function returns TX antenna specific operating parameter values stored in the local structures.  </td></tr>
<tr>
<th><b>API:</b> </th><th>RadarReturnCode radarSetRxParam(RadarHandle* handle, uint8_t slotid, uint32_t antenna_mask, RadarRxParam id ,uint32_t value)  </th></tr>
<tr>
<td><b>Description:</b> </td><td>The API provides a function to configure RX antenna specific operating parameter.  </td></tr>
<tr>
<td><b>Implementation:</b></td><td>This function takes RX antenna specific operating parameters and store the configuration in various structures on the HAL level. The following are the TX antenna specific operating parameters that should be set:   <table class="doxtable">
<tr>
<td><b>Id</b> </td><td><b>Radar Rx Param</b> </td><td><b>Description</b> </td><td><b>CLI Configuration command</b>  </td></tr>
<tr>
<td>0 </td><td>RX_PARAM_UNDEFINED </td><td>A default undefined value that should be used at initialization. </td><td>-  </td></tr>
<tr>
<td>1 </td><td>RX_PARAM_VGA_DB </td><td>Variable Gain Amplifiers (VGA) in dB. <br  />
 </td><td>factoryCalibCfg "rxGain"  </td></tr>
<tr>
<td>2 </td><td>RX_PARAM_HP_GAIN_DB </td><td>High Pass (HP) filter gain in dB. </td><td>NOT Supported  </td></tr>
<tr>
<td>3 </td><td>RX_PARAM_HP_CUTOFF_KHZ </td><td>High Pass (HP) cut off frequency in kHz. </td><td>NOT Supported  </td></tr>
</table>
</td></tr>
<tr>
<th><b>API:</b></th><th>RadarReturnCode radarGetRxParam(RadarHandle* handle, uint8_t slot_id, uint32_t antenna_mask, RadaRxParam id, uint32_t* value) </th></tr>
<tr>
<td><b>Description:</b></td><td>The API provides a function to retrieve RX antenna specific operating parameters.  </td></tr>
<tr>
<td><b>Implementation:</b></td><td>The function returns RX antenna specific operating parameter values stored in the local structures.  </td></tr>
<tr>
<th><b>API:</b></th><th>RadarReturnCode radarSetVendorParam(RadarHandle* handle, uint32_t slot_id, RadarVendorParam id, uint32_t value)  </th></tr>
<tr>
<td><b>Description:</b> </td><td>The API provides a function to configure the TI specific sensor operating parameters.  </td></tr>
<tr>
<td><b>Implementation:</b></td><td><p class="starttd">This function takes vendor specific operating parameters and store the configuration in various structures on the HAL level. Although the vendor specific parameters are configured to their default values, so they are not required to be set for basic operation of device.</p>
<table class="doxtable">
<tr>
<td><b>Id</b> </td><td><b>Radar Vendor Specific Parameter</b> </td><td><b>Description </b> </td><td><b>Default Values</b>  </td></tr>
<tr>
<td>0 <br  />
 </td><td>RADAR_VENDOR_PARAM_UNDEFINED </td><td>A default undefined value that should be used at initialization. </td><td>-  </td></tr>
<tr>
<td>1 </td><td>RADAR_VENDOR_PARAM_CHIRP_IDLE_TIME </td><td>Time period Between Ramp End and Ramp Start time (in us). It is used to calculate and configure chirp’s Ramp End time. </td><td>2950 us  </td></tr>
<tr>
<td>2 </td><td>RADAR_VENDOR_PARAM_NUM_OF_BURST </td><td>Number of bursts that the user wants to receive can be configured. If set to 0 it means infinite bursts. </td><td>5 Bursts  </td></tr>
</table>
</td></tr>
<tr>
<th><b>API:</b> </th><th>RadarReturnCode radarGetVendorParam(RadarHandle* handle, uint8_t slot_id, RadarVendorParam id, uint32_t* value)  </th></tr>
<tr>
<td><b>Description:</b></td><td>The API provides a function to retrieve vendor specific operating parameters.   </td></tr>
<tr>
<td><b>Implementation:</b> </td><td>The function returns vendor specific operating parameter values stored in the local structures.  </td></tr>
<tr>
<th><b>API:</b> </th><th>RadarReturnCode radarActivateConfig(RadarHandle* handle, int8_t slot_id)   </th></tr>
<tr>
<td><b>Description:</b></td><td>The API provide a function to activate the configurations.  </td></tr>
<tr>
<td><b>Implementation:</b></td><td>The Function converts all the configurations set by radarSetMainParam, radarSetTxParam, radarSetRxParam and radarSetVendorParam to CLI commands by performing necessary calculations when required. The function then sends the CLI Commands to the radar.   </td></tr>
<tr>
<th><b>API:</b> </th><th>RadarReturnCode radarStartDataStreaming(RadarHandle* handle)   </th></tr>
<tr>
<td><b>Description:</b></td><td>The API provides a function to start running the radar with the provided configuration and starts emitting data.  </td></tr>
<tr>
<td><b>Implementation:</b> </td><td><p class="starttd">The function sends the CLI command “sensorStart” to the radar.</p>
<p class="endtd"></p>
</td></tr>
<tr>
<th><b>API:</b></th><th>RadarReturnCode radarReadBurst(RadarHandle* handle, RadarBurstFormat* format, uint8_t* buffer, uint32_t* read_bytes, timespec_t timeout)   </th></tr>
<tr>
<td><b>Description:</b> </td><td>The API provides a function to read a single data burst.  </td></tr>
<tr>
<td><b>Implementation:</b></td><td>The function reads data from serial port of exact size equivalent of one burst into buffer.   </td></tr>
<tr>
<th><b>API:</b></th><th>RadarReturnCode radarSetBurstReadyCb(RadarHandle* handle, RadarBurstReadyCB cb, void* user_data)   </th></tr>
<tr>
<td><b>Description:</b></td><td>The API provides a means to register a callback to be invoked when Burst Data is ready to be read.  </td></tr>
<tr>
<td><b>Implementation:</b></td><td>The function registers the OnBurstReady callback which calls radarReadBurst function to read Burst data from the radar. <b>OnBurstReady</b> callback is invoked for each newly available set of burst data.  </td></tr>
<tr>
<th><b>API:</b></th><th>RadarReturnCode radarStopDataStreaming(RadarHandle* handle)  </th></tr>
<tr>
<td><b>Description:</b> </td><td>The API provides a function to stop running the radar which will stop capturing and sending data from radar.  </td></tr>
<tr>
<td><b>Implementation:</b> </td><td><p class="starttd">The function writes the CLI command “sensorStop” to the radar. </p>
<p class="endtd"></p>
</td></tr>
</table>
<h1><a class="anchor" id="autotoc_md910"></a>
How to Build the Demo</h1>
<ol>
<li>
Install the MMWAVE-L-SDK on Host(Linux). </li>
<li>
Steps to build the Host (Linux) demo:<ul>
<li>Open the terminal in “HAL-Demo” directory and run the command “make”. This builds the host demo executable.  </li>
</ul>
</li>
<li>
Steps to build the device(xwrLx4xx) demo (if not already built):<ul>
<li>Build the target files using following command. <div class="fragment"><div class="line">make -s -C examples/ripple_demo/xwrL64xx-evm/m4fss0-0_freertos/ti-arm-clang all</div>
</div><!-- fragment -->  </li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md911"></a>
How to Run the Demo</h1>
<ol>
<li>
Connect xWRL6432 to your host. </li>
<li>
Flash the target ‘ripple_demo.release.appimage’ built in examples/ripple_demo/xwrL64xx-evm/m4fss0-0_freertos/ti-arm-clang to the device using visualizer tool.  </li>
<li>
Switch the device to Functional mode and keep the following switch settings: <table class="doxtable">
<tr>
<th>S1.1 </th><th>S1.2 </th><th>S1.3 </th><th>S1.4 </th><th>S1.5 </th><th>S1.6  </th></tr>
<tr>
<td>On </td><td>Off </td><td>On </td><td>Off </td><td>On </td><td>On  </td></tr>
</table>
<table class="doxtable">
<tr>
<th>S4.1 </th><th>S4.2 </th><th>S4.3 </th><th>S4.4  </th></tr>
<tr>
<td>Off </td><td>Off </td><td>Off </td><td>On  </td></tr>
</table>
</li>
<li>
Saleae logic analyzer (Logic Pro 8 or above) can be used to capture burst data (Raw ADC data) data. Details of setup can be found at 'Setting up ADC data capture via SPI' section below. </li>
<li>
On Linux host, once the setup is ready as per previous step, start capture of SPI data in the Logic Software by pressing 'Start' button. Then, open the terminal in the HAL_Demo directory and run the demo using "./Demo" command. </li>
<li>
Enter the Application/UART COM Port Number "/dev/ttyxxxx" and press Enter. </li>
<li>
<p class="startli">As the demo runs, SPI waveforms are captured in Logic software. Data received can be seen in 'Data' tab of 'Analyzers' window. </p>
<p class="interli"> <style>div.image img[src="ripple_waveforms.png"]{width:80%}</style> </p><div class="image">
<img src="ripple_waveforms.png" alt=""/>
</div>
<p class="endli"></p>
</li>
<li>
<p class="startli">Export the data to a text file for post processing.</p>
<p class="endli"></p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md912"></a>
Setting up ADC data capture via SPI</h1>
<ul>
<li>ADC data is transferred out via SPI after every chirp.</li>
<li>Device configures SPI interface as follows:<ul>
<li>Speed: 28Mhz</li>
<li>Data Width: 32 bits (MSB first)</li>
<li>Chip select: Active Low</li>
<li>SPI Mode: 0 (CPOL = 0, CPHA = 0)</li>
</ul>
</li>
<li>Connect the Saleae logic analyzer to device (xWRL6432) as shown below. On host, install the Logic software to capture the data.</li>
</ul>
<p> <style>div.image img[src="ripple_setup.png"]{width:60%}</style> </p><div class="image">
<img src="ripple_setup.png" alt=""/>
</div>
<ul>
<li>In Logic software, configure for SPI analyzer (as per configurations above) in 'analyzers' window to capture SPI data. Configure for sampling rate more than or equal to 100 MS/s.</li>
</ul>
<h1><a class="anchor" id="autotoc_md913"></a>
Post Processing of ADC data</h1>
<ol>
<li>
processAdcData.m is a matlab script that can be used for parsing the ADC data collected via SPI. It is placed at /examples/ripple_demo/ADCDataProcessing. This folder has reference ADC data file and reference config file as well. </li>
<li>
<p class="startli">Run the below command in the MATLAB command window:  </p><div class="fragment"><div class="line">frameAdcData = processAdcData(&lt;adcDataFname&gt;, &lt;cfgFname&gt;);</div>
</div><!-- fragment --><p> Two input arguments:<br  />
 &emsp;a. adcDataFname: .txt file containing ADC data in hexadecimal format as described below (already streamed by SPI in this format)<br  />
  <style>div.image img[src="ripple_byteorder.png"]{width:10%}</style> </p><div class="image">
<img src="ripple_byteorder.png" alt=""/>
</div>
<p> &emsp;b. cfgFname: .cfg file containing the radar CLI used to collect the ADC data. <br  />
 Output:<br  />
 &emsp;frameAdcData: It returns ADC data of a frame in format [RX*TX][Samples][Chirps].<br  />
</p>
<p class="endli"></p>
</li>
<li>
The script does the following operations:<br  />
 &emsp;a. Parse the ADC data of the format described above into ‘int16’ samples array.<br  />
 &emsp;b. Parse the .cfg file used to collect the ADC data using the ripple demo.<br  />
 &emsp;c. ADC data is reshaped in in format [RX*TX][Samples][Chirps].<br  />
 &emsp;d. First FFT is done on samples to resolve the range, then FFT is done across the chirps to resolve the doppler.<br  />
 &emsp;e. 2d-FFT plot (detection matrix) is plotted every frame and the range fft vs Chirps for all the frames is plotted at the last.<br  />
 </li>
</ol>
<p>Sample Plots:  <style>div.image img[src="ripple_heat_map.png"]{width:60%}</style> </p><div class="image">
<img src="ripple_heat_map.png" alt=""/>
</div>
<h1><a class="anchor" id="autotoc_md914"></a>
Limitations</h1>
<ul>
<li>
The ADC data for every chirp is transfered during chirp idle time. Hence, users have to ensure that sufficient chirp idle time is available so as to transfer all the SPI data. Eg: When 128 ADC samples (256 bytes) are configured per chirp, we need atleast ~140usec as chirp idle time.  </li>
<li>
BPM-MIMO scheme is not supported by the Matlab post processing script. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
