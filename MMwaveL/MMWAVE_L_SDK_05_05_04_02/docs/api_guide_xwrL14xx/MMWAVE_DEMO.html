<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>xWRL1432 MMWAVE-L-SDK: Mmwave Demo</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="xWRL1432 MMWAVE-L-SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xWRL1432 MMWAVE-L-SDK
   &#160;<span id="projectnumber">05.05.04.02</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('MMWAVE_DEMO.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Mmwave Demo </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_examples_mmw_demos_mmwave_demo"></a> </p>
<h1><a class="anchor" id="autotoc_md848"></a>
Purpose and Scope</h1>
<p>The millimeter wave demo (Mmwave_demo) is the out of box (OOB) millimeter wave radar signal processing chain demo on xWRL1432 SOC device. This chapter presents the millimeter wave demo (mmwave_demo) radar signal processing chain demo implementation details on xWRL1432 SOC device using the MMWAVE LP SDK. The chapter provides a description of the signal processing flow, memory usage, and benchmark results. It also focuses on the implementation details of the low-level signal processing chain. The processing chain is based on range-doppler detection. This chain can be used as a resource for initiating parkingassist applications, blind spot detection (BSD) applications, and many more applications.</p>
<h1><a class="anchor" id="MMWAVE_DEMO_COMBOS"></a>
Supported Combinations</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter  </th><th class="markdownTableHeadNone">Value   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CPU + OS  </td><td class="markdownTableBodyNone">m4fss0-0 freertos   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Toolchain  </td><td class="markdownTableBodyNone">ti-arm-clang   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Board  </td><td class="markdownTableBodyNone">xWRL1432-evm   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Example folder  </td><td class="markdownTableBodyNone">examples/mmw_demo/mmwave_demo   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md849"></a>
Supported Features</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Feature  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CLI Removal  </td><td class="markdownTableBodyNone">This feature generates an optimized application with reduced RAM and inturn reduced power. It is important to note that CLI is removed, if this feature is enabled, in addition to other CLI dependent features such as ADC logging, Monitors etc. This is disabled by default.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Raw ADC streaming  </td><td class="markdownTableBodyNone">Streaming of adc data over RDIF+DCA1000 or SPI. This feature is disabled by default.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Monitors  </td><td class="markdownTableBodyNone">FECSS analog monitors. This feature is disabled by default.   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Developer Guideline:<ul>
<li>It is adviced to keep M4 in WFI mode when device is actively chirping, to save power and reduce chances of noise coupling to RF</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="autotoc_md850"></a>
Using SysConfig</h1>
<p>A GUI tool SysConfig is used to configure different modules and peripherals of the example. Using this tool, users can select and customize different modules and peripherals. The SysConfig tool will generate the code for initializing and configuring these modules. This configuration is saved to a file called example.syscfg for every example. To know more about how to use SDK with SysConfig, Visit this page</p>
<p><a class="el" href="SYSCONFIG_INTRO_PAGE.html">Using SDK with SysConfig</a></p>
<h2><a class="anchor" id="autotoc_md851"></a>
Custom Demo Code Options</h2>
<p>Additionally, the GUI also allows enabling of supported combinations of the features listed above.</p>
<h3><a class="anchor" id="autotoc_md852"></a>
Steps to enable/disable the supported features</h3>
<ul>
<li>Open the demo example.syscfg and navigate to the TI DEMO menu</li>
<li>This provides the flexibility to Enable/Disable the features as shown in the figure below. Choose the required features and save the example.syscfg file</li>
</ul>
<p> <style>div.image img[src="mmwave_syscfg_start.png"]{width:60%}</style> </p><div class="image">
<img src="mmwave_syscfg_start.png" alt=""/>
</div>
<ul>
<li>Compile the application and run the demo with the updated binaries</li>
</ul>
<h3><a class="anchor" id="autotoc_md853"></a>
CLI Removal Feature</h3>
<p>This feature, if enabled, allows for a memory optimized demo code and application by disabling the CLI utility SW resources. By default, the demo configurations are predefined and the values match the default parking_5m.cfg.</p>
<p>However, the flexibility to modify these configurations is still possible through a sysconfig build-time option, to upload the required config via json file. This is an optional step, only if the default configuration needs to be updated.</p>
<p> <style>div.image img[src="mmwave_syscfg.png"]{width:75%}</style> </p><div class="image">
<img src="mmwave_syscfg.png" alt=""/>
</div>
<p>Reference json file for CLI-removal based demo processing (CLI_Rem.json) is available in the demo's profiles folder in the SDK (../examples/mmw_demo/mmwave_demo/profiles). All parameters remain similar to the CLI cfg file and details about the same can be found in the Configuration file format section below.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>When CLI Removal is enabled, Phase compensation factors are taken from the default unity compensation factors(By default - real coefficients are unity factors with sign corresponding to the antenna phase shift for FCCSP design, imag coefficients are zeros) predefined in the application code.</li>
<li>When CLI Removal is enabled, the following features are not supported:<ul>
<li>Monitors</li>
<li>Raw ADC data streaming</li>
<li>SDK Visualizer (Alternatively, BAC/Industrial visualizer could be used for performance visualization, using Start Without Sending CFG option. Please refer to TI Radar ToolBox for more details)</li>
</ul>
</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="autotoc_md854"></a>
MMWAVE Demo Setup</h1>
<p>The demo detection demo setup is shown in Figure below. The demo configuration is provided by the command line interface (CLI) configuration file. The PC visualizer is connected to xWRL1432 EVM board via a single UART port. Initially, to start a demo, a set of CLI configuration commands is sent to the EVM. Based on the configuration the EVM sends through the same port various detection information to the visualizer, such as point cloud, range profile, detection heatmap, presence detection information, and stats data.</p>
<p> <style>div.image img[src="mmwave_setup.png"]{width:70%}</style> </p><div class="image">
<img src="mmwave_setup.png" alt=""/>
<div class="caption">
Millimeter wave demo setup</div></div>
<p>The processing layers of the demo is shown below</p>
<p> <style>div.image img[src="mmwave_sigpro.png"]{width:40%}</style> </p><div class="image">
<img src="mmwave_sigpro.png" alt=""/>
<div class="caption">
The signal processing layers of the millimeter wave demo</div></div>
<p>Below is the top-level radar signal processing timing diagram per frame</p>
<p> <style>div.image img[src="mmwave_sigpro_timing.png"]{width:80%}</style> </p><div class="image">
<img src="mmwave_sigpro_timing.png" alt=""/>
<div class="caption">
Signal processing high level timing diagram</div></div>
<h1><a class="anchor" id="autotoc_md855"></a>
MIMO Modulation Schemes</h1>
<p>The demo currently supports only a 2 TX BPM-MIMO scheme. In addition, it supports only uniform chirp distribution within the frame (‚ÄúNormal Mode‚Äù), namely single burst per frame, and even number of chirps per burst. The example of the chirp timing diagram is shown in Figure below.</p>
<p> <style>div.image img[src="mmwave_bpm_mimo.png"]{width:80%}</style> </p><div class="image">
<img src="mmwave_bpm_mimo.png" alt=""/>
<div class="caption">
Chirp timing diagram 2Tx BPM-MIMO</div></div>
<h1><a class="anchor" id="autotoc_md856"></a>
Antenna Geometry</h1>
<p>The demo supports different antenna configurations. This is achieved through the CLI configuration. The antenna pattern is specified by the CLI command antGeometryCfg. The command specifies the row and column position for each virtual antenna in the 2D virtual antenna array grid, as illustrated in Figure below. The syntax of the command is</p>
<p>antGeometryCfg ant1Row ant1Col ant2Row ant2Col ‚Ä¶ant6Row ant6Col distX distZ</p>
<p>The last two parameters of the command specify antenna spacing (in millimeters) in X and Z dimensions.</p>
<p> <style>div.image img[src="mmwave_ant_geo.png"]{width:80%}</style> </p><div class="image">
<img src="mmwave_ant_geo.png" alt=""/>
<div class="caption">
Virtual antenna arrangement based on the Tx/Rx antenna pattern and the corresponding CLI configuration command for xWRL1432 EVM board</div></div>
<p>Below figure shows the antenna configuration on the XWRL1432 EVM board.</p>
<p> <style>div.image img[src="xwrL1432.png"]{width:50%}</style> </p><div class="image">
<img src="xwrL1432.png" alt=""/>
<div class="caption">
IWRL1432 EVM board, FR4 based, 2-patch antennas.</div></div>
<p>The antenna spacing and the virtual antenna array are shown in Figure below. The right-most figure shows the virtual antenna with the red and blue antennas corresponding to TX1 and TX2 respectively.</p>
<p> <style>div.image img[src="mmwave_ant_spacing.png"]{width:80%}</style> </p><div class="image">
<img src="mmwave_ant_spacing.png" alt=""/>
<div class="caption">
Antenna spacing and virtual antenna array representation</div></div>
<h1><a class="anchor" id="autotoc_md857"></a>
Signal Processing Chain</h1>
<p>The top-level view of this signal processing chain is shown in Figure below. This chain performs object detection in dange-doppler detection matrix.</p>
<p> <style>div.image img[src="mmwave_sigpro_chain.png"]{width:80%}</style> </p><div class="image">
<img src="mmwave_sigpro_chain.png" alt=""/>
<div class="caption">
Signal processing chain ‚Äì top-level view</div></div>
<p>The signal processing consists of the following data processing units:</p>
<ul>
<li><b>Range DPU:</b> Performs:<ul>
<li>Range FFT for each antenna and chirp. Note that although that the chain is configured in BPM mode, the range DPU is configured with disabled BPM since the BPM decoding is performed in the last DPU in the processing chain.</li>
<li>The only radar data cube format supported in this demo is <b>DPIF_RADARCUBE_FORMAT_6</b></li>
</ul>
</li>
<li><b>DOA DPU:</b> This DPU creates Range-doppler detection matrix using an approach of non-coherent Doppler FFT summation across virtual antennas. Per range bin it performs:<ul>
<li>Doppler FFT per each antenna,</li>
<li>Non-coherent summation of Doppler FFT magnitudes across all virtual antennas.</li>
</ul>
</li>
<li><b>CFAR DPU:</b> Performs CFAR detection algorithm on the range-doppler detection matrix:<ul>
<li>CFAR detection algorithm (CFAR-CASO) applied along range dimension,</li>
<li>Detected points confirmed by being local peak in Doppler domain,</li>
<li>Range and Doppler interpolation,</li>
<li>Sorting of the detected points with range indices in increasing order</li>
</ul>
</li>
<li><b>AoA2D DPU:</b> This DPU generates a final point cloud list in Cartesian format, achieved through the following operations:<ul>
<li>for each group of detected points at the same range index, it computes Doppler FFT,</li>
<li>for each detected point in the group, at the detected range and Doppler index pair, it performs the following operations:<ul>
<li>it maps the antenna symbols from the detected range and Doppler index pair into a 2D virtual antenna array,</li>
<li>it then computes 2D azimuth/elevation FFT on the virtual antenna array,</li>
<li>based on the peaks in the azimuth domain and corresponding positions in the elevation domain, the DPU calculates the coordinates of the detected points in Cartesian format.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md858"></a>
Data Compression</h2>
<p>This section describes the data compression option implemented in the signal processing chain. The primary reason for data compression is the reduction of the size of the data storage, namely the radar cube memory size which can be quite large for certain applications. The compression is applied on the output of the range FFT data resulting in the reduced radar cube memory. The applied compression and decompression operations in the processing chain are illustrated in Figure below. The data compression is integrated in the range processing DPU, while the data decompression is integrated in the Doppler DPU and AoA2D DPU.</p>
<p> <style>div.image img[src="mmwave_comp_decomp_sigpro_chain.png"]{width:80%}</style> </p><div class="image">
<img src="mmwave_comp_decomp_sigpro_chain.png" alt=""/>
<div class="caption">
Compression/decompression feature integrated in the signal processing chain</div></div>
<p>The data compression/decompression is performed by HWA. The compression method used in the processing chain is the BFT method and it is applied on the pair of consecutive range bins of the same Rx channel. The two options of the compression ratios (CR) are supported in the processing chain, CR=50% and CR=25%.</p>
<p><b>Compression ratio - 50%:</b></p>
<p>The compression operation is illustrated in Figure below. It is applied on the range FFT output samples. The input to one compression operation consists of the two range bins, occupying 64 bits, that is 2 complex samples of type complex16, represented as four 16-bit real values. The output consists of the 4-bit common exponent and the four 7-bit mantissa fields corresponding to the four 16-bit input values, making the total output size of 32 bits.</p>
<p> <style>div.image img[src="mmwave_comp_50.png"]{width:80%}</style> </p><div class="image">
<img src="mmwave_comp_50.png" alt=""/>
<div class="caption">
BFP compression, compression ratio = 50%</div></div>
<p><b>Compression ratio - 25%:</b></p>
<p>The compression operation is illustrated in Figure below. It is applied on the range FFT output samples. The input to the one compression operation consists of the two range bins, occupying 64 bits, that is 2 complex samples of type complex16, represented as four 16-bit real values. The output consists of the 4-bit common exponent and the four 3-bit mantissa fields corresponding to the four 16-bit input values, making total output size of 16 bits.</p>
<p> <style>div.image img[src="mmwave_comp_25.png"]{width:80%}</style> </p><div class="image">
<img src="mmwave_comp_25.png" alt=""/>
<div class="caption">
BFP compression, compression ratio = 25%</div></div>
<h3><a class="anchor" id="autotoc_md859"></a>
Range processing DPU</h3>
<p>The range processing diagram with compression is shown in Figure below. The two param sets are added for the compression operation after the range FFT, one in the ping and the other in the pong processing path.</p>
<p> <style>div.image img[src="mmwave_rangedpu_comp.png"]{width:80%}</style> </p><div class="image">
<img src="mmwave_rangedpu_comp.png" alt=""/>
<div class="caption">
Range processing DPU with compression option</div></div>
<h3><a class="anchor" id="autotoc_md860"></a>
Doppler Processing DPU</h3>
<p>The Doppler processing DPU diagram with optional decompression is shown in Figure below. The two decompression param sets (one in ping and the other in pong path) decompress two range gates each.</p>
<p> <style>div.image img[src="mmwave_dopdpu_decomp.png"]{width:70%}</style> </p><div class="image">
<img src="mmwave_dopdpu_decomp.png" alt=""/>
<div class="caption">
Doppler DPU including decompression option</div></div>
<h3><a class="anchor" id="autotoc_md861"></a>
AoA2D DPU</h3>
<p>The AoA2D DPU diagram is shown in Figure below. The decompression param set is placed before the Doppler FFT pram set. Although the decompression engine decompresses data of the two range bins, only one range bin is output into the HWA memory. During the configuration time the two param sets are created, one for even range bin and the other for odd range bin, and then the sets are saved in the local memory. At the run time, depending on the detected range bin index being odd or even, the corresponding param set is loaded to HWA before execution.</p>
<p> <style>div.image img[src="mmwave_aoa2d_decomp.png"]{width:70%}</style> </p><div class="image">
<img src="mmwave_aoa2d_decomp.png" alt=""/>
<div class="caption">
AoA2D processing DPU with decompression option</div></div>
<p>The processing flow is illustrated in Figure below. There is a slight difference in the processing flow when the compression is enabled and when it is disabled.</p>
<p> <style>div.image img[src="mmwave_aoa2d_comp_decomp_flow.png"]{width:40%}</style> </p><div class="image">
<img src="mmwave_aoa2d_comp_decomp_flow.png" alt=""/>
<div class="caption">
AoA2D processing flow with compression disabled on the left and with compression enabled on the right</div></div>
<p>When the compression is disabled, the input EDMA data transfer of the next range gate is done in parallel with the angle processing of the current range gate, and therefore the EDMA transfer and the HWA Doppler processing are software triggered separately, while when the compression is enabled, the EDMA transfer and the HWA Doppler processing are chained, and software triggered one time</p>
<h1><a class="anchor" id="autotoc_md862"></a>
Rx Channel Gain/Offset Measurement and Compensation</h1>
<p>Because of imperfections in antenna layouts on the board there is a need to calibrate the sensor to compensate for bias in the range estimation and the receive channel gain and phase imperfections. The demo provides the ability to do the measurement and compensation.</p>
<h2><a class="anchor" id="autotoc_md863"></a>
Measurement Procedure Implementation</h2>
<p>The measurement procedure is configured using a CLI command measureRangeBiasAndRxChanPhase. The following is the command syntax:</p>
<p>measureRangeBiasAndRxChanPhase enabled targetDistance searchWindow</p><ul>
<li>where enabled - is the flag to enable the procedure, targetDistance - is the distance of the strong target in front of the sensor at the bore site (in meters), searchWindow - is the search window (in meters).</li>
</ul>
<p>The procedure is implemented by the function mmwDemo_rangeBiasRxChPhaseMeasure(). It is called in the processing chain after the range processing DPU. The input to the procedure is a radar cube. Please note that this procedure assumes static clutter removal and compression are both turned off, major motion detection is enabled, and the sensor is operating in 2Tx BPM-MIMO mode with all three receivers (3Rx) active. Additionally, it assumes that the symbols in the radar cube have not been BPM decoded in the range DPU, which is configured in 2Tx TDM-MIMO mode. The measurement procedure first calculates the range profile as the sum of the magnitude squares across all antennas on the range FFTs. Then it searches for the peak in the zone ùëã‚àíùê∑/2 ‚â§ ùëüùëéùëõùëîùëí ‚â§ ùëã+ùê∑/2 where ùê∑ = searchWindow and ùëã = targetDistance.</p>
<p>The procedure then estimates the peak position using the three point parabolic interpolation and the range bias as the difference between the peak position and the configured target distance X.</p>
<p>The Rx channel compensation coefficients are calculated according to following equations.</p>
<p>From the radar cube stored as a complex16 3D array ùëã[ùëê‚Ñéùëñùëüùëù][ùëéùëõùë°ùëíùëõùëõùëé][ùëüùëéùëõùëîùëí], the received symbols are extracted at the range index ùëñ<sub>ùëùùëíùëéùëò</sub> of the peak position corresponding to the target as  <style>div.image img[src="mmwave_eq1.png"]{width:30%}</style> </p><div class="image">
<img src="mmwave_eq1.png" alt=""/>
</div>
<p> The symbols are then BPM decoded as  <style>div.image img[src="mmwave_eq2.png"]{width:30%}</style> </p><div class="image">
<img src="mmwave_eq2.png" alt=""/>
</div>
<p> The coefficients are then calculated as  <style>div.image img[src="mmwave_eq3.png"]{width:15%}</style> </p><div class="image">
<img src="mmwave_eq3.png" alt=""/>
</div>
<p> where  <style>div.image img[src="mmwave_eq4.png"]{width:15%}</style> </p><div class="image">
<img src="mmwave_eq4.png" alt=""/>
</div>
<p> The coefficients are transmitted to the host within the TLV packet each frame. The SDK visualizer displays these coefficients in its command window.</p>
<p><b>Measurement Procedure Steps:</b></p>
<ul>
<li>Set a strong target like corner reflector at boresight at desired distance and measure precisely the distance from the sensor.</li>
<li>Create the CLI configuration file for the measurement procedure with<ul>
<li>the enabled flag to 1 in CLI command measureRangeBiasAndRxChanPhase,</li>
<li>all antennas enabled,</li>
<li>TDM MIMO mode selected,</li>
<li>major mode detection enabled.</li>
</ul>
</li>
<li>Run the target demo. The target sends TLV with the calculated coefficients.</li>
<li>Copy one snapshot of the coefficients to clipboard.</li>
<li>Paste the copied line into the final CLI configuration file.</li>
</ul>
<h1><a class="anchor" id="autotoc_md864"></a>
System execution flow</h1>
<h1><a class="anchor" id="autotoc_md865"></a>
Task Model</h1>
<p>This demo is implemented on xWRL1432 using multiple tasks running in the system. Table below list all tasks used in the system.</p>
<p> <style>div.image img[src="mmwave_tasks.png"]{width:60%}</style> </p><div class="image">
<img src="mmwave_tasks.png" alt=""/>
<div class="caption">
Demo tasks</div></div>
<h2><a class="anchor" id="autotoc_md866"></a>
Main Task</h2>
<p>This is free RTOS main task initially called by the main function. It is active only during the start time, and after the creation of the CLI task it rests in pending state.</p>
<h2><a class="anchor" id="autotoc_md867"></a>
CLI Task</h2>
<p>The CLI task provides the execution context for the command line interface. It includes simple command parser.</p>
<h2><a class="anchor" id="autotoc_md868"></a>
DPC Task</h2>
<p>The DPC task provides the execution context for the detection processing chain.</p>
<h2><a class="anchor" id="autotoc_md869"></a>
UART Task</h2>
<p>This task controls the transfer of radar detection data to the host. The task transmits one packet of data per radar frame using a TLV format structure. Depending on the CLI configuration command guiMonitor the task sends point cloud, range profile, detection matrix, etc.</p>
<h2><a class="anchor" id="autotoc_md870"></a>
ADC read data Task</h2>
<p>This task is used for running the unit tests for the demo. The task reads reference ADC data samples from the file and feeds the signal processing chain instead of real ADC data coming from the RF</p>
<h2><a class="anchor" id="autotoc_md871"></a>
Power Management Task</h2>
<p>This task is engaged when the demo is running in the power saving deep sleep mode.</p>
<h2><a class="anchor" id="autotoc_md872"></a>
Timing Diagram</h2>
<p>The timing diagram during the startup and the first two frames is illustrated in Figure below.</p>
<p> <style>div.image img[src="mmwave_timing_lp_disabled.png"]{width:80%}</style> </p><div class="image">
<img src="mmwave_timing_lp_disabled.png" alt=""/>
<div class="caption">
Timing diagram ‚Äì low power mode disabled.</div></div>
<p>The timing diagram in the low power mode is shown below.</p>
<p> <style>div.image img[src="mmwave_lp_enabled.png"]{width:80%}</style> </p><div class="image">
<img src="mmwave_lp_enabled.png" alt=""/>
<div class="caption">
Timing diagram ‚Äì low power mode enabled.</div></div>
<h1><a class="anchor" id="autotoc_md873"></a>
Memory Usage</h1>
<p>The millimeter wave demo memory usage can always be found in the MAP file. The current usage is shown in Table below.</p>
<p> <style>div.image img[src="mmwave_memory_usage.png"]{width:15%}</style> </p><div class="image">
<img src="mmwave_memory_usage.png" alt=""/>
<div class="caption">
The memory usage</div></div>
<p>Some of the data arrays are dynamically handled using a set of simple memory allocation utility functions, provided below.</p>
<p> <style>div.image img[src="mmwave_memory_functions.png"]{width:50%}</style> </p><div class="image">
<img src="mmwave_memory_functions.png" alt=""/>
<div class="caption">
Memory allocation functions</div></div>
<p>Two memory heaps are created, one in the local core memory, gMmwCoreLocMem[28*1024], and the other, gMmwL3[416K], occupying 256KB shared memory of APPSS and 160KB shared memory of HWASS. Currently less than one 3kB of memory is allocated in the local core RAM. The usage of the shared memory depends on the configuration. At the start time, after the CLI commands has been received and configuration completed, memory usage of these two heaps is printed out on the console. The memory usage for the CLI configuration file parking_9m.cfg which is provided in this SDK release is shown in Table below.</p>
<p> <style>div.image img[src="mmwave_parking_9m.png"]{width:50%}</style> </p><div class="image">
<img src="mmwave_parking_9m.png" alt=""/>
<div class="caption">
Memory usage for the CLI configuration file parking_9m.cfg</div></div>
<h1><a class="anchor" id="autotoc_md874"></a>
Benchmarks</h1>
<p>Currently the CPU time and the UART transmit time is reported to Host within the stats TLV. The explanation of these time intervals is shown in the timing diagram above.</p>
<h1><a class="anchor" id="autotoc_md875"></a>
Configuration (.cfg) File Format (CLI INTERFACE)</h1>
<dl class="section attention"><dt>Attention</dt><dd><b>Converting configuration from older SDK release to current SDK release:</b><br  />
 As new versions of SDK releases are available, there are usually changes to the configuration commands that are supported in the new release. Now, users may have some hand crafted config file which worked perfectly well on older SDK release version but will not work as is with the new SDK release. Check users guide for details.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Example configuration files are available at '${SDK_INSTALL_PATH}/examples/mmw_demo/mmwave_demo/profiles/{board}' and '${SDK_INSTALL_PATH}/examples/mmw_demo/mmwave_demo/profiles/{board}'. All the CLI commands should be between 'sensorStop' and 'sensorStart'</dd></dl>
<p>Each line in the .cfg file describes a command with parameters. The various commands and their arguments are described in the table below (arguments are in sequence)</p>
<h2><a class="anchor" id="autotoc_md876"></a>
Sensor front-end parameters</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Commands  </th><th class="markdownTableHeadNone">Parameters  </th><th class="markdownTableHeadNone">Notes   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>sensorStop</b>  </td><td class="markdownTableBodyNone"><code>FrameStopMode</code>  </td><td class="markdownTableBodyNone">Indicates the frame stop mode. This command stops the sensor from transmitting further frames. <br  />
Important Note: This command is not supported when lowPowerCfg is 1 <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="3"><b>channelCfg</b>  </td><td class="markdownTableBodyNone"><code>RxChCtrlBitMask</code>  </td><td class="markdownTableBodyNone">RX antennas 1 and 2, mask = 0x011b = 3 <br  />
RX antennas 1 and 3, mask = 0x101b = 5 <br  />
RX antennas 2 and 3, mask = 0x110b = 6 <br  />
RX antennas 1, 2 &amp; 3, mask = 0x111b = 7<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>TxChCtrlBitMask</code>  </td><td class="markdownTableBodyNone">TX antennas 1 and 2, mask = 0x011b = 3<br  />
TX antenna 1, mask = 0x001b = 1 <br  />
TX antenna 2, mask = 0x010b = 2<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MiscCtrl</code>  </td><td class="markdownTableBodyNone">Not supported on the current version of the SDK.<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="7"><b>chirpComnCfg</b>  </td><td class="markdownTableBodyNone"><code>DigOutputSampRate</code>  </td><td class="markdownTableBodyNone">Digital output Sampling rate for chirp ADC samples. Digital sampling rate is given by 100MHz/ DigOutputSampRate. The valid sampling rate can be configured as per below.<br  />
 8 - 12.5 MHz <br  />
 9 - 11.11 MHz <br  />
 10 - 10 MHz <br  />
 12 - 8.333 MHz <br  />
 16 - 6.25 MHz <br  />
 20 - 5 MHz <br  />
 25 - 4 MHz <br  />
 32 - 3.125 MHz <br  />
 40 - 2.5 MHz <br  />
 50 - 2 MHz <br  />
 64 - 1.5625 MHz <br  />
 80 - 1.25 MHz <br  />
 100 - 1 MHz   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>DigOutputBitsSel</code>  </td><td class="markdownTableBodyNone">Digital output sample bits select, this field governs which bits of the FECSS DFE's internal 16 bit signed data path are sent as output.<br  />
 0 - Digital sample output is 12 MSB bits of DFE after rounding 4 LSBs <br  />
 1 - Digital sample output is 12 bits after rounding 3 LSBs &amp; clipping 1 MSB <br  />
 2 - Digital sample output is 12 bits after rounding 2 LSBs &amp; clipping 2 MSB <br  />
 3 - Digital sample output is 12 bits after rounding 1 LSBs &amp; clipping 3 MSB <br  />
 4 - Digital sample output is 12 LSB bits after clipping 4 MSB <br  />
 5 - Digital sample output is 16 bits   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>DfeFirSel</code>  </td><td class="markdownTableBodyNone">The final stage FIR filter's characteristics can be selected as below. <br  />
 0 - Long Filter (90% visibility): This provides visibility to a larger range of IF frequencies: 0 to 0.45 x Sampling Rate. Beyond that, the filter response starts drooping &amp; enters filter transition band. <br  />
 1 - Short Filter (80% visibility): This provides faster settled outputs but the IF frequency range visible is 0 to 0.40 x Sampling Rate. Beyond that, the filter response starts drooping &amp; enters filter transition band.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>NumOfAdcSamples</code>  </td><td class="markdownTableBodyNone">No. of ADC samples.<br  />
<b>Valid Range</b>: 2 to 1024.<br  />
 <b>Note</b> SDK-OOB Demo allows a maximum of 1024 h_NumOfAdcSamples because HWA 1.2 can only process FFTs up to 1024 points. However, the front-end is capable of supporting up to 2048 h_NumOfAdcSamples.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ChirpTxMimoPatSel</code>  </td><td class="markdownTableBodyNone"><b>Note</b> Only the BPM_2TX pattern is supported in this demo. <br  />
 0 - TX BPM MIMO pattern disabled <br  />
 1 - TDMA_2TX pattern <br  />
 4 - BPM_2TX pattern   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ChirpRampEndTime</code>  </td><td class="markdownTableBodyNone">Chirp Profile Ramp end Time. This is a common ramp end time value for all chirps in a frame.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ChirpRxHpfSel</code>  </td><td class="markdownTableBodyNone">Chirp Profile HPF corner frequency. This is a common HPF corner frequency value for all chirps in a frame. <br  />
 0 - 175kHz HPF corner frequency<br  />
 1 - 350kHz HPF corner frequency<br  />
 2 - 700kHz HPF corner frequency<br  />
 3 - 1400kHz HPF corner frequency   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="5"><b>chirpTimingCfg</b>  </td><td class="markdownTableBodyNone"><code>ChirpIdleTime</code>  </td><td class="markdownTableBodyNone">Chirp Profile Idle Time. This is a common idle time value for all chirps in a frame. <br  />
<b>Unit</b>: 1us.<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ChirpAdcSkipSamples</code>  </td><td class="markdownTableBodyNone">Chirp Profile ADC start skip samples. This is a common adc start time value for all chirps in a frame <br  />
 <b>Valid range</b>: 0 to 63   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ChirpTxStartTime</code>  </td><td class="markdownTableBodyNone">Chirp Profile TX start Time. This is a common TX start time value for all chirps in a frame.This field indicates the TX start time in the chirp cycle with respect to the knee of the ramp. <br  />
 <b>Unit</b>: In usec   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ChirpRfFreqSlope</code>  </td><td class="markdownTableBodyNone">Chirp Profile RF Frequency Slope. This is a common RF frequency slope value for all chirps in a frame.This field indicates the required FMCW slope of the chirp. <br  />
 <b>Unit</b>: MHz/us <br  />
<b>Valid range</b>:- 399MHz/us to +399MHz/us.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ChirpRfFreqStart</code>  </td><td class="markdownTableBodyNone">Chirp Profile RF start Frequency. This is a common RF start frequency value for all chirps in a frame. This field indicates the required start frequency of the chirp.<br  />
 <b>Unit</b>: GHz <br  />
<b>Valid range</b>:58GHz to 62.5GHz for ES1.0 devices   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="6"><b>frameCfg</b>  </td><td class="markdownTableBodyNone"><code>NumOfChirpsInBurst</code>  </td><td class="markdownTableBodyNone">Number of Chirps in a Burst. This field indicates the number of chirps to be generated per burst.<br  />
 <b>Valid range</b>: 1 to 65535 chirps .<br  />
 (<em>Limited support in current OOB</em>)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>NumOfChirpsAccum</code>  </td><td class="markdownTableBodyNone">Number of accumulation per chirp. This field indicates the Number of chirps to be accumulated before sending the ADC data out in DFE, this can be used to increase the SNR without increasing the number of chirps to process in the DSP/HW accelerator. <br  />
 <b>Valid range</b>: : 0 to 64 chirps.<br  />
 (<em>Limited support in current OOB</em>)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>BurstPeriodicity</code>  </td><td class="markdownTableBodyNone">Burst periodicity in Œºs. This field indicates the period of the burst.<br  />
 (<em>Limited support in current OOB</em>)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>NumOfBurstsInFrame</code>  </td><td class="markdownTableBodyNone"><b>Note</b> Only one burst per frame is supported in this demo. <br  />
 Number of bursts per frame. <br  />
 <b>Valid range</b>:1 to 4096 <br  />
<b>Note</b> Only a power-of-two number of chirps(NumOfBurstsInFrame * NumOfChirpsInBurst) per frame is supported. <br  />
 (<em>Limited support in current OOB</em>)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>FramePeriodicity</code>  </td><td class="markdownTableBodyNone">Frame Periodicity. This field indicates the period of the frame, 32bit counter.This field indicates the frame periodicity, the time gap between successive frame starts. <br  />
 <b>Unit</b>: ms <br  />
<b>Valid range</b>:100 to 4294967295 (<em>Limited support in current OOB</em>)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>NumOfFrames</code>  </td><td class="markdownTableBodyNone">Number of frames. <br  />
 <b>Valid range</b>: 0 to 65535, 0 means infinite<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="5"><b>adcLogging</b>  </td><td class="markdownTableBodyNone"><code>enable</code>  </td><td class="markdownTableBodyNone">ADC data logging enable: <br  />
 0 - Disable. <br  />
 1: Enable via DCA. <br  />
 2: Enable via SPI. <br  />
 NOTE: When ADC logging via DCA is enabled number of adc samples must be a multiple of 4. And the configs listed below are not applicable when SPI logging is used. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>sideBandEnable</code>  </td><td class="markdownTableBodyNone">Sideband data logging:(optional argument) <br  />
 0: Disable. <br  />
 1: Enable. <br  />
 NOTE: FrameLivMonEn in sensorstart must be set to a value 2(RX_SATURATION_LIVE_MON must be enabled) for sideband data logging. And by default sideband data is disabled. <br  />
 (Refer to the ICD for more details about this feature) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>swizzlingMode</code>  </td><td class="markdownTableBodyNone">RDIF Data Swizzling Mode enable control:(optional argument) <br  />
 0: Pin0-bit0-Cycle1 Mode. <br  />
 1: Pin3-bit0-Cycle1 Mode. <br  />
 2: Pin0-bit0-Cycle3 Mode. <br  />
 3: Pin3-bit0-Cycle3 Mode. <br  />
 (Refer to the ICD for more details about this feature) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>scramblerMode</code>  </td><td class="markdownTableBodyNone">RDIF Scrambler Mode enable control:(optional argument) <br  />
 0: Disable. <br  />
 1: Enable. <br  />
 (Refer to the ICD for more details about this feature) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>laneRate</code>  </td><td class="markdownTableBodyNone">Enable RDIF lane rate update:(optional argument) <br  />
 0: Combined Lane Rate of 400Mbps. <br  />
 1: Combined Lane Rate of 320Mbps. <br  />
 2: Combined Lane Rate of 200Mbps. <br  />
 3: Combined Lane Rate of 160Mbps. <br  />
 4: Combined Lane Rate of 100Mbps. <br  />
 (Refer to the ICD for more details about this feature) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>lowPowerCfg</b>  </td><td class="markdownTableBodyNone"><code>Enable/Disable</code>  </td><td class="markdownTableBodyNone">Configuration to enable/disable the power management framework.<br  />
 0 - Disabled <br  />
 1 - Enabled <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="5"><b>factoryCalibcfg</b>  </td><td class="markdownTableBodyNone"><code>Save enable</code>  </td><td class="markdownTableBodyNone">When this option is enabled application will boot-up normally and configure the FECSS to perform all applicable factory calibrations during FECSS initialization. Once the calibrations are performed, application will retrieve the calibration data from FECSS and save it to FLASH. User need to specify valid &lt;flash offset&gt; value. &lt;restore enable&gt; option should be set to 0. <br  />
<b>Note</b> The factory calibration should be done at room temp (25 &deg;C +/- 15 &deg;C)<br  />
 0 - Save Disabled <br  />
 1 - Save Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>restore enable</code>  </td><td class="markdownTableBodyNone">When Restore enabled option is set, application will check the FLASH for a valid calibration data section. If present, it will restore the data from FLASH and provide it to FECSS while configuring it to skip any real-time factory calibrations and use provided calibration data. User need to specify valid &lt;flash offset&gt; value which was used during saving of calibration data. &lt;save enable&gt; option should be set to 0. &lt;rxGain&gt; and &lt;backoff0&gt; arguments will be ignored when restore option is enabled. <br  />
 0 - Restored Disabled <br  />
 1 - Restore Enabled   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>rxGain</code>  </td><td class="markdownTableBodyNone">Recommended value is 30db to 40db.<br  />
 <b>Units</b>: db.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>backoff0</code>  </td><td class="markdownTableBodyNone">TX channel power calibration. Valid Range: 0db to 26db.<br  />
 <b>Units</b>: db.<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>flash offset</code>  </td><td class="markdownTableBodyNone">Address offset in the flash to be used while saving or restoring calibration data. Make sure the address doesn't overlap the location in FLASH where application images are stored and has enough space for saving factory Calibration data. This field is don't care if both save and restore are disabled.Flash address range is 0x0 to 0x1FFFFF (16Mb) Actual Factory calibration data is of size 128 bytes. It is recommended to use last sector of flash memory starting with address 0x1FF000. <br  />
<b>Note</b> The flash offset should be greater than 1MB (0x100000h) for EVM. This check is only to make sure Appimage and ATE calibration data is not corrupted.<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>baudRate</b>  </td><td class="markdownTableBodyNone"><code>baudRateVal</code>  </td><td class="markdownTableBodyNone">The sensor starts with 115200 baud rate by default. When this command is sent to the device, the baud rate for the UART communication is updated according to the given value. Currently only <code>baudRateVal</code>=1250000 is supported <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="4"><b>sensorStart</b>  </td><td class="markdownTableBodyNone">'FrameTrigMode'  </td><td class="markdownTableBodyNone">Frame Trigger Mode. <br  />
 0 - Frame SW immediate trigger Mode (SW_TRIG). <br  />
 1 - Frame SW timer based trigger Mode (SW_TIMER_TRIG). <br  />
 2 - Frame HW trigger low power Mode (HW_LOW_PWR_TRIG). <br  />
 3 - Frame HW trigger low jitter Mode (HW_LOW_JIT_TRIG). <br  />
 4 - CW CZ Trigger Mode (CW_CZ_TRIG). <br  />
 5 - Chirp Timer Override Trigger Mode (CT_OVRD_TRIG).<br  />
 (<em>Currently SDK supports only SW_TRIG mode(0)</em>) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">'ChirpStartSigLbE'  </td><td class="markdownTableBodyNone">Chirp Timer (CT) start signal loopback enable control.<br  />
 0 - CHIRP_START_SIGNAL to DIG_SYNC_OUT Loopback Disable <br  />
 1 - CHIRP_START_SIGNAL to DIG_SYNC_OUT Loopback Enable. <br  />
 (<em>Currently SDK supports only Loopback Disable mode(0)</em>) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">'FrameLivMonEn'  </td><td class="markdownTableBodyNone">Frame Live monitors enable control. <br  />
 0 - Live monitor Disabled <br  />
 1 - Synth Frequency Monitor Enabled <br  />
2 - Rx Saturation Live Monitor Enabled <br  />
 3 - Both Synth Frequency Monitor and Rx Saturation Live Monitor Enabled <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">'FrameTrigTimerVal'  </td><td class="markdownTableBodyNone">Frame Trigger Timer Value. 32bit counter value. <br  />
 (<em>Currently SDK demo is tested only with value 0</em>)<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>sensorWarmRst</b>  </td><td class="markdownTableBodyNone"><code>Reserved for future</code>  </td><td class="markdownTableBodyNone">This command initiates a warm reset of sensor with application getting reloaded from flash after reset. <br  />
Important Note: This command is not supported when lowPowerCfg is 1<br  />
   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md877"></a>
Detection layer parameters</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Commands  </th><th class="markdownTableHeadNone">Parameters  </th><th class="markdownTableHeadNone">Notes   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="8"><b>sigProcChainCfg</b>  </td><td class="markdownTableBodyNone"><code>azimuthFftSize</code>  </td><td class="markdownTableBodyNone">Azimuth FFT size. Suggested to set as power of 2<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>elevationFftSize</code>  </td><td class="markdownTableBodyNone">Elevation FFT size. Suggested to set as power of 2<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>motDetMode</code>  </td><td class="markdownTableBodyNone">The flag must be set to 1.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>coherentDoppler</code>  </td><td class="markdownTableBodyNone">This flag is ignored.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>numFrmPerMinorMotProc</code>  </td><td class="markdownTableBodyNone">This flag is ignored.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>numMinorMotionChirpsPerFrame</code>  </td><td class="markdownTableBodyNone">This flag is ignored.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>forceMinorMotionVelocityToZero</code>  </td><td class="markdownTableBodyNone">This flag is ignored.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>minorMotionVelocityInclusionThr</code>  </td><td class="markdownTableBodyNone">This flag is ignored.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="12"><b>cfarCfg</b>  </td><td class="markdownTableBodyNone"><code>averageMode</code>  </td><td class="markdownTableBodyNone">CFAR Averaging mode selection Recommened to set 2 <br  />
 0 - CFAR-CA <br  />
 1 - CFAR-CAGO <br  />
 2 - CFAR-CASO   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>winLen</code>  </td><td class="markdownTableBodyNone">One-sided noise averaging window length (in samples) of range-CFAR Recommened to set as power of 2<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>guardLen</code>  </td><td class="markdownTableBodyNone">One-sided guard length (in samples) of range-CFAR. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>noiseDiv</code>  </td><td class="markdownTableBodyNone">Cumulative noise sum divisor expressed as a shift. Sum of noise samples is divided by 2^noiseDiv. Suggested to set as log2(winLen).<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>cyclicMode</code>  </td><td class="markdownTableBodyNone">Cyclic mode or wrapped around mode. <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>thresholdScale</code>  </td><td class="markdownTableBodyNone">Threshold factor of range-CFAR in dB scale (20log10). <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>peakGroupingEn</code>  </td><td class="markdownTableBodyNone">Enable or disable Peakgrouping <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>sideLobeThreshold</code>  </td><td class="markdownTableBodyNone"><b>Note:</b> This flag is used by AoA2D DPU. <br  />
 Sidelobe threshold (in linear scale) in azimuth domain to declare a local peak as a valid detection. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>localMaxRangeDomain</code>  </td><td class="markdownTableBodyNone">Enable/disable selection of the local maximum in the range domain <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>localMaxDopplerDomain</code>  </td><td class="markdownTableBodyNone">Enable/disable selection of the local maximum in the Doppler domain <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>interpolateRange</code>  </td><td class="markdownTableBodyNone">Enable /disable the interpolation of the range <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>interpolateDopplerDomain</code>  </td><td class="markdownTableBodyNone">Enable /disable the interpolation of the Doppler <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="8"><b>cfarScndPassCfg</b>  </td><td class="markdownTableBodyNone"><code>enabled</code>  </td><td class="markdownTableBodyNone">Second pass CFAR enabled flag: <br  />
 0 - Disabled <br  />
 1 - Enabled <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>averageMode</code>  </td><td class="markdownTableBodyNone">CFAR Averaging mode selection Recommened to set 2 <br  />
 0 - CFAR-CA <br  />
 1 - CFAR-CAGO <br  />
 2 - CFAR-CASO   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>winLen</code>  </td><td class="markdownTableBodyNone">One-sided noise averaging window length (in samples) of range-CFAR Recommened to set as power of 2<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>guardLen</code>  </td><td class="markdownTableBodyNone">One-sided guard length (in samples) of range-CFAR. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>noiseDiv</code>  </td><td class="markdownTableBodyNone">Cumulative noise sum divisor expressed as a shift. Sum of noise samples is divided by 2^noiseDiv. Suggested to set as log2(winLen).<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>cyclicMode</code>  </td><td class="markdownTableBodyNone">Cyclic mode or wrapped around mode. <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>thresholdScale</code>  </td><td class="markdownTableBodyNone">Threshold factor of range-CFAR in dB scale (20log10). <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>peakGroupingEn</code>  </td><td class="markdownTableBodyNone">Enable or disable Peakgrouping <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="4"><b>aoaFovCfg</b>  </td><td class="markdownTableBodyNone"><code>minAzimuthDeg</code>  </td><td class="markdownTableBodyNone">Minimum azimuth angle (in degrees) that specifies the start of field of view <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>maxAzimuthDeg</code>  </td><td class="markdownTableBodyNone">Maximum azimuth angle (in degrees) that specifies the end of field of view <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>minElevationDeg</code>  </td><td class="markdownTableBodyNone">Minimum elevation angle (in degrees) that specifies the start of field of view <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>maxElevationDeg</code>  </td><td class="markdownTableBodyNone">Maximum elevation angle (in degrees) that specifies the end of field of view <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="2"><b>rangeSelCfg</b>  </td><td class="markdownTableBodyNone"><code>minMeters</code>  </td><td class="markdownTableBodyNone">Minimum range of exported detected points <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>maxMeters</code>  </td><td class="markdownTableBodyNone">Maximum range of exported detected points<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>clutterRemoval</b>  </td><td class="markdownTableBodyNone"><code>enabled</code>  </td><td class="markdownTableBodyNone"><b>Note:</b> Clutter removal is not supported. The flag must be set to 0.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="7"><b>compRangeBiasAndRxChanPhase</b>  </td><td class="markdownTableBodyNone"><code>rangeBias</code>  </td><td class="markdownTableBodyNone">Value of the Range Bias (m).<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>virtAntIdx 1</code>  </td><td class="markdownTableBodyNone">Phase compensation factor (real, imaginary) of virtual antenna 1. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>virtAntIdx 2</code>  </td><td class="markdownTableBodyNone">Phase compensation factor (real, imaginary) of virtual antenna 2. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>virtAntIdx 3</code>  </td><td class="markdownTableBodyNone">Phase compensation factor (real, imaginary) of virtual antenna 3. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>virtAntIdx 4</code>  </td><td class="markdownTableBodyNone">Phase compensation factor (real, imaginary) of virtual antenna 4. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>virtAntIdx 5</code>  </td><td class="markdownTableBodyNone">Phase compensation factor (real, imaginary) of virtual antenna 5. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>virtAntIdx 6</code>  </td><td class="markdownTableBodyNone">Phase compensation factor (real, imaginary) of virtual antenna 6. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="3"><b>measureRangeBiasAndRxChanPhase</b>  </td><td class="markdownTableBodyNone"><code>enabled</code>  </td><td class="markdownTableBodyNone">Enable measurement of the range bias and rx channel gain and phase imperfections <br  />
 0 - Disabled <br  />
 1 - Enabled <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>targetDistance</code>  </td><td class="markdownTableBodyNone">Distance in meters where strong reflector is located to be used as test object for measurement. This field is only used when measurement mode is enabled. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>searchWin</code>  </td><td class="markdownTableBodyNone">Distance in meters of the search window around <code>targetDistance</code> where the peak will be searched <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="11"><b>guiMonitor</b>  </td><td class="markdownTableBodyNone"><code>pointCloud</code>  </td><td class="markdownTableBodyNone">Enable/Disable the transmission of the point cloud data <br  />
 0 - Disable <br  />
 1 - Enable, point cloud in floating point format, plus side information, <br  />
 2 - Enable, point cloud in compressed format (fixed point)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>rangeProfile</code>  </td><td class="markdownTableBodyNone">Enable/Disable the transmission of the Range Profile data. <br  />
 0 - Disable <br  />
 1 - Enable   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>NoiseProfile</code>  </td><td class="markdownTableBodyNone">Not supported, must be set to 0 <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>rangeAzimuthHeatMap</code>  </td><td class="markdownTableBodyNone">Not supported, must be set to 0 <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>rangeDopplerHeatMap</code>  </td><td class="markdownTableBodyNone">Enable/Disable transmission of the Range Doppler heatmap <br  />
 0 - Disable <br  />
 1 - Enable <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>statsInfo</code>  </td><td class="markdownTableBodyNone">Enable/Disable the transmission of the Statistics info that include processing time, temperature, power. (<em>Partially supported in the current SDK</em>) <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>presenceInfo</code>  </td><td class="markdownTableBodyNone">Not supported, must be set to 0 <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>adcSamples</code>  </td><td class="markdownTableBodyNone">Enable/Disable the transmission of the raw ADC samples of the last two chirps of the frame <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>trackerInfo</code>  </td><td class="markdownTableBodyNone">Not supported, must be set to 0 <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>microDopplerInfo</code>  </td><td class="markdownTableBodyNone">Not supported, must be set to 0 <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>classifierInfo</code>  </td><td class="markdownTableBodyNone">Not supported, must be set to 0 <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="14"><b>antGeometryCfg</b>  </td><td class="markdownTableBodyNone"><code>vAnt1_row</code>  </td><td class="markdownTableBodyNone">row index of virtual antenna 1. (TxAnt1-&gt;RxAnt1) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vAnt1_col</code>  </td><td class="markdownTableBodyNone">column index of virtual antenna 1. (TxAnt1-&gt;RxAnt1) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vAnt2_row</code>  </td><td class="markdownTableBodyNone">row index of virtual antenna 2. (TxAnt1-&gt;RxAnt2) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vAnt2_col</code>  </td><td class="markdownTableBodyNone">column index of virtual antenna 2. (TxAnt1-&gt;RxAnt2) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vAnt3_row</code>  </td><td class="markdownTableBodyNone">row index of virtual antenna 3. (TxAnt1-&gt;RxAnt3) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vAnt3_col</code>  </td><td class="markdownTableBodyNone">column index of virtual antenna 3. (TxAnt1-&gt;RxAnt3) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vAnt4_row</code>  </td><td class="markdownTableBodyNone">row index of virtual antenna 4. (TxAnt2-&gt;RxAnt1) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vAnt4_col</code>  </td><td class="markdownTableBodyNone">column index of virtual antenna 4. (TxAnt2-&gt;RxAnt1) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vAnt5_row</code>  </td><td class="markdownTableBodyNone">row index of virtual antenna 5. (TxAnt2-&gt;RxAnt2) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vAnt5_col</code>  </td><td class="markdownTableBodyNone">column index of virtual antenna 5. (TxAnt2-&gt;RxAnt2) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vAnt6_row</code>  </td><td class="markdownTableBodyNone">row index of virtual antenna 6. (TxAnt2-&gt;RxAnt3) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vAnt6_col</code>  </td><td class="markdownTableBodyNone">column index of virtual antenna 6. (TxAnt2-&gt;RxAnt3) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>antDistX</code>  </td><td class="markdownTableBodyNone">Antenna spacing in X dimension in mm. This is optional argument. If omitted, it is assumed that &lambda;/d<sub>x</sub>=2 <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>antDistZ</code>  </td><td class="markdownTableBodyNone">Antenna spacing in Z dimension in mm. This is optional argument. If omitted, it is assumed that &lambda;/d<sub>z</sub>=2 <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="2"><b>compressionCfg</b>  </td><td class="markdownTableBodyNone"><code>enabled</code>  </td><td class="markdownTableBodyNone">Data compression enable/disable flag: <br  />
 0 - Disabled <br  />
 1 - Enabled <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>compressionRatio</code>  </td><td class="markdownTableBodyNone">Compression ratio (CR). Supported only CR=0.5 and CR=0.25<br  />
   </td></tr>
</table>
<p>Refer <b>${SDK_INSTALL_PATH}/docs/Motion_Presence_Detection_Demo_Tuning_Guide.pdf</b> document for Parameter tuning and customization of Demo application.</p>
<h1><a class="anchor" id="autotoc_md878"></a>
UART and Output to the Host</h1>
<h2><a class="anchor" id="autotoc_md879"></a>
Output TLV Description</h2>
<p>The packet structure consists of fixed sized frame header, followed by variable number of TLVs (see Figure below). Each TLV has fixed header followed by variable size payload. The Byte order is Little Endian.</p>
<p> <style>div.image img[src="mmwave_tlv.png"]{width:80%}</style> </p><div class="image">
<img src="mmwave_tlv.png" alt=""/>
<div class="caption">
Data packet structure sent to Host.</div></div>
<h3><a class="anchor" id="autotoc_md880"></a>
Frame Header Structure</h3>
<p>The frame header is of fixed size (40bytes). It is defined by the structure as</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>MmwDemo_output_message_header_t</div>
<div class="line">{</div>
<div class="line">uint16_t magicWord[4]; <span class="comment">/* Sync word: {0x0102,0x0304,0x0506,0x0708} */</span></div>
<div class="line">uint32_t version; <span class="comment">/* MajorNum*2^24+MinorNum*2^16+BugfixNum*2^8+BuildNum */</span></div>
<div class="line">uint32_t totalPacketLen; <span class="comment">/* Total packet length including header in Bytes */</span></div>
<div class="line">uint32_t platform; <span class="comment">/* platform type */</span></div>
<div class="line">uint32_t frameNumber; <span class="comment">/* Frame number */</span></div>
<div class="line">uint32_t timeCpuCycles; <span class="comment">/* Time in CPU cycles when the message was created */</span></div>
<div class="line">uint32_t numDetectedObj; <span class="comment">/* Number of detected objects */</span></div>
<div class="line">uint32_t numTLVs; <span class="comment">/* Number of TLVs */</span></div>
<div class="line">uint32_t subFrameNumber; <span class="comment">/* Subframe number */</span></div>
<div class="line">} MmwDemo_output_message_header;</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md881"></a>
TLV Structure</h3>
<p>The TLV structure consists of a fixed header, TL (8bytes) followed by TLV specific payload. The TLV header structure is shown below.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>MmwDemo_output_message_tl_t</div>
<div class="line">{</div>
<div class="line">uint32_t type; <span class="comment">/* TLV type */</span></div>
<div class="line">uint32_t length; <span class="comment">/* Length in bytes */</span></div>
<div class="line">} MmwDemo_output_message_tl;</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md882"></a>
Point Cloud TLV</h3>
<p>The demo outputs point cloud data in one of the two formats, floating point format and more compressed fixed point format. The format option is selected from the CLI configuration.</p>
<h4><a class="anchor" id="autotoc_md883"></a>
Floating point format</h4>
<p>The point cloud data are sent using two TLV elements, first one with the detected point cartesian coordinates and the radial velocity, and the second one, this side information, the detected point snr and noise.</p>
<p><a class="anchor" id="autotoc_md884"></a></p><h5>Point Cloud ‚Äì Coordinates TLV</h5>
<ul>
<li>Type = MMWDEMO_OUTPUT_MSG_DETECTED_POINTS</li>
<li>Length = sizeof(DPIF_PointCloudCartesian) * numberOfPoints</li>
</ul>
<p>The single point is defined as:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>DPIF_PointCloudCartesian_t</div>
<div class="line">{</div>
<div class="line"><span class="keywordtype">float</span> x; <span class="comment">/* x - coordinate in meters. */</span></div>
<div class="line"><span class="keywordtype">float</span> y; <span class="comment">/* y - coordinate in meters. */</span></div>
<div class="line"><span class="keywordtype">float</span> z; <span class="comment">/* z - coordinate in meters. */</span></div>
<div class="line"><span class="keywordtype">float</span> velocity; <span class="comment">/* radial velocity away from sensor in m/s */</span></div>
<div class="line">} DPIF_PointCloudCartesian;</div>
</div><!-- fragment --><p> <a class="anchor" id="autotoc_md885"></a></p><h5>Point Cloud - Side information TLV</h5>
<ul>
<li>Type = MMWDEMO_OUTPUT_MSG_DETECTED_POINTS_SIDE_INFO</li>
<li>Length = sizeof(DPIF_PointCloudSideInfo) * numberOfPoints</li>
</ul>
<p>The single point side info is defined as:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>DPIF_PointCloudSideInfo_t</div>
<div class="line">{</div>
<div class="line">int16_t snr; <span class="comment">/* snr - CFAR cell to side noise ratio in dB, 1LSB = 0.1dB */</span></div>
<div class="line">int16_t noise; <span class="comment">/* noise level of side of detected cell in dB, 1LSB = 0.1dB */</span></div>
<div class="line">} DPIF_PointCloudSideInfo;</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md886"></a>
Fix-point format</h4>
<ul>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_DETECTED_POINTS</li>
<li>Length = sizeof (MmwDemo_output_message_point_uint) + sizeof (MmwDemo_output_message_UARTpoint) * numberOfPoints</li>
</ul>
<p>The unit structure is defined as:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>MmwDemo_output_message_point_uint_t</div>
<div class="line">{</div>
<div class="line"><span class="keywordtype">float</span> xyzUnit; <span class="comment">/* x/y/z coordinates reporting unit, in m */</span></div>
<div class="line"><span class="keywordtype">float</span> dopplerUnit; <span class="comment">/* radial velocity reporting unit, in m/s */</span></div>
<div class="line"><span class="keywordtype">float</span> snrUint; <span class="comment">/* SNR reporting unit, in dB */</span></div>
<div class="line"><span class="keywordtype">float</span> noiseUint; <span class="comment">/* Noise reporting unit, in dB */</span></div>
<div class="line">uint16_t numDetectedPoints[2]; <span class="comment">/* number of detected points in [0]-major and [1]-minor motion mode */</span></div>
<div class="line">} MmwDemo_output_message_point_uint;</div>
</div><!-- fragment --><ul>
<li>Note that since this demo does not support minor mode, the number of detected points are stored in the field numDetectedPoints[0], while the field numDetectedPoints[1] is set to zero.</li>
</ul>
<p>The single point is defined as:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>MmwDemo_output_message_UARTpoint_t</div>
<div class="line">{</div>
<div class="line">int16_t x; <span class="comment">/* Detected point x, 1LSB = xyzUnit */</span></div>
<div class="line">int16_t y; <span class="comment">/* Detected point y, 1LSB = xyzUnit */</span></div>
<div class="line">int16_t z; <span class="comment">/* Detected point z, 1LSB = xyzUnit */</span></div>
<div class="line">int16_t doppler; <span class="comment">/* Detected point radial velocity, 1LSB = dopplerUnit */</span></div>
<div class="line">uint8_t snr; <span class="comment">/* Range detection SNR, 1LSB = snrUnit */</span></div>
<div class="line">uint8_t noise; <span class="comment">/* Detected point noise value 1LSB = noiseUnit */</span></div>
<div class="line">} MmwDemo_output_message_UARTpoint;</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md887"></a>
Range Profile TLV</h3>
<p>This demo sends the range profile using as the major mode TLV. This TLV contains the range profile, specified as an array of 32-bit unsigned linear values of range bins. The length is equal to number of range bin elements, (half of the range FFT size, since the ADC samples are real).</p>
<ul>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_RANGE_PROFILE_MAJOR</li>
<li>Length = sizeof(uint32_t) * numberOfRangeBins</li>
</ul>
<h3><a class="anchor" id="autotoc_md888"></a>
Range-Doppler Heatmap TLV</h3>
<p>This TLV contains the range-Doppler detection matrix (heatmap) which consists of two-dimensional array of 32-bit unsigned magnitude values. The matrix is arranged as X[rangeInd* numDopplerBins + dopplerInd], rangeInd = 0, numRangeBins - 1, dopplerInd = 0, numDopplerBins ‚Äì 1</p>
<ul>
<li>Type = MMWDEMO_OUTPUT_MSG_RANGE_DOPPLER_HEAT_MAP (equal to 5)</li>
<li>Length = sizeof(uint32_t) * numRangeBins * numDopplerBins</li>
</ul>
<h3><a class="anchor" id="autotoc_md889"></a>
Stats TLV</h3>
<p>This TLV contains statistics described in the structure below.</p>
<ul>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_STATS</li>
<li>Length = sizeof(MmwDemo_output_message_stats)</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>MmwDemo_output_message_stats_t</div>
<div class="line">{</div>
<div class="line">uint32_t interFrameProcessingTime; <span class="comment">/* Interframe processing time in usec */</span></div>
<div class="line">uint32_t transmitOutputTime; <span class="comment">/* Transmission data transmit time in usec */</span></div>
<div class="line">uint16_t powerMeasured[4]; <span class="comment">/* Power at 1.8V, 3.3V, 1.2V and 1.2V RF rails(1LSB = 100 uW) */</span></div>
<div class="line">int16_t tempReading[4]; <span class="comment">/* Temperature: Rx, Tx, PM, DIG. (oC), 1LSB = 1oC */</span></div>
<div class="line">} MmwDemo_output_message_stats;</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md890"></a>
Rx channel compensation measurement output TLV</h3>
<p>This TLV contains the output of Rx channel compensation measurement procedure.</p>
<ul>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_RX_CHAN_COMPENSATION_INFO</li>
<li>Length = sizeof(DPU_DoaProc_compRxChannelBiasFloatCfg)</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>DPU_DoaProc_compRxChannelBiasFloatCfg_t</div>
<div class="line">{</div>
<div class="line"><span class="keywordtype">float</span> rangeBias;</div>
<div class="line"><span class="keywordtype">float</span> rxChPhaseComp[2 * SYS_COMMON_NUM_TX_ANTENNAS * SYS_COMMON_NUM_RX_CHANNEL];</div>
<div class="line">} <a class="code" href="structDPU__DoaProc__compRxChannelBiasFloatCfg.html">DPU_DoaProc_compRxChannelBiasFloatCfg</a>;</div>
</div><!-- fragment --> <h1><a class="anchor" id="autotoc_md891"></a>
Low Power Configuration (lowPowerCfg = 1)</h1>
<h2><a class="anchor" id="autotoc_md892"></a>
Flow Diagram</h2>
<p>Below is the high level flow diagram of Motion and Presence detection OOB demo in Low Power Mode:  <style>div.image img[src="motiondet_demo_flow_lp.png"]{width:30%}</style> </p><div class="image">
<img src="motiondet_demo_flow_lp.png" alt=""/>
<div class="caption">
Flow in Low Power Mode</div></div>
<h2><a class="anchor" id="autotoc_md893"></a>
Threshold and Latency time duration for Power module</h2>
<p>Syscfg of Power driver provides some options to be configured by user as per their demo implementations:</p>
<p><b>Threshold Value</b> The idle time available only after which entry to various power modes is considered. This is upto the user to configure based on their system requirements.<br  />
 <b>Latency Value:</b> There is a latency for the device to transition into the different low power modes, and to wake from that specific low power mode to resume activity. The actual transition latency will depend upon overall device state, as well as execution of notification functions that are registered with the Power driver. User is expected to measure this in their implementations and configure this value. If there is Xms idle time, device will get into low power state for (X - Latency value) time duration.</p>
<p>Threshold and latency values can be changed (tuned) to meet specific application requirements. Threshold and Latency values for different power modes can be configured in Power Syscfg: <br  />
</p>
<p> <style>div.image img[src="lpds_values.png"]{width:45%}</style> </p><div class="image">
<img src="lpds_values.png" alt=""/>
<div class="caption">
THRESHOLD AND LATENCY VALUES OF DIFFERENT POWER MODES</div></div>
<p> <br  />
 <br  />
</p>
<p>Enabling wake-up sources from LPDS state: Wake-up from Deep sleep exit is provisioned in the device through a number of external wakeup sources like UART/SPI/GPIO/SYNC_IN/Sleep counter, etc. By Default wake-up using Sleep Counter is enabled in Demo.</p>
<p> <style>div.image img[src="wakeup_sources_lpds.png"]{width:45%}</style> </p><div class="image">
<img src="wakeup_sources_lpds.png" alt=""/>
<div class="caption">
LPDS WAKEUP SOURCES</div></div>
<p> <br  />
 <br  />
</p>
<h1><a class="anchor" id="autotoc_md894"></a>
Raw ADC data streaming</h1>
<h2><a class="anchor" id="autotoc_md895"></a>
Steps for DCA based streaming</h2>
<p>MMWAVE-L-SDK OOB (out-of-box) demo supports raw ADC data streaming through the RDIF interface. When the radar EVM board connected with the DCA1000EVM board, users can use the DCA1000EVM CLI application to capture the raw data without starting the mmWaveStudio GUI interface. The DCA1000EVM CLI application is primarily a command line tool for configuration of FPGA and recording based on the user inputs. The DCA1000EVM CLI application connects to DCA1000EVM system through 1GB Ethernet for configuration and recording of data. RADAR EVM is connected to DCA1000EVM for data capture and connected to PC for configuration of data generation. However, there are some important limitations associated with this feature:</p><ul>
<li>Do not use this feature when Low power mode is enabled (lowPowerCfg 1).</li>
</ul>
<p>The DCA1000EVM CLI application is provided for Windows and can be recompiled for other platforms. Users can find the source code and user guide in MMWAVE-STUDIO release package.</p>
<p>The DCA1000EVM CLI application has the following functionalities.</p><ul>
<li>CLI application parses the parameters in JSON formatted config file for the corresponding CLI Control commands.</li>
<li>CLI application supports both Windows and Linux.</li>
<li>Acknowledgement of commands and error codes are handled and returned by the CLI application.</li>
<li>The response status of each of the command is captured in a log file by the CLI application.</li>
<li>CLI application supports running as a foreground as well as a background process.</li>
</ul>
<h3><a class="anchor" id="autotoc_md896"></a>
DCA1000EVM Setup</h3>
<ul>
<li>DCA1000EVM should be connected to Host PC via Ethernet cable to access the CLI and Data Transfer process.</li>
<li>DCA1000EVM should be connected to TI Radar EVM via 60 pin HD Connector by using 60 pin Samtec ribbon cable.</li>
<li>DCA1000EVM power input should be connected either from DC Jack or TI Radar EVM power output (from 60 pin HD connector) by selecting the switch SW3.</li>
<li>Follow the mmWave Studio for additional RADAR EVM connectivity to PC and other pre-requisites.</li>
<li>Refer <b>TI_DCA1000EVM_quickStartGuide.pdf</b> document for more details.</li>
</ul>
<h3><a class="anchor" id="autotoc_md897"></a>
Power on/off sequence</h3>
<p>Initiate the power on sequence by turning on the radar EVM first, followed by the DCA1000EVM board. For shutdown, power off the DCA1000EVM board first, and then the radar EVM board.</p>
<h3><a class="anchor" id="autotoc_md898"></a>
Steps to Perform Raw ADC Data Streaming</h3>
<p>For successful recording of data from RADAR EVM sequence is given as follows</p>
<ul>
<li>Configure FPGA<ul>
<li>Ensure JSON config file (CLI) and Script config file (RADAR EVM) data format mode are in sync</li>
<li>Run the command - DCA1000EVM_CLI_Control.exe fpga configFile.json (located in mmWaveStudio/PostProc)</li>
<li>The acknowledgement for the above command is shown below  <style>div.image img[src="dca1000_cfg.png"]{width:50%}</style> <div class="image">
<img src="dca1000_cfg.png" alt=""/>
</div>
</li>
</ul>
</li>
<li>Start the record<ul>
<li>Ensure JSON config file (CLI) and Script config file (RADAR EVM) data logging mode are in sync</li>
<li>Run the command - DCA1000EVM_CLI_Control.exe start_record configFile.json (located in mmWaveStudio/PostProc)</li>
<li>The acknowledgement for the above command is shown below  <style>div.image img[src="dca1000_logging.png"]{width:50%}</style> <div class="image">
<img src="dca1000_logging.png" alt=""/>
</div>
</li>
</ul>
</li>
<li>Run the demo immediately after the above command by using the configuration with "adcLoggging 1" to enable this feature.</li>
<li>When data transfer starts DATA_TRANS_PRG LED (LD1) on DCA1000EVM will start toggling.</li>
<li>After the Raw ADC Data capture it will get stored in a adc_data_Raw_0.bin file in PostProc folder. And CLI_LogFile.txt contains all the commands execution information along with the timestamp. It can be viewed manually whenever required. The file will be appended for new sessions and new command execution information.</li>
<li>FPGA should be reconfigured in the following scenarios<ul>
<li>When the system is booted or rebooted</li>
<li>When the FPGA or DCA1000EVM is reset</li>
</ul>
</li>
</ul>
<p>Refer <b>TI_DCA1000EVM_CLI_Software_UserGuide.pdf</b> document for more details.</p>
<h3><a class="anchor" id="autotoc_md899"></a>
Validation of the ADC data</h3>
<p>The path <b>${SDK_INSTALL_PATH}/tools/ADC_parser</b> includes parsing and post processing scripts for interpreting Raw ADC data acquired from the DCA1000EVM board.</p><ul>
<li>The ar_convertAdcData_xWRLx432.m takes the Raw adc dump as input and converts it into adc matrix.</li>
<li>In addition, a post processing script Test_read_adc_data_xWRLx432.m, has been included to invoke the above parsing script, compute 1D and 2D FFTs.</li>
<li>The inputs to this script are adc_data_Raw_0.bin and cli_configuration.cfg. Update the paths accordingly in the above post processing script.</li>
<li>The FFT peaks are a means of validating the captured raw adc data. For example, a corner reflector is placed at 1m along the boresight of the radar. Assuming an FFT bin resolution of 0.1m/bin (derived based on chirping params), the 1D FFT peak falls at 10th bin.</li>
</ul>
<h2><a class="anchor" id="autotoc_md900"></a>
SPI based streaming of Raw ADC Data</h2>
<p>The MmWave Demo supports streaming of raw ADC data over SPI interface every frame during the frame idle time. However, there are some important limitations associated with this feature:</p>
<ul>
<li>User has to ensure that sufficient memory is available to store Raw ADC Data required per frame.</li>
<li>ADC data of every frame is transmitted during frame idle time. User has to ensure that sufficient frame idle time is available to transmit all the data by using proper frame periodicity in their config.</li>
<li>Use this feature with Low power mode disabled (lowPowerCfg 0).</li>
<li>This feature uses FTDI USB to SPI converter chips like FT232H, FT4232H etc. to transfer data from SPI interface of xWRL1432 to Host. If EVMs have these FTDI chips on them, user can use those, if not external converters have to be connected. Here the FTDI chip acts as SPI master and xWRL1432 acts as Slave device. SPI_busy signal is used as means of synchronization between FTDI chip and xWRL1432 device.</li>
</ul>
<h3><a class="anchor" id="autotoc_md901"></a>
Building the demo with this feature enabled</h3>
<p>Demos in SDK have this feature disabled by default. Follow below steps to enable this feature in demo.</p>
<ul>
<li>Enable the "ADC STREAMING via SPI" feature in "TI Demo" tab of demo Sysconfig.</li>
<li>"ADC_DATA_BUFF_MAX_SIZE" in "mmw_cli.h" file defines the size of buffer that holds ADC data of every frame. User is expected to update this macro based on the configurations being used. This size is "Number of RX antennas used X Number of Chirps per Frame X Number of ADC Samples per Chirp X Number of bytes per ADC Sample". Also, user has to work on linker scipt if required to get this buffer memory allocated and has to ensure that demo builds.</li>
<li>Rebuild the demo. Flash the appimage.</li>
</ul>
<h3><a class="anchor" id="autotoc_md902"></a>
Steps to Perform Raw ADC Data Streaming on xWRL1432 FCCSP device:</h3>
<ul>
<li>FCCSP EVM does not have on board SPI FTDI chip. User has to use external converter cable. We show the usage with C232HM-DDHSL-0 cable here (FT232H device) (<a href="https://ftdichip.com/products/c232hm-ddhsl-0-2/">https://ftdichip.com/products/c232hm-ddhsl-0-2/</a>). Please use C232HM-DDHSL-0 external cable or any FT232H device only. We can use other FTDI SPI-to-USB interface cable and chip but that needs to have MPSSE engine, also it may require different configuration for GPIO read. That's why It is preferable to use FT232H device only.</li>
</ul>
<p> <style>div.image img[src="C232HM-DDHSL-0_color_code.png"]{width:40%}</style> </p><div class="image">
<img src="C232HM-DDHSL-0_color_code.png" alt=""/>
<div class="caption">
C232HM-DDHSL-0 Cable SPI Wire Description</div></div>
<ul>
<li>Connection Table of SPI Interface of xWRL1432 with C232HM-DDHSL-0 Cable</li>
</ul>
<table class="doxtable">
<tr>
<th>XWRLx4XX FCCSP Device </th><th>C232HM-DDHSL-0 Cable  </th></tr>
<tr>
<td>MOSI </td><td>YELLOW WIRE  </td></tr>
<tr>
<td>MISO </td><td>GREEN WIRE  </td></tr>
<tr>
<td>CHIP SELECT </td><td>BROWN WIRE  </td></tr>
<tr>
<td>SPI CLOCK </td><td>ORANGE WIRE  </td></tr>
<tr>
<td>SPI BUSY </td><td>GREY WIRE  </td></tr>
<tr>
<td>GROUND </td><td>BLACK WIRE  </td></tr>
</table>
<p><br  />
</p>
<ul>
<li>Ensure that switch S1.1 and S1.6 is ON.</li>
<li>Setup Teraterm and paste the configuration, change "lowPowerCfg 1" to lowPowerCfg 0" to make the low power mode disable and change the "adcLogging 0" to "adcLogging 2" to enable this feature.</li>
<li>Do not press enter after sensor start command.</li>
</ul>
<p> <style>div.image img[src="Tera_term_spi_commands.png"]{width:60%}</style> </p><div class="image">
<img src="Tera_term_spi_commands.png" alt=""/>
<div class="caption">
Stop at the sensor start command</div></div>
<ul>
<li>Configure the FTDI chip to tranfer data to the Host.</li>
<li>To configure the FTDI chip, Run the adcDataSPIFTDI.exe application located in tools/spi_adc_streaming folder.</li>
<li>Give all the inputs to adcDataSPIFTDI application like Device Type, Number of ADC samples, Number of chiprs in burst, Number of burst in frame, Number of Frames, Number of Rx Antennas as given in configuration file. Ensure that this is done before "sensorStart" command is sent.</li>
</ul>
<p> <style>div.image img[src="adc_spi_exe.png"]{width:60%}</style> </p><div class="image">
<img src="adc_spi_exe.png" alt=""/>
<div class="caption">
Configuring adcDataSPIFTDI.exe</div></div>
<ul>
<li>After configuring the FTDI chip, send the Sensor Start command and Demo will start, Raw ADC Data for given number of frames will get stored in a adcData.txt file in spi_adc_streaming folder.</li>
<li>After getting all the data, we will see "Press Any key to Exit" text in adcDataSPIFTDI.exe. Close the adcDataSPIFTDI.exe application before opening the adcData.txt file.</li>
</ul>
<p> <style>div.image img[src="Close_the_exe.png"]{width:60%}</style> </p><div class="image">
<img src="Close_the_exe.png" alt=""/>
<div class="caption">
Configuring adcDataSPIFTDI.exe</div></div>
<h3><a class="anchor" id="autotoc_md903"></a>
Validation of the ADC data</h3>
<p>The path <b>${SDK_INSTALL_PATH}/tools/ADC_parser</b> includes parsing and post processing scripts for interpreting Raw ADC data acquired through SPI.</p><ul>
<li>The SPI based adc data is input as a .txt file along with the corresponding cli.cfg file.</li>
<li>The above file paths can be updated in the post processing script Test_read_adc_data_xWRLx432.m, to compute 1D and 2D FFTs.</li>
<li>The FFT peaks are a means of validating the captured raw adc data. For example, a corner reflector is placed at 1m along the boresight of the radar. Assuming an FFT bin resolution of 0.1m/bin (derived based on chirping params), the 1D FFT peak falls at 10th bin.</li>
</ul>
<h1><a class="anchor" id="autotoc_md904"></a>
Running in test mode</h1>
<p>For testing the signal processing chain, the source for the ADC samples can be configured to be the input file, instead of RF input stream, as shown in Figure below. This mode is enabled using a CLI command adcDataSource which specifies the input binary ADC data file. Note that this mode can run when the code is loaded through CCS. In this mode the RF part of the SOC is not configured.</p>
<p> <style>div.image img[src="mpd_adcdata.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_adcdata.png" alt=""/>
<div class="caption">
Reading ADC data from file</div></div>
<p>In this mode demo is controlled form the ADC read data task mmwDemo_adcFileReadTask(), that reads data from the file, and triggers the input EDMA of the range DPU. This task also saves the point cloud and the range azimuth heat map to files.</p>
<p>The timing diagram is illustrated below.</p>
<p> <style>div.image img[src="mmwave_adc_timing_diagram.png"]{width:80%}</style> </p><div class="image">
<img src="mmwave_adc_timing_diagram.png" alt=""/>
<div class="caption">
Timing diagram in demo test mode - ADC samples read from file.</div></div>
<h1><a class="anchor" id="autotoc_md905"></a>
Steps to Run Monitors</h1>
<p>Please refer to <a class="el" href="MONITORS.html">Monitors</a> for steps to run monitors</p>
<h1><a class="anchor" id="autotoc_md906"></a>
Steps to Run the Example</h1>
<ul>
<li><b>When using CCS projects to build</b>, import the CCS project for the required combination and build it using the CCS project menu (see <a class="el" href="CCS_PROJECTS_PAGE.html">Using SDK with CCS Projects</a>).</li>
<li><b>When using makefiles to build</b>, note the required combination and build using make command (see <a class="el" href="MAKEFILE_BUILD_PAGE.html">Using SDK with Makefiles</a>)</li>
<li>Launch a CCS debug session and run the executable, see <a class="el" href="CCS_LAUNCH_PAGE.html">CCS Launch, Load and Run</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md907"></a>
Power Measurements with INA228</h1>
<p>Following are power numbers with SDK default configurations measured using INA228 sensor.</p>
<table class="doxtable">
<tr>
<th>Configuration </th><th>Average Power (mW)  </th></tr>
<tr>
<td>Automated Parking </td><td>30.7  </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="astructDPU__DoaProc__compRxChannelBiasFloatCfg_html"><div class="ttname"><a href="structDPU__DoaProc__compRxChannelBiasFloatCfg.html">DPU_DoaProc_compRxChannelBiasFloatCfg</a></div><div class="ttdoc">Range Bias and rx channel gain/phase compensation configuration.</div><div class="ttdef"><b>Definition:</b> doaproc.h:474</div></div>
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
