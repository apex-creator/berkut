<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" href="favicon.png" type="image/png">    
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<title>xWRL1432 MMWAVE-L-SDK: Motion and Presence Detection OOB Demo</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<style>
.tinav {
    background: #c00;
    /* height: 41.375px; */
    height: 30px;
    }
</style>    
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="xWRL1432 MMWAVE-L-SDK"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectlogo"><a href="https://www.ti.com"><img alt="Logo" src="ti_logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xWRL1432 MMWAVE-L-SDK
   &#160;<span id="projectnumber">05.05.04.02</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class=tinav></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('MOTION_AND_PRESENCE_DETECTION_DEMO.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Motion and Presence Detection OOB Demo </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_examples_mmw_demos_motion_and_presence_detection"></a> </p>
<h1><a class="anchor" id="autotoc_md752"></a>
Purpose and Scope</h1>
<p>The Motion and Presence Detection OOB demo shows some of the capabilities of the xWRL1432 SOC using the drivers in the MMWAVE-L-SDK (Software Development Kit). The chapter provides description of system execution flow, memory usage, task organization and benchmark results. The chapter focuses on the implementation details of the low-level signal processing chain. It allows user to specify the chirping profile and displays the detected objects and other information in real-time. The demo comes with some default configurations (PresenceDetect.cfg, MotionDetect.cfg etc...). The configuration in PresenceDetect.cfg leverages the Minor Motion mode of the Signal processing chain to demonstrate the sensors ability to detect presence through fine motion. The MotionDetect.cfg configures the device to detect moving objects. It outputs a point cloud that can be fed to a tracker.</p>
<h1><a class="anchor" id="MOTION_AND_PRESENCE_DETECTION_DEMO_COMBOS"></a>
Supported Combinations</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter  </th><th class="markdownTableHeadNone">Value   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CPU + OS  </td><td class="markdownTableBodyNone">m4fss0-0 freertos   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Toolchain  </td><td class="markdownTableBodyNone">ti-arm-clang   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Board  </td><td class="markdownTableBodyNone">xWRL1432-evm   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Example folder  </td><td class="markdownTableBodyNone">examples/mmw_demo/motion_detection   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md753"></a>
Supported Features</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Feature  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Quick Evaluation  </td><td class="markdownTableBodyNone">Preflashed default application toggles the user LED based on presence detected within 1x1 sq mtr box infront of the radar. This feature is disabled by default.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">CLI Removal  </td><td class="markdownTableBodyNone">This feature generates an optimized application with reduced RAM and inturn reduced power. It is important to note that CLI is removed, if this feature is enabled, in addition to other CLI dependent features such as ADC logging, Monitors etc. This is disabled by default.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">MPD_Enable  </td><td class="markdownTableBodyNone">This feature allows optional enabling of MPD DPU in the demo processing chain, when CLI Removal is enabled. This is disabled by default, to reduce the demo application's memory footprint.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Dynamic Reconfig  </td><td class="markdownTableBodyNone">This feature enables seamless transitions between high-performance tracker processing and low-power presence detection, for intelligent power saving. This feature is disabled by default.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Raw ADC streaming  </td><td class="markdownTableBodyNone">Streaming of adc data over RDIF+DCA1000 or SPI. This feature is disabled by default.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Monitors  </td><td class="markdownTableBodyNone">FECSS analog monitors. This feature is disabled by default. This feature is disabled by default.   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Developer Guideline:<ul>
<li>It is adviced to keep M4 in WFI mode when device is actively chirping, to save power and reduce chances of noise coupling to RF</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="autotoc_md754"></a>
Using SysConfig</h1>
<p>A GUI tool SysConfig is used to configure different modules and peripherals of the example. Using this tool, users can select and customize different modules and peripherals. The SysConfig tool will generate the code for initializing and configuring these modules. This configuration is saved to a file called example.syscfg for every example. To know more about how to use SDK with SysConfig, Visit this page</p>
<p><a class="el" href="SYSCONFIG_INTRO_PAGE.html">Using SDK with SysConfig</a></p>
<h2><a class="anchor" id="autotoc_md755"></a>
Custom Demo Code Options</h2>
<p>Additionally, the GUI also allows enabling of supported combinations of the features listed above.</p>
<h3><a class="anchor" id="autotoc_md756"></a>
Steps to enable/disable the supported features</h3>
<ul>
<li>Open the demo example.syscfg and navigate to the TI DEMO menu</li>
<li>This provides the flexibility to Enable/Disable the features as shown in the figure below. Choose the required features and save the example.syscfg file</li>
</ul>
<p> <style>div.image img[src="mpd_syscfg_start.png"]{width:60%}</style> </p><div class="image">
<img src="mpd_syscfg_start.png" alt=""/>
</div>
<ul>
<li>Compile the application and run the demo with the updated binaries</li>
</ul>
<h3><a class="anchor" id="autotoc_md757"></a>
CLI Removal Feature</h3>
<p>This feature, if enabled, allows for a memory optimized demo code and application by disabling the CLI utility SW resources. By default, the demo configurations are predefined and the values match the default PresenceDetect.cfg.</p>
<p>However, the flexibility to modify these configurations is still possible through a sysconfig build-time option, to upload the required config via json file. This is an optional step, only if the default configuration needs to be updated.</p>
<p> <style>div.image img[src="mpd_syscfg.png"]{width:75%}</style> </p><div class="image">
<img src="mpd_syscfg.png" alt=""/>
</div>
<p>Reference json files for CLI-removal based point cloud only processing (CLI_Rem.json) and CLI-removal with MPD DPU enabled optionally (CLI_Rem_MPD_En.json) are available in the demo's profiles folder in the SDK (../examples/mmw_demo/motion_and_presence_detection/profiles). All parameters remain similar to the CLI cfg file and details about the same can be found in the Configuration file format section below.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>When CLI Removal is enabled, Phase compensation factors are taken from the default unity compensation factors(By default - real coefficients are unity factors with sign corresponding to the antenna phase shift for FCCSP design, imag coefficients are zeros) predefined in the application code.</li>
<li>When CLI Removal is enabled, the following features are not supported:<ul>
<li>Monitors</li>
<li>Raw ADC data streaming</li>
<li>Dynamic Reconfig</li>
<li>SDK Visualizer (Alternatively, BAC/Industrial visualizer could be used for performance visualization, using Start Without Sending CFG option. Please refer to TI Radar ToolBox for more details)</li>
</ul>
</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="autotoc_md758"></a>
Motion Detection Demo Setup</h1>
<p>The OOB motion/presence detection demo setup is shown in Figure below. The demo configuration is provided by the command line interface (CLI) configuration file. The PC visualizer is connected to the xWRL1432 EVM board via single UART port. The motion/presence detection algorithm runs on the xWRL1432 radar sensor. Initially, to start a demo, a set of CLI configuration commands is sent to the EVM. Based on the configuration the EVM sends through the same port various detection information to the visualizer, such as point cloud, range profile, detection heatmap, presence detection information, and stats data.</p>
<p> <style>div.image img[src="mpd_setup.png"]{width:70%}</style> </p><div class="image">
<img src="mpd_setup.png" alt=""/>
<div class="caption">
OOB Motion detection demo setup</div></div>
<p>The updated release of the SDK incorporates new functionalities including target tracking and target classification. With these added functionalities, the OOB demo can perform different use cases that can be controlled through the CLI configuration file.</p>
<p>Below is the processing layers of the demo for the motion/presence detection use case.</p>
<p> <style>div.image img[src="mpd_sigpro_layers.png"]{width:40%}</style> </p><div class="image">
<img src="mpd_sigpro_layers.png" alt=""/>
<div class="caption">
The signal processing layers of the motion/presence detection demo</div></div>
<p>Below is the processing layers of the demo including target tracking and classification.</p>
<p> <style>div.image img[src="mpd_sigpro_layers1.png"]{width:40%}</style> </p><div class="image">
<img src="mpd_sigpro_layers1.png" alt=""/>
<div class="caption">
The signal processing layers including target tracking and classification</div></div>
<p>Below is the top-level radar signal processing timing diagram per frame including presence detection, and target tracking and classification.</p>
<p> <style>div.image img[src="mpd_timing.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_timing.png" alt=""/>
<div class="caption">
Signal processing high level timing diagram</div></div>
<h1><a class="anchor" id="autotoc_md759"></a>
MIMO Modulation Schemes</h1>
<p>Motion Detection OOB Demo supports two MIMO modulation schemes TDM-MIMO and BPM-MIMO scheme. Typical timing diagram is illustrated in Figure below.</p>
<p> <style>div.image img[src="mpd_chirp_timing.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_chirp_timing.png" alt=""/>
<div class="caption">
Chirp timing diagram TDM-MIMO and BPM-MIMO</div></div>
<h1><a class="anchor" id="autotoc_md760"></a>
Chirp Configuration Modes</h1>
<p>The motion detection demo currently supports two chirp configuration modes ‚ÄúNormal mode‚Äù and ‚ÄúBurst mode‚Äù. The following configuration conditions are defined for the two modes. In the normal mode, one burst per frame is configured, and the number of chirps is even number, while in the burst mode 2 chirps per burst are configured, and the number of bursts per frame is even number. Both modes support either TDM or BPM MIMO modulation scheme. Note that single TX operation is not supported in burst mode. The Tx antenna pattern for these two modes is illustrated below.</p>
<p> <style>div.image img[src="mpd_mimo_normal.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_mimo_normal.png" alt=""/>
<div class="caption">
2Tx MIMO pattern in Normal Mode</div></div>
<p> <style>div.image img[src="mpd_mimo_burst.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_mimo_burst.png" alt=""/>
<div class="caption">
2Tx MIMO pattern in Burst Mode</div></div>
<h1><a class="anchor" id="autotoc_md761"></a>
Antenna Geometry</h1>
<p>The demo supports different antenna configurations. This is achieved through the CLI configuration. The antenna pattern is specified by the CLI command antGeometryCfg. The command specifies the row and column position for each virtual antenna in the 2D virtual antenna array grid, as illustrated in Figure below. The syntax of the command is</p>
<p>antGeometryCfg ant1Row ant1Col ant2Row ant2Col ‚Ä¶ant6Row ant6Col distX distZ</p>
<p>The last two parameters of the command specify antenna spacing (in millimeters) in X and Z dimensions.</p>
<p> <style>div.image img[src="mpd_ant_geo.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_ant_geo.png" alt=""/>
<div class="caption">
Virtual antenna arrangement based on the Tx/Rx antenna pattern and the corresponding CLI configuration command for xWRL1432 EVM board</div></div>
<p>Below figure shows the antenna configuration on the IWRL6432 EVM board.</p>
<p> <style>div.image img[src="iwrl6432.png"]{width:50%}</style> </p><div class="image">
<img src="iwrl6432.png" alt=""/>
<div class="caption">
IWRL6432 EVM board, FR4 based, 2-patch antennas.</div></div>
<p>The antenna spacing and the virtual antenna array are shown below. The right-most figure shows the virtual antenna with the red and blue antennas corresponding to TX1 and TX2 respectively.</p>
<p> <style>div.image img[src="mpd_ant_spacing.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_ant_spacing.png" alt=""/>
<div class="caption">
Antenna spacing and virtual antenna array representation</div></div>
<h1><a class="anchor" id="autotoc_md762"></a>
Signal Processing Chain</h1>
<p>The top-level signal processing chain implemented on xWRL1432 for the presence/motion detection use case is shown below. For more information on the signal processing chain please refer <b>${SDK_INSTALL_PATH}/docs/Motion_Presence_Detection_Demo_Tuning_Guide.pdf</b>.</p>
<p> <style>div.image img[src="mpd_presence_processing.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_presence_processing.png" alt=""/>
<div class="caption">
High level view of radar processing chain with presence detection option</div></div>
<p>Below is the top-level signal processing chain including the tracker and micro-Doppler based classification and discrimination between human and non-human targets.</p>
<p> <style>div.image img[src="mpd_tracker_processing.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_tracker_processing.png" alt=""/>
<div class="caption">
Top-level view of radar signal processing chain tracker and tracker and classification</div></div>
<p>The basic signal processing is split among the following data processing functional block units (DPUs)</p>
<ul>
<li><b>Range DPU:</b> Performs:<ul>
<li>BPM decoding applied on the ADC samples,</li>
<li>Range FFT for each antenna and chirp.</li>
<li>The only radar data cube format supported in this demo is <b>DPIF_RADARCUBE_FORMAT_6</b></li>
</ul>
</li>
<li><b>DOA DPU:</b> Creates the range azimuth detection matrix (heatmap). Per range bin it performs:<ul>
<li>Doppler FFT per each antenna,</li>
<li>Static clutter removal by dropping zero Doppler bin,</li>
<li>Antenna mapping into (azimuth-elevation) 2D array, and 2D angle FFT per Doppler bin,</li>
<li>Summation and peak selection across Doppler dimension,</li>
<li>Peak selection across elevation dimension. (NOTE: The angle-FFT processing of the SDK only supports the antenna configuration shown in Figure above. Below chapters describes how this may be modified for other antenna configurations. The summation/peak selection across Doppler and elevation dimensions are used to collapse the Doppler and elevation dimensions to create a range-azimuth detection matrix)</li>
</ul>
</li>
<li><b>CFAR DPU:</b> Performs CFAR detection algorithm on the range-azimuth detection matrix:<ul>
<li>CFAR detection algorithm (CFAR-CASO) applied along range dimension,</li>
<li>Detected points confirmed by being local peak in azimuth domain,</li>
<li>Range and azimuth interpolation,</li>
<li>Elevation estimation as maximum peak selection in elevation domain,</li>
<li>Radial Velocity estimation as maximum peak selection in Doppler domain,</li>
<li>Calculates cartesian coordinates of detected point, places detected point to point cloud list.</li>
</ul>
</li>
<li><b>Presence Detection DPU:</b> Performs:<ul>
<li>Zone association,</li>
<li>Search for clusters in Cartesian space,</li>
<li>State machine per zone,</li>
<li>Outputs presence information per zone</li>
</ul>
</li>
<li><b>Tracker processing DPU:</b> Performs target tracking based on the point cloud data and reports a list of tracking targets.</li>
<li><b>Micro-Doppler DPU:</b> Performs the classification of detected and tracked targets. The classification is based on the features extracted from the detected ¬µ-Doppler spectrum reflected from the target. It includes the following functionalities per detected target:<ul>
<li>¬µ-Doppler spectrum computation,</li>
<li>Feature extraction from the ¬µ-Doppler spectrum,</li>
<li>Classification of detected targets as human or non-human.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md763"></a>
Motion Detection Modes</h2>
<p>Motion detection algorithm supports following motion detection modes.</p>
<ul>
<li><b>Major motion detection mode</b>: In this mode, the detection layer chain runs one time using the radar cube from the current frame. The Doppler FFT processing is done across chirps in a single frame.</li>
<li><b>Minor motion detection mode</b>: In this mode, the detection layer chain runs one time using the radar cube created across the current and previous frames. The Doppler FFT processing is done across chirps that span multiple frames.</li>
<li><b>Auto mode</b>: In this mode, the detection layer chain runs two times using both the radar cube from the current frame and the radar cube created across the current and previous frames.</li>
</ul>
<p>The radar cube generation in Major and Minor mode is illustrated in Figures below.</p>
<p> <style>div.image img[src="mpd_radarcube_major_minor.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_radarcube_major_minor.png" alt=""/>
<div class="caption">
Radar cubes for Major and Minor motion detection</div></div>
<p> <style>div.image img[src="mpd_radarcube_auto.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_radarcube_auto.png" alt=""/>
<div class="caption">
Radar processing chain in auto mode (major and minor motion detection mode)</div></div>
<h2><a class="anchor" id="autotoc_md764"></a>
Dynamic Reconfig</h2>
<p>This feature enables seamless transitions between high-performance tracker processing and low-power presence detection through the designed state machine. It additionally achieves power saving by intelligent configuration switching, based on the detected scene.</p>
<p>The flow diagram is shown below.</p>
<p> <style>div.image img[src="profileswitch.png"]{width:50%}</style> </p><div class="image">
<img src="profileswitch.png" alt=""/>
</div>
<p>This feature can be added to the demo code by using syscfg, as it is disabled by default. And, the configuration parameters can be populated via CLI command - "profileSwitchCfg" which has the following parameters:</p><ul>
<li>switchCfgEnable: 0: Disable, 1: Enable.</li>
<li>frmPretoTrack: Threshold on number of frames for switching from presence to tracker state.</li>
<li>frmTracktoPre: Threshold on number of frames for switching from tracker to presence state.</li>
</ul>
<p>Users can initiate the demo with either the presence/tracker configuration. Once the set threshold is hit, the sensor smoothly switches to the alternate configuration (tracker/presence) predefined in the demo application. When the sensor returns to the initial config state based on the state machine, it takes the saved user configured parameters.</p>
<p>For example, if a user starts the demo with the presence configuration with profileSwitchCfg enabled, the sensor automatically transitions to the tracker configuration when continuous presence is detected for frmPretoTrack frames. If no tracker objects are detected for frmTracktoPre frames, the demo reverts to the user-provided presence configuration. This cycle repeats based on the sensing scene. In turn, power saving is also achieved by staying in the low power presence configuration, unless a constant movement is detected for the configured number of frames.</p>
<p>Note: This feature can be enabled only when lowPowerCfg CLI command is enabled. This is to ensure maximum power saving possible and optimal demo experience overall.</p>
<h1><a class="anchor" id="RANGE_ANGLE_SNR"></a>
Variable SNR detection thresholds</h1>
<h2><a class="anchor" id="autotoc_md765"></a>
SNR vs Range - Feature Description</h2>
<p>The amount of power that objects placed at a fixed distance can return back to the radar is proportional to the reciprocal of their distance to the fourth power. To account for this attenuation, users can set a detection SNR threshold that decreases with range. The user can set a variable detection threshold as a function of range through the CLI with just 2 arguments : the range at which they want to detect a target, and the SNR they expect the target to exhibit at that range. This reference pair of (range, power) can be used to estimate the expected power of the same target at different ranges using the below power equation. This equation defines the curve for the SNR compensation.</p>
<p> <style>div.image img[src="rangesnreq1.png"]{width:30%}</style> </p><div class="image">
<img src="rangesnreq1.png" alt=""/>
</div>
<p>The user can also add an additional 2 arguments - a minimum and a maximum range for which the SNR compensation to saturate at. So, if points are detected closer than the minimum range, the SNR of those points will be compared to will be the SNR at the minimum range, and if points are detected further than the maximum range, the SNR of those points will be compared to the SNR at the maximum range. See the graph below. The minimum range for SNR compensation is set to 2 meters, and the maximum range for compensation is set to 5 meters.</p>
<p> <style>div.image img[src="rangesnr_graph.png"]{width:30%}</style> </p><div class="image">
<img src="rangesnr_graph.png" alt=""/>
</div>
<h2><a class="anchor" id="autotoc_md766"></a>
SNR vs Angle - Feature Description</h2>
<p>Just like the returned power from the object to the radar varies over range, it also varies over angle due to the variation of antenna gain over the angle of arrival of a target. This is principally dictated by the radiation patterns of the transmitters and receivers.</p>
<p>To account for this variation over angle, different rangeSNRCompensations can be applied over 1-2 sets of angle limits. The recommended usage is the following:</p>
<ul>
<li>Set the reference (range, SNR) pair for the middle of the field of view (blue region in diagram below).</li>
</ul>
<p> <style>div.image img[src="range_angle_snr.png"]{width:30%}</style> </p><div class="image">
<img src="range_angle_snr.png" alt=""/>
</div>
<p>Since the middle of the field of view will often have the most antenna gain, set a compensation factor that limits the number of weak SNR points that can be detected right in front of the radar. This will reduce the number of false positives detected. The below example accomplishes this with a reference SNR of 6 dB at 12 meters for the range between -30 and 30 degrees, shown by the blue trace in the graph below.</p>
<p> <style>div.image img[src="range_diff_anglessnr.png"]{width:30%}</style> </p><div class="image">
<img src="range_diff_anglessnr.png" alt=""/>
</div>
<ul>
<li>Set the range compensation for a wider field of view (red radial region in the diagram above). Since objects in this this region will typically experience less antenna gain, it is important to reduce the compensation thresholds for this region. The example above sets this value to 2, meaning that the region has the same detection criteria as the first (blue) region, but with thresholds uniformly 2 dB lower over range. This region stretches from -50 degrees to -30 degrees and from +30 degrees to +50 degrees, and saturates the same way as the first region at less than 5m and greater than 12m away. See that the red curve in the graph above is always 2 dB below the blue curve.</li>
<li>Set the cfar threshold to a value lower than the minimum detection at the edges of the field of view. In the graph above, the minimum SNR compensation is 6 dB at 12 meters, minus 2 for the secondary region, leaving 4 dB. Therefore, the CFAR detection threshold must be set to 4 dB at most. See that the yellow trace is never strictly below the blue or red traces. This threshold will be applied to angles outside of +/- 50 degrees (yellow region), as that was the limit set by the secondary rangeCompensation (red region).<ul>
<li>The exact values can change, but the methodology behind the multiple zone thresholds, namely, having decreasing SNR thresholds over angle, should be kept the same. The final 5 available arguments for the rangeSNRCompensation allow the user to apply it over different angles. The 6th and 7th arguments allow the user to set minimum and maximum angles for the 1st range vs SNR relationship (blue radial region in figure above), and the 8th and 9th arguments set the minimum and maximum angles for the 2nd range vs SNR relationship (red radial region in figure above). Finally, the 10th argument sets the reduction in transmit power between the 1st and 2nd regions. This is seen as the difference between the red and blue traces in the graph above.</li>
</ul>
</li>
</ul>
<p>Refer to rangeSNRCompensation CLI command for more details on SNR vs Range and Angle - CLI structure.</p>
<h1><a class="anchor" id="autotoc_md767"></a>
Rx Channel Gain/Offset Measurement and Compensation</h1>
<p>Because of imperfections in antenna layouts on the board there is a need to calibrate the sensor to compensate for bias in the range estimation and the receive channel gain and phase imperfections. The motion detection demo provides the ability to do the measurement and compensation.</p>
<h2><a class="anchor" id="autotoc_md768"></a>
Measurement Procedure Implementation</h2>
<p>The measurement procedure is configured using a CLI command measureRangeBiasAndRxChanPhase. The following is the command syntax:</p>
<p>measureRangeBiasAndRxChanPhase enabled targetDistance searchWindow</p><ul>
<li>where enabled - is the flag to enable the procedure, targetDistance - is the distance of the strong target in front of the sensor at the bore site (in meters), searchWindow - is the search window (in meters).</li>
</ul>
<p>The procedure is implemented by the function mmwDemo_rangeBiasRxChPhaseMeasure(). It is called in the processing chain after the range processing DPU. The input to the procedure is a radar cube. The measurement procedure first calculates the range profile as the sum of the magnitude squares across all antennas on the range FFTs. Then it searches for the peak in the zone ùëã‚àíùê∑/2 ‚â§ ùëüùëéùëõùëîùëí ‚â§ ùëã+ùê∑/2 where ùê∑ = searchWindow and ùëã = targetDistance.</p>
<p>The procedure then estimates the peak position using the three point parabolic interpolation and the range bias as the difference between the peak position and the configured target distance X.</p>
<p>The Rx channel compensation coefficients are calculated according to following equations.</p>
<p>From the radar cube stored as a complex16 3D array ùëã[ùëê‚Ñéùëñùëüùëù][ùëéùëõùë°ùëíùëõùëõùëé][ùëüùëéùëõùëîùëí], the received symbols are extracted at the range index ùëñ<sub>ùëùùëíùëéùëò</sub> of the peak position corresponding to the target as  <style>div.image img[src="mpd_rx_eq1.png"]{width:30%}</style> </p><div class="image">
<img src="mpd_rx_eq1.png" alt=""/>
</div>
<p> The coefficients are calculated as  <style>div.image img[src="mpd_rx_eq2.png"]{width:15%}</style> </p><div class="image">
<img src="mpd_rx_eq2.png" alt=""/>
</div>
<p> where  <style>div.image img[src="mpd_rx_eq3.png"]{width:15%}</style> </p><div class="image">
<img src="mpd_rx_eq3.png" alt=""/>
</div>
<p> The coefficients are transmitted to the host within the TLV packet each frame. The SDK visualizer displays these coefficients in its command window.</p>
<p><b>Measurement Procedure Steps:</b></p>
<ul>
<li>Set a strong target like corner reflector at boresight at desired distance and measure precisely the distance from the sensor.</li>
<li>Create the CLI configuration file for the measurement procedure with<ul>
<li>the enabled flag to 1 in CLI command measureRangeBiasAndRxChanPhase,</li>
<li>all antennas enabled,</li>
<li>TDM MIMO mode selected,</li>
<li>major mode detection enabled.</li>
</ul>
</li>
<li>Run the target demo. The target sends TLV with the calculated coefficients.</li>
<li>Copy one snapshot of the coefficients to clipboard.</li>
<li>Paste the copied line into the final CLI configuration file.</li>
</ul>
<h1><a class="anchor" id="autotoc_md769"></a>
System execution flow</h1>
<p>This section explains the execution flow of the demo during both the initialization and configuration stages, as well as during each frame in the steady state.</p>
<h2><a class="anchor" id="autotoc_md770"></a>
Initialization and Configuration</h2>
<p>The system execution flow at the initialization and configuration time is shown in Figure below. At the startup the system initialization is performed, the CLI task is created, waiting for the input CLI commands. After receiving the CLI sensorStart command, the last command in the configuration sequence, it configures the RF and then creates the demo DPC task, mmwDemo_dpcTask. As the DPC task has higher priority than the CLI task, it preempts the CLI task, and performs the configuration of the signal processing chain components, and calls the range processing API as a first processing DPU in the chain. The range processing function starts pending on the semaphore waiting for the first frame chirping and the chirp processing time to complete. The task control is then switched back to CLI task that creates the UART transmit task, mmwDemo_TransmitProcessedOutputTask, and issues the sensor start command to the RF. The CLI task then enters the pending state and remains in it from that moment on. The power management task, that is also created at the start time is engaged only in the power saving mode.</p>
<p> <style>div.image img[src="mpd_init_config.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_init_config.png" alt=""/>
<div class="caption">
Initialization and configuration</div></div>
<h2><a class="anchor" id="autotoc_md771"></a>
Steady state ‚Äì low power mode disabled</h2>
<p>The steady state system execution flow is periodic, executed per frame. Figure below shows the system execution flow over one frame period. The frame ISR function is triggered upon the frame start event, and currently it is only used for diagnostic purpose. During the chirping time, the HWA is performing the chirp processing, while the range DPU process function is waiting for the HWA processing to complete. After the range processing, the DOA DPU followed by CFAR DPU are executed creating the point cloud list. The point cloud list is compressed to fix format ready to be sent out to the Host. The HWA is then configured for the next frame, semaphore post to the UART task indicating that the frame data are ready, and the range processing API is called for the next frame. The DPC task goes to pending state giving control to the UART task to send data to the HOST.</p>
<p> <style>div.image img[src="mpd_init_config_lp_disabled.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_init_config_lp_disabled.png" alt=""/>
<div class="caption">
System execution per frame when low power mode is disabled</div></div>
<h2><a class="anchor" id="autotoc_md772"></a>
Steady state ‚Äì low power mode enabled</h2>
<p>The steady state system flow in low power mode is shown in Figure below. In the low power mode the powerManagementTask() controls the power savings. When the UART task completes the data transfer to the Host of the frame n, it calculates the available time for the low power deep sleep phase as ùëá<sub>ùë†ùëôùëíùëíùëù</sub>(ùëõ) = ùëá<sub>ùêπùëüùëéùëöùëí</sub> ‚àí ùëá<sub>ùê∑ùëíùëöùëú</sub>(ùëõ) ‚àí ùëá<sub>ùëôùëùùëëùë†ùêøùëéùë°ùëíùëõùëêùë¶</sub></p>
<p> <style>div.image img[src="mpd_init_config_lp_enabled.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_init_config_lp_enabled.png" alt=""/>
<div class="caption">
System execution per frame when low power mode is enabled</div></div>
<h1><a class="anchor" id="autotoc_md773"></a>
Task Model</h1>
<p>Motion detection demo is implemented on xWRL1432 using multiple tasks running in the system. Table below list all tasks used in the system.</p>
<p> <style>div.image img[src="mpd_tasks.png"]{width:50%}</style> </p><div class="image">
<img src="mpd_tasks.png" alt=""/>
<div class="caption">
Motion detection demo tasks</div></div>
<h2><a class="anchor" id="autotoc_md774"></a>
Main Task</h2>
<p>This is free RTOS main task initially called by the main function. It is active only during the start time, and after the creation of the CLI task it rests in pending state.</p>
<h2><a class="anchor" id="autotoc_md775"></a>
CLI Task</h2>
<p>The CLI task provides the execution context for the command line interface. It includes simple command parser.</p>
<h2><a class="anchor" id="autotoc_md776"></a>
DPC Task</h2>
<p>The DPC task provides the execution context for the detection processing chain.</p>
<h2><a class="anchor" id="autotoc_md777"></a>
UART Task</h2>
<p>This task controls the transfer of radar detection data to the host. The task transmits one packet of data per radar frame using a TLV format structure. Depending on the CLI configuration command guiMonitor the task sends point cloud, range profile, detection matrix, presence detection information, etc.</p>
<h2><a class="anchor" id="autotoc_md778"></a>
ADC read data Task</h2>
<p>This task is used for running the unit tests for motion detection demo. The task reads reference ADC data samples from the file and feeds the signal processing chain instead of real ADC data coming from the RF.</p>
<h2><a class="anchor" id="autotoc_md779"></a>
Power Management Task</h2>
<p>This task is engaged when the motion detection demo is running in the power saving deep sleep mode.</p>
<h2><a class="anchor" id="autotoc_md780"></a>
Timing Diagram</h2>
<p>The timing diagram during the startup and the first two frames is illustrated below</p>
<p> <style>div.image img[src="mpd_timing_lp_disabled.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_timing_lp_disabled.png" alt=""/>
<div class="caption">
Timing diagram ‚Äì low power mode disabled.</div></div>
<p>The timing diagram in the low power mode is shown below.</p>
<p> <style>div.image img[src="mpd_timing_lp_enabled.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_timing_lp_enabled.png" alt=""/>
<div class="caption">
Timing diagram ‚Äì low power mode enabled.</div></div>
<h1><a class="anchor" id="autotoc_md781"></a>
Benchmarks</h1>
<p>Currently the CPU time and the UART transmit time is reported to Host within the stats TLV. The explanation of these time intervals is shown in the timing diagram above.</p>
<h1><a class="anchor" id="autotoc_md782"></a>
Configuration (.cfg) File Format (CLI INTERFACE)</h1>
<dl class="section attention"><dt>Attention</dt><dd><b>Converting configuration from older SDK release to current SDK release:</b><br  />
 As new versions of SDK releases are available, there are usually changes to the configuration commands that are supported in the new release. Now, users may have some hand crafted config file which worked perfectly well on older SDK release version but will not work as is with the new SDK release. Check users guide for details.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Example configuration files are available at '${SDK_INSTALL_PATH}/examples/mmw_demo/motion_detection/profiles/xWRL1432-evm'. All the CLI commands should be between 'sensorStop' and 'sensorStart'</dd></dl>
<p>Each line in the .cfg file describes a command with parameters. The various commands and their arguments are described in the table below (arguments are in sequence)</p>
<h2><a class="anchor" id="autotoc_md783"></a>
Sensor front-end parameters</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Commands  </th><th class="markdownTableHeadNone">Parameters  </th><th class="markdownTableHeadNone">Notes   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>sensorStop</b>  </td><td class="markdownTableBodyNone"><code>FrameStopMode</code>  </td><td class="markdownTableBodyNone">Indicates the frame stop mode. This command stops the sensor from transmitting further frames. <br  />
Important Note: This command is not supported when lowPowerCfg is 1 <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="3"><b>channelCfg</b>  </td><td class="markdownTableBodyNone"><code>RxChCtrlBitMask</code>  </td><td class="markdownTableBodyNone">RX antennas 1 and 2, mask = 0x011b = 3 <br  />
RX antennas 1 and 3, mask = 0x101b = 5 <br  />
RX antennas 2 and 3, mask = 0x110b = 6 <br  />
RX antennas 1, 2 &amp; 3, mask = 0x111b = 7<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>TxChCtrlBitMask</code>  </td><td class="markdownTableBodyNone">TX antennas 1 and 2, mask = 0x011b = 3<br  />
TX antenna 1, mask = 0x001b = 1 <br  />
TX antenna 2, mask = 0x010b = 2<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MiscCtrl</code>  </td><td class="markdownTableBodyNone">Not supported on the current version of the SDK.<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="7"><b>chirpComnCfg</b>  </td><td class="markdownTableBodyNone"><code>DigOutputSampRate</code>  </td><td class="markdownTableBodyNone">Digital output Sampling rate for chirp ADC samples. Digital sampling rate is given by 100MHz/ DigOutputSampRate. The valid sampling rate can be configured as per below.<br  />
 8 - 12.5 MHz <br  />
 9 - 11.11 MHz <br  />
 10 - 10 MHz <br  />
 12 - 8.333 MHz <br  />
 16 - 6.25 MHz <br  />
 20 - 5 MHz <br  />
 25 - 4 MHz <br  />
 32 - 3.125 MHz <br  />
 40 - 2.5 MHz <br  />
 50 - 2 MHz <br  />
 64 - 1.5625 MHz <br  />
 80 - 1.25 MHz <br  />
 100 - 1 MHz   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>DigOutputBitsSel</code>  </td><td class="markdownTableBodyNone">Digital output sample bits select, this field governs which bits of the FECSS DFE's internal 16 bit signed data path are sent as output.<br  />
 0 - Digital sample output is 12 MSB bits of DFE after rounding 4 LSBs <br  />
 1 - Digital sample output is 12 bits after rounding 3 LSBs &amp; clipping 1 MSB <br  />
 2 - Digital sample output is 12 bits after rounding 2 LSBs &amp; clipping 2 MSB <br  />
 3 - Digital sample output is 12 bits after rounding 1 LSBs &amp; clipping 3 MSB <br  />
 4 - Digital sample output is 12 LSB bits after clipping 4 MSB <br  />
 5 - Digital sample output is 16 bits   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>DfeFirSel</code>  </td><td class="markdownTableBodyNone">The final stage FIR filter's characteristics can be selected as below. <br  />
 0 - Long Filter (90% visibility): This provides visibility to a larger range of IF frequencies: 0 to 0.45 x Sampling Rate. Beyond that, the filter response starts drooping &amp; enters filter transition band. <br  />
 1 - Short Filter (80% visibility): This provides faster settled outputs but the IF frequency range visible is 0 to 0.40 x Sampling Rate. Beyond that, the filter response starts drooping &amp; enters filter transition band.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>NumOfAdcSamples</code>  </td><td class="markdownTableBodyNone">No. of ADC samples.<br  />
<b>Valid Range</b>: 2 to 1024.<br  />
 <b>Note</b> SDK-OOB Demo allows a maximum of 1024 h_NumOfAdcSamples because HWA 1.2 can only process FFTs up to 1024 points. However, the front-end is capable of supporting up to 2048 h_NumOfAdcSamples.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ChirpTxMimoPatSel</code>  </td><td class="markdownTableBodyNone">Only option 0 is not supported in current OOB Demo. <br  />
 0 - TX BPM MIMO pattern disabled <br  />
 1 - TDMA_2TX pattern <br  />
 4 - BPM_2TX pattern   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ChirpRampEndTime</code>  </td><td class="markdownTableBodyNone">Chirp Profile Ramp end Time. This is a common ramp end time value for all chirps in a frame.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ChirpRxHpfSel</code>  </td><td class="markdownTableBodyNone">Chirp Profile HPF corner frequency. This is a common HPF corner frequency value for all chirps in a frame. <br  />
 0 - 175kHz HPF corner frequency<br  />
 1 - 350kHz HPF corner frequency<br  />
 2 - 700kHz HPF corner frequency<br  />
 3 - 1400kHz HPF corner frequency   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="5"><b>chirpTimingCfg</b>  </td><td class="markdownTableBodyNone"><code>ChirpIdleTime</code>  </td><td class="markdownTableBodyNone">Chirp Profile Idle Time. This is a common idle time value for all chirps in a frame. <br  />
<b>Unit</b>: 1us.<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ChirpAdcSkipSamples</code>  </td><td class="markdownTableBodyNone">Chirp Profile ADC start skip samples. This is a common adc start time value for all chirps in a frame <br  />
 <b>Valid range</b>: 0 to 63   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ChirpTxStartTime</code>  </td><td class="markdownTableBodyNone">Chirp Profile TX start Time. This is a common TX start time value for all chirps in a frame.This field indicates the TX start time in the chirp cycle with respect to the knee of the ramp. <br  />
 <b>Unit</b>: In usec   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>ChirpRfFreqSlope</code>  </td><td class="markdownTableBodyNone">Chirp Profile RF Frequency Slope. This is a common RF frequency slope value for all chirps in a frame.This field indicates the required FMCW slope of the chirp. <br  />
 <b>Unit</b>: MHz/us <br  />
<b>Valid range</b>:- 399MHz/us to +399MHz/us.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>ChirpRfFreqStart</code>  </td><td class="markdownTableBodyNone">Chirp Profile RF start Frequency. This is a common RF start frequency value for all chirps in a frame. This field indicates the required start frequency of the chirp.<br  />
 <b>Unit</b>: GHz <br  />
<b>Valid range</b>:58GHz to 62.5GHz for ES1.0 devices <br  />
 <b>Note</b> The xWRL6432AOP device operates within a frequency band of 57 GHz to 63.5 GHz.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="6"><b>frameCfg</b>  </td><td class="markdownTableBodyNone"><code>NumOfChirpsInBurst</code>  </td><td class="markdownTableBodyNone">Number of Chirps in a Burst. This field indicates the number of chirps to be generated per burst.<br  />
 <b>Valid range</b>: 1 to 65535 chirps .<br  />
 (<em>Limited support in current OOB</em>)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>NumOfChirpsAccum</code>  </td><td class="markdownTableBodyNone">Number of accumulation per chirp. This field indicates the Number of chirps to be accumulated before sending the ADC data out in DFE, this can be used to increase the SNR without increasing the number of chirps to process in the DSP/HW accelerator. <br  />
 <b>Valid range</b>: : 0 to 64 chirps.<br  />
 (<em>Limited support in current OOB</em>)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>BurstPeriodicity</code>  </td><td class="markdownTableBodyNone">Burst periodicity in Œºs. This field indicates the period of the burst.<br  />
 (<em>Limited support in current OOB</em>)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>NumOfBurstsInFrame</code>  </td><td class="markdownTableBodyNone">Number of bursts per frame. <br  />
 <b>Valid range</b>:1 to 4096 <br  />
<b>Note</b> Only a power-of-two number of chirps(NumOfBurstsInFrame * NumOfChirpsInBurst) per frame is supported. <br  />
(<em>Limited support in current OOB</em>)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>FramePeriodicity</code>  </td><td class="markdownTableBodyNone">Frame Periodicity. This field indicates the period of the frame, 32bit counter.This field indicates the frame periodicity, the time gap between successive frame starts. <br  />
 <b>Unit</b>: ms <br  />
<b>Valid range</b>:100 to 4294967295 (<em>Limited support in current OOB</em>)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>NumOfFrames</code>  </td><td class="markdownTableBodyNone">Number of frames. <br  />
 <b>Valid range</b>: 0 to 65535, 0 means infinite<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="5"><b>adcLogging</b>  </td><td class="markdownTableBodyNone"><code>enable</code>  </td><td class="markdownTableBodyNone">ADC data logging enable: <br  />
 0 - Disable. <br  />
 1: Enable via DCA. <br  />
 2: Enable via SPI. <br  />
 NOTE: When ADC logging via DCA is enabled number of adc samples must be a multiple of 4. And the configs listed below are not applicable when SPI logging is used. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>sideBandEnable</code>  </td><td class="markdownTableBodyNone">Sideband data logging:(optional argument) <br  />
 0: Disable. <br  />
 1: Enable. <br  />
 NOTE: FrameLivMonEn in sensorstart must be set to a value 2(RX_SATURATION_LIVE_MON must be enabled) for sideband data logging. And by default sideband data is disabled. Also note that Side Band capture is not supported on IWRL devices due to non support for required monitoring <br  />
 (Refer to the ICD for more details about this feature) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>swizzlingMode</code>  </td><td class="markdownTableBodyNone">RDIF Data Swizzling Mode enable control:(optional argument) <br  />
 0: Pin0-bit0-Cycle1 Mode. <br  />
 1: Pin3-bit0-Cycle1 Mode. <br  />
 2: Pin0-bit0-Cycle3 Mode. <br  />
 3: Pin3-bit0-Cycle3 Mode. <br  />
 (Refer to the ICD for more details about this feature) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>scramblerMode</code>  </td><td class="markdownTableBodyNone">RDIF Scrambler Mode enable control:(optional argument) <br  />
 0: Disable. <br  />
 1: Enable. <br  />
 (Refer to the ICD for more details about this feature) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>laneRate</code>  </td><td class="markdownTableBodyNone">Enable RDIF lane rate update:(optional argument) <br  />
 0: Combined Lane Rate of 400Mbps. <br  />
 1: Combined Lane Rate of 320Mbps. <br  />
 2: Combined Lane Rate of 200Mbps. <br  />
 3: Combined Lane Rate of 160Mbps. <br  />
 4: Combined Lane Rate of 100Mbps. <br  />
 (Refer to the ICD for more details about this feature) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>lowPowerCfg</b>  </td><td class="markdownTableBodyNone"><code>Enable/Diable</code>  </td><td class="markdownTableBodyNone">Configuration to enable/disable the power management framework.<br  />
 0 - Disabled <br  />
 1 - Enabled <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="5"><b>factoryCalibcfg</b>  </td><td class="markdownTableBodyNone"><code>Save enable</code>  </td><td class="markdownTableBodyNone">When this option is enabled application will boot-up normally and configure the FECSS to perform all applicable factory calibrations during FECSS initialization. Once the calibrations are performed, application will retrieve the calibration data from FECSS and save it to FLASH. User need to specify valid &lt;flash offset&gt; value. &lt;restore enable&gt; option should be set to 0. <br  />
<b>Note</b> The factory calibration should be done at room temp (25 &deg;C +/- 15 &deg;C)<br  />
 0 - Save Disabled <br  />
 1 - Save Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>restore enable</code>  </td><td class="markdownTableBodyNone">When Restore enabled option is set, application will check the FLASH for a valid calibration data section. If present, it will restore the data from FLASH and provide it to FECSS while configuring it to skip any real-time factory calibrations and use provided calibration data. User need to specify valid &lt;flash offset&gt; value which was used during saving of calibration data. &lt;save enable&gt; option should be set to 0. &lt;rxGain&gt; and &lt;backoff0&gt; arguments will be ignored when restore option is enabled. <br  />
 0 - Restored Disabled <br  />
 1 - Restore Enabled   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>rxGain</code>  </td><td class="markdownTableBodyNone">Recommended value is 30db to 40db.<br  />
 <b>Units</b>: db.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>backoff0</code>  </td><td class="markdownTableBodyNone">TX channel power calibration. Valid Range: 0db to 26db.<br  />
 <b>Units</b>: db.<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>flash offset</code>  </td><td class="markdownTableBodyNone">Address offset in the flash to be used while saving or restoring calibration data. Make sure the address doesn't overlap the location in FLASH where application images are stored and has enough space for saving factory Calibration data. This field is don't care if both save and restore are disabled.Flash address range is 0x0 to 0x1FFFFF (16Mb) Actual Factory calibration data is of size 128 bytes. It is recommended to use last sector of flash memory starting with address 0x1FF000. <br  />
<b>Note</b> Note The flash offset should be greater than 1MB (0x100000h) for EVM. This check is only to make sure Appimage and ATE calibration data is not corrupted.<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>baudRate</b>  </td><td class="markdownTableBodyNone"><code>baudRateVal</code>  </td><td class="markdownTableBodyNone">The sensor starts with 115200 baud rate by default. When this command is sent to the device, the baud rate for the UART communication is updated according to the given value. Currently only <code>baudRateVal</code>=1250000 is supported <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="4"><b>sensorStart</b>  </td><td class="markdownTableBodyNone">'FrameTrigMode'  </td><td class="markdownTableBodyNone">Frame Trigger Mode. <br  />
 0 - Frame SW immediate trigger Mode (SW_TRIG). <br  />
 1 - Frame SW timer based trigger Mode (SW_TIMER_TRIG). <br  />
 2 - Frame HW trigger low power Mode (HW_LOW_PWR_TRIG). <br  />
 3 - Frame HW trigger low jitter Mode (HW_LOW_JIT_TRIG). <br  />
 4 - CW CZ Trigger Mode (CW_CZ_TRIG). <br  />
 5 - Chirp Timer Override Trigger Mode (CT_OVRD_TRIG).<br  />
 (<em>Currently SDK supports only SW_TRIG mode(0)</em>) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">'ChirpStartSigLbE'  </td><td class="markdownTableBodyNone">Chirp Timer (CT) start signal loopback enable control.<br  />
 0 - CHIRP_START_SIGNAL to DIG_SYNC_OUT Loopback Disable <br  />
 1 - CHIRP_START_SIGNAL to DIG_SYNC_OUT Loopback Enable. <br  />
 (<em>Currently SDK supports only Loopback Disable mode(0)</em>) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">'FrameLivMonEn'  </td><td class="markdownTableBodyNone">Frame Live monitors enable control. <br  />
 0 - Live monitor Disabled <br  />
 1 - Synth Frequency Monitor Enabled <br  />
2 - Rx Saturation Live Monitor Enabled <br  />
 3 - Both Synth Frequency Monitor and Rx Saturation Live Monitor Enabled <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">'FrameTrigTimerVal'  </td><td class="markdownTableBodyNone">Frame Trigger Timer Value. 32bit counter value. <br  />
 (<em>Currently SDK demo is tested only with value 0</em>)<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>sensorWarmRst</b>  </td><td class="markdownTableBodyNone"><code>Reserved for future</code>  </td><td class="markdownTableBodyNone">This command initiates a warm reset of sensor with application getting reloaded from flash after reset.<br  />
Important Note: This command is not supported when lowPowerCfg is 1<br  />
   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md784"></a>
Detection layer parameters</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Commands  </th><th class="markdownTableHeadNone">Parameters  </th><th class="markdownTableHeadNone">Notes   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="9"><b>sigProcChainCfg</b>  </td><td class="markdownTableBodyNone"><code>azimuthFftSize</code>  </td><td class="markdownTableBodyNone">Azimuth FFT size. Suggested to set as power of 2<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>elevationFftSize</code>  </td><td class="markdownTableBodyNone">Elevation FFT size. Suggested to set as power of 2<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>motDetMode</code>  </td><td class="markdownTableBodyNone">Major / Minor / AUTO mode selection <br  />
 1 - Major motion detection only <br  />
 2 - Minor motion detection only <br  />
 3 - Auto detection mode.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>coherentDoppler</code>  </td><td class="markdownTableBodyNone">Coherent/Non-coherent Doppler selection <br  />
 0 - Non-coherent integration along Doppler dimension. <br  />
 1 - Select maximum (coherent) peak in Doppler dimension. <br  />
 2 - Non-coherent integration along Doppler used to create detection matrix, and find maximum position to add to detected point.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>numFrmPerMinorMotProc</code>  </td><td class="markdownTableBodyNone">Number of frames included for minor motion detection. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>numMinorMotionChirpsPerFrame</code>  </td><td class="markdownTableBodyNone">Number of chirps (bursts) per frame used for minor motion detection. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>forceMinorMotionVelocityToZero</code>  </td><td class="markdownTableBodyNone">Force Doppler value of detected points tp zero in minor motion detection <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>minorMotionVelocityInclusionThr</code>  </td><td class="markdownTableBodyNone">Minor motion detected points with absolute velocity greater than this threshold are not included in the point cloud list. Threshold is specified in m/sec   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>dopElevDimReductOrder</code>  </td><td class="markdownTableBodyNone">Doppler and elevation dimension reduction order <br  />
 0 - First Doppler, then elevation <br  />
 1 - First elevation, then Doppler <br  />
 <b>Note:</b> This is a optional parameter.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="3"><b>steerVecCorr</b>  </td><td class="markdownTableBodyNone"><code>enableAntSymbGen</code>  </td><td class="markdownTableBodyNone">Enable/Disable the steering vector DPU <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>enableSteerVecCorr</code>  </td><td class="markdownTableBodyNone">Enable/Disable the steering vector correlation <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>enableAngleInterp</code>  </td><td class="markdownTableBodyNone">Enable/Disable the angle interpolation <br  />
 0 - Disabled <br  />
 1 - Enabled <br  />
 <b>Note</b> Only valid on xwrL6432AOP device   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="13"><b>cfarCfg</b>  </td><td class="markdownTableBodyNone"><code>averageMode</code>  </td><td class="markdownTableBodyNone">CFAR Averaging mode selection Recommened to set 2 <br  />
 0 - CFAR-CA <br  />
 1 - CFAR-CAGO <br  />
 2 - CFAR-CASO   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>winLen</code>  </td><td class="markdownTableBodyNone">One-sided noise averaging window length (in samples) of range-CFAR Recommened to set as power of 2<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>guardLen</code>  </td><td class="markdownTableBodyNone">One-sided guard length (in samples) of range-CFAR. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>noiseDiv</code>  </td><td class="markdownTableBodyNone">Cumulative noise sum divisor expressed as a shift. Sum of noise samples is divided by 2^noiseDiv. Suggested to set as log2(winLen).<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>cyclicMode</code>  </td><td class="markdownTableBodyNone">Cyclic mode or wrapped around mode. <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>thresholdScale</code>  </td><td class="markdownTableBodyNone">Threshold factor of range-CFAR in dB scale (20log10). <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>peakGroupingEn</code>  </td><td class="markdownTableBodyNone">Enable or disable Peakgrouping <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>sideLobeThreshold</code>  </td><td class="markdownTableBodyNone">Sidelobe threshold (in linear scale) in azimuth domain to declare a local peak as a valid detection. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>localMaxRangeDomain</code>  </td><td class="markdownTableBodyNone">Enable/disable selection of the local maximum in the range domain <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>localMaxAzimuthDomain</code>  </td><td class="markdownTableBodyNone">Enable/disable selection of the local maximum in the Angle domain <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>interpolateRange</code>  </td><td class="markdownTableBodyNone">Enable /disable the interpolation of the range <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>interpolateAzimuthDomain</code>  </td><td class="markdownTableBodyNone">Enable /disable the interpolation of the Azimuth <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>lookUpTableCorrectAzimuthDom</code>  </td><td class="markdownTableBodyNone">Enable /disable the Angle correction using Lookup Table Approach <br  />
 0 - Disabled <br  />
 1 - Enabled <br  />
 <b>Note:</b> This is a optional parameter.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="10"><b>rangeSNRCompensation</b>  </td><td class="markdownTableBodyNone"><code>enabled</code>  </td><td class="markdownTableBodyNone">Enable/Disable the rangeSNRCompensation <br  />
 0 - Disabled <br  />
 1 - Enabled <br  />
 Refer to <a class="el" href="MOTION_AND_PRESENCE_DETECTION_DEMO.html#RANGE_ANGLE_SNR">Variable SNR detection thresholds</a> for more details.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>compensationRange</code>  </td><td class="markdownTableBodyNone">The range from the radar in meters at which points with SNR values above the detection threshold (specified by compensationSNR) should be retained. Points with SNR values below this threshold at this range are discarded.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>compensationSNR</code>  </td><td class="markdownTableBodyNone">The minimum SNR value needed for a point to be considered a detection at the compensationRange. Points with SNR values below the compensationSNR at the compensationRange are discarded.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>minimumCompensationDistance</code>  </td><td class="markdownTableBodyNone">Range in meters at which the compensation value saturates at the SNR corresponding to the SNR at minimumCompensationDistance away. <br  />
 <b>Note:</b> This is a optional parameter.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>maximumCompensationDistance</code>  </td><td class="markdownTableBodyNone">Range in meters at which the compensation value saturates at the SNR corresponding to the SNR at maximumCompensationDistance away. <br  />
 <b>Note:</b> This is a optional parameter.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>minimumCompensationAngle</code>  </td><td class="markdownTableBodyNone">Minimum angle in degrees where the compensation is applied. If not populated, the compensations is applied throughout the entire field of view. If populated, points whose azimuth angle is less than this value will be detected with the cfarCfg‚Äôs threshold value or the secondary compensation threshold (if enabled). <br  />
 <b>Note:</b> This is a optional parameter.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>maximumCompensationAngle</code>  </td><td class="markdownTableBodyNone">Maximum angle in degrees where the compensation is applied. If not populated, the compensations is applied throughout the entire field of view. If populated, points whose azimuth angle is greater than this value will be detected with the cfarCfg‚Äôs threshold value or the secondary compensation threshold (if enabled). <br  />
 <b>Note:</b> This is a optional parameter.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>secondaryMinimumCompensationAngle</code>  </td><td class="markdownTableBodyNone">Minimum angle in degrees where the 2nd pass compensation is applied. If not populated, no second pass compensation occurs. If populated, points whose azimuth angle is less than this value will be detected with the cfarCfg‚Äôs threshold value. <br  />
 <b>Note:</b> This is a optional parameter.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>secondaryMaximumCompensationAngle</code>  </td><td class="markdownTableBodyNone">Maximum angle in degrees where the 2nd pass compensation is applied. If not populated, no second pass compensation occurs. If populated, points whose azimuth angle is greater than this value will be detected with the cfarCfg‚Äôs threshold value. <br  />
 <b>Note:</b> This is a optional parameter.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>secondaryCompensationSNRDelta</code>  </td><td class="markdownTableBodyNone">The difference between the primary and secondary SNR compensations in dB. <br  />
 <b>Note:</b> This is a optional parameter.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="4"><b>aoaFovCfg</b>  </td><td class="markdownTableBodyNone"><code>minAzimuthDeg</code>  </td><td class="markdownTableBodyNone">Minimum azimuth angle (in degrees) that specifies the start of field of view <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>maxAzimuthDeg</code>  </td><td class="markdownTableBodyNone">Maximum azimuth angle (in degrees) that specifies the end of field of view <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>minElevationDeg</code>  </td><td class="markdownTableBodyNone">Minimum elevation angle (in degrees) that specifies the start of field of view <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>maxElevationDeg</code>  </td><td class="markdownTableBodyNone">Maximum elevation angle (in degrees) that specifies the end of field of view <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="2"><b>rangeSelCfg</b>  </td><td class="markdownTableBodyNone"><code>minMeters</code>  </td><td class="markdownTableBodyNone">Minimum range of exported detected points <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>maxMeters</code>  </td><td class="markdownTableBodyNone">Maximum range of exported detected points<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>clutterRemoval</b>  </td><td class="markdownTableBodyNone"><code>enabled</code>  </td><td class="markdownTableBodyNone">Configure the static clutter removal <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="7"><b>compRangeBiasAndRxChanPhase</b>  </td><td class="markdownTableBodyNone"><code>rangeBias</code>  </td><td class="markdownTableBodyNone">Value of the Range Bias (m).<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>virtAntIdx 1</code>  </td><td class="markdownTableBodyNone">Phase compensation factor (real, imaginary) of virtual antenna 1. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>virtAntIdx 2</code>  </td><td class="markdownTableBodyNone">Phase compensation factor (real, imaginary) of virtual antenna 2. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>virtAntIdx 3</code>  </td><td class="markdownTableBodyNone">Phase compensation factor (real, imaginary) of virtual antenna 3. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>virtAntIdx 4</code>  </td><td class="markdownTableBodyNone">Phase compensation factor (real, imaginary) of virtual antenna 4. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>virtAntIdx 5</code>  </td><td class="markdownTableBodyNone">Phase compensation factor (real, imaginary) of virtual antenna 5. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>virtAntIdx 6</code>  </td><td class="markdownTableBodyNone">Phase compensation factor (real, imaginary) of virtual antenna 6. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="3"><b>measureRangeBiasAndRxChanPhase</b>  </td><td class="markdownTableBodyNone"><code>enabled</code>  </td><td class="markdownTableBodyNone">Enable measurement of the range bias and rx channel gain and phase imperfections <br  />
 0 - Disabled <br  />
 1 - Enabled <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>targetDistance</code>  </td><td class="markdownTableBodyNone">Distance in meters where strong reflector is located to be used as test object for measurement. This field is only used when measurement mode is enabled. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>searchWin</code>  </td><td class="markdownTableBodyNone">Distance in meters of the search window around <code>targetDistance</code> where the peak will be searched <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="13"><b>guiMonitor</b>  </td><td class="markdownTableBodyNone"><code>pointCloud</code>  </td><td class="markdownTableBodyNone">Enable/Disable the transmission of the point cloud data <br  />
 0 - Disable <br  />
 1 - Enable, point cloud in floating point format, plus side information, <br  />
 2 - Enable, point cloud in compressed format (fixed point)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>rangeProfile</code>  </td><td class="markdownTableBodyNone">Enable/Disable the transmission of the Range Profile data <br  />
 0 - Disable <br  />
 1 - Enable, range profile from Major mode detection <br  />
 2 - Enable, range profile from Minor mode detection <br  />
 3 - Enable, both range profiles   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>NoiseProfile</code>  </td><td class="markdownTableBodyNone">Not used in the current SDK <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>rangeAzimuthHeatMap</code>  </td><td class="markdownTableBodyNone">Enable/Disable transmission of the Range Azimuth heatmap <br  />
 0 - Disable <br  />
 1 - Enable, heatmap from Major mode detection <br  />
 2 - Enable, heatmap from Minor mode detection <br  />
 3 - Enable, both heatmaps   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>rangeDopplerHeatMap</code>  </td><td class="markdownTableBodyNone">Not used in the current SDK <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>statsInfo</code>  </td><td class="markdownTableBodyNone">Enable/Disable the transmission of the Statistics info that include processing time, temperature, power. (<em>Partially supported in the current SDK</em>) <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>presenceInfo</code>  </td><td class="markdownTableBodyNone">Enable/Disable the transmission of the presence detection information <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>adcSamples</code>  </td><td class="markdownTableBodyNone">Enable/Disable the transmission of the raw ADC samples of the last two chirps of the frame <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>trackerInfo</code>  </td><td class="markdownTableBodyNone">Enable/Disable the transmission of the group tracker information <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>microDopplerInfo</code>  </td><td class="markdownTableBodyNone">Enable/Disable the transmission of the micro-Doppler information <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>classifierInfo</code>  </td><td class="markdownTableBodyNone">Enable/Disable the transmission of the classifier information <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>quickEvalInfo</code>  </td><td class="markdownTableBodyNone">Enable/Disable the quick eval plots. The quick eval plots the presence info and is not useful without it being enabled <br  />
 0 - Disabled <br  />
 1 - Enabled   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>pointCloudAntennaSymbols</code>  </td><td class="markdownTableBodyNone">Enable/Disable the point cloud antenna symbol information <br  />
 0 - Disabled <br  />
 1 - Enabled <br  />
 <b>Note</b> Only valid when steering vectors are enabled on xwrL6432AOP device and this is a optional parameter.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="14"><b>antGeometryCfg</b>  </td><td class="markdownTableBodyNone"><code>vAnt1_row</code>  </td><td class="markdownTableBodyNone">row index of virtual antenna 1. (TxAnt1-&gt;RxAnt1) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vAnt1_col</code>  </td><td class="markdownTableBodyNone">column index of virtual antenna 1. (TxAnt1-&gt;RxAnt1) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vAnt2_row</code>  </td><td class="markdownTableBodyNone">row index of virtual antenna 2. (TxAnt1-&gt;RxAnt2) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vAnt2_col</code>  </td><td class="markdownTableBodyNone">column index of virtual antenna 2. (TxAnt1-&gt;RxAnt2) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vAnt3_row</code>  </td><td class="markdownTableBodyNone">row index of virtual antenna 3. (TxAnt1-&gt;RxAnt3) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vAnt3_col</code>  </td><td class="markdownTableBodyNone">column index of virtual antenna 3. (TxAnt1-&gt;RxAnt3) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vAnt4_row</code>  </td><td class="markdownTableBodyNone">row index of virtual antenna 4. (TxAnt2-&gt;RxAnt1) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vAnt4_col</code>  </td><td class="markdownTableBodyNone">column index of virtual antenna 4. (TxAnt2-&gt;RxAnt1) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vAnt5_row</code>  </td><td class="markdownTableBodyNone">row index of virtual antenna 5. (TxAnt2-&gt;RxAnt2) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vAnt5_col</code>  </td><td class="markdownTableBodyNone">column index of virtual antenna 5. (TxAnt2-&gt;RxAnt2) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>vAnt6_row</code>  </td><td class="markdownTableBodyNone">row index of virtual antenna 6. (TxAnt2-&gt;RxAnt3) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>vAnt6_col</code>  </td><td class="markdownTableBodyNone">column index of virtual antenna 6. (TxAnt2-&gt;RxAnt3) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>antDistX</code>  </td><td class="markdownTableBodyNone">Antenna spacing in X dimension in mm. This is optional argument. If omitted, it is assumed that &lambda;/d<sub>x</sub>=2 <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>antDistZ</code>  </td><td class="markdownTableBodyNone">Antenna spacing in Z dimension in mm. This is optional argument. If omitted, it is assumed that &lambda;/d<sub>z</sub>=2 <br  />
   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md785"></a>
Motion/presence detection layer</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Commands  </th><th class="markdownTableHeadNone">Parameters  </th><th class="markdownTableHeadNone">Notes   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="7"><b>mpdBoundaryBox</b>  </td><td class="markdownTableBodyNone"><code>Zone</code>  </td><td class="markdownTableBodyNone">Zone: This command is used to describe the boundary of each zone. (<em>Upto twelve zones are permitted in current SDK</em>) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>x-min</code>  </td><td class="markdownTableBodyNone">x-min <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>x-max</code>  </td><td class="markdownTableBodyNone">x-max <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>y-min</code>  </td><td class="markdownTableBodyNone">y-min <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>y-max</code>  </td><td class="markdownTableBodyNone">y-max <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>z-min</code>  </td><td class="markdownTableBodyNone">z-min <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>z-max</code>  </td><td class="markdownTableBodyNone">z-max <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="5"><b>sensorPosition</b>  </td><td class="markdownTableBodyNone"><code>xOffset</code>  </td><td class="markdownTableBodyNone">Offset of the radar sensor position in x-axis referenced to the boundary box origin. (m) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>yOffset</code>  </td><td class="markdownTableBodyNone">Offset of the radar sensor position in y-axis referenced to the boundary box origin. (m) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>zOffset</code>  </td><td class="markdownTableBodyNone">Height of the radar sensor above the ground plane. (m) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>azimTilt</code>  </td><td class="markdownTableBodyNone">The azimuth tilt (in degrees)of the sensor about the axis Zw. A positive value indicates clockwise rotation when viewing towards the ground. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>elevTilt</code>  </td><td class="markdownTableBodyNone">The elevation tilt (in degrees)of the sensor about the axis Xw. A positive value indicates tilt towards the ground. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="8"><b>majorStateCfg</b>  </td><td class="markdownTableBodyNone"><code>pointThre1</code>  </td><td class="markdownTableBodyNone">Number of detected points (in a single frame) needed in a zone to enter the motion/presence state. If the number of points exceed this threshold, no need to check the SNR. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>pointThre2</code>  </td><td class="markdownTableBodyNone">Number of detected points (in a single frame) needed in a zone to enter the motion/presence state. If the number of points exceeds this threshold, the snrThre2 criteria is checked. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>snrThre2</code>  </td><td class="markdownTableBodyNone">Minimum total SNR (linear) of detected points (in a single frame) in a zone to enter the motion/presence state if the pointThre2 criteria is also satisfied. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>pointHistThre1</code>  </td><td class="markdownTableBodyNone">Number of detected points (in a frame history buffer) needed in a zone to enter the motion/presence state. If the number of points exceed this threshold, no need to check the SNR. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>pointHistThre2</code>  </td><td class="markdownTableBodyNone">Number of detected points (in a frame history buffer) needed in a zone to enter the motion/presence state. If the number of points exceeds this threshold, the snrHistThre2 criteria is checked. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>snrHistThre2</code>  </td><td class="markdownTableBodyNone">Minimum total SNR (linear) of detected points (in a frame history buffer) in a zone to enter the motion/presence state if the pointHistThre2 criteria is also satisfied. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>histBufferSize</code>  </td><td class="markdownTableBodyNone">Size of the frame history buffer size (in frames) used in pointHistThre1, pointHistThre2, and snrHistThre2 parameters. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>major2minorThre</code>  </td><td class="markdownTableBodyNone">A motion status is preserved if it recorded at least one motion detection in the last major2minorThre frames. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="8"><b>minorStateCfg</b>  </td><td class="markdownTableBodyNone"><code>pointThre1</code>  </td><td class="markdownTableBodyNone">Number of detected points (in a single frame) needed in a zone to enter the motion/presence state. If the number of points exceed this threshold, no need to check the SNR. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>pointThre2</code>  </td><td class="markdownTableBodyNone">Number of detected points (in a single frame) needed in a zone to enter the motion/presence state. If the number of points exceeds this threshold, the snrThre2 criteria is checked. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>snrThre2</code>  </td><td class="markdownTableBodyNone">Minimum total SNR (linear) of detected points (in a single frame) in a zone to enter the motion/presence state if the pointThre2 criteria is also satisfied. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>pointHistThre1</code>  </td><td class="markdownTableBodyNone">Number of detected points (in a frame history buffer) needed in a zone to enter the motion/presence state. If the number of points exceed this threshold, no need to check the SNR. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>pointHistThre2</code>  </td><td class="markdownTableBodyNone">Number of detected points (in a frame history buffer) needed in a zone to enter the motion/presence state. If the number of points exceeds this threshold, the snrHistThre2 criteria is checked. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>snrHistThre2</code>  </td><td class="markdownTableBodyNone">Minimum total SNR (linear) of detected points (in a frame history buffer) in a zone to enter the motion/presence state if the pointHistThre2 criteria is also satisfied. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>histBufferSize</code>  </td><td class="markdownTableBodyNone">Size of the frame history buffer size (in frames) used in pointHistThre1, pointHistThre2, and snrHistThre2 parameters. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>minor2emptyThre</code>  </td><td class="markdownTableBodyNone">A motion status is preserved if it recorded at least one motion detection in the last minor2emptyThre frames. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="3"><b>clusterCfg</b>  </td><td class="markdownTableBodyNone"><code>enabled</code>  </td><td class="markdownTableBodyNone">Configure clustering logic. <br  />
 0: Disable. <br  />
 1: Enable.<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>maxDistance</code>  </td><td class="markdownTableBodyNone">The radius (in meters) of the neighborhood around a point (i.e., epsilon in DBSCAN algorithm). Note that the distance measure only takes the geometric difference between the point and centroid into account. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>x-max</code>  </td><td class="markdownTableBodyNone">Minimum number of neighbor points required within the epsilon radius around point. <br  />
   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md786"></a>
Tracking layer parameters</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Commands  </th><th class="markdownTableHeadNone">Parameters  </th><th class="markdownTableHeadNone">Notes   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="6"><b>boundaryBox</b>  </td><td class="markdownTableBodyNone"><code>x-min</code>  </td><td class="markdownTableBodyNone">Minimum distance in x-dimension with respect to the origin in the World co-ordinates <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>x-max</code>  </td><td class="markdownTableBodyNone">Maximum distance in x-dimension with respect to the origin in the World co-ordinates <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>y-min</code>  </td><td class="markdownTableBodyNone">Minimum distance in y-dimension with respect to the origin in the World co-ordinates <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>y-max</code>  </td><td class="markdownTableBodyNone">Maximum distance in y-dimension with respect to the origin in the World co-ordinates <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>z-min</code>  </td><td class="markdownTableBodyNone">Minimum distance in z-dimension with respect to the origin in the World co-ordinates <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>z-max</code>  </td><td class="markdownTableBodyNone">Maximum distance in z-dimension with respect to the origin in the World co-ordinates <br  />
Note that Z = 0 corresponds to the ground plane.<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="6"><b>staticBoundaryBox</b>  </td><td class="markdownTableBodyNone"><code>x-min</code>  </td><td class="markdownTableBodyNone">Minimum distance in x-dimension with respect to the origin in the World co-ordinates <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>x-max</code>  </td><td class="markdownTableBodyNone">Maximum distance in x-dimension with respect to the origin in the World co-ordinates <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>y-min</code>  </td><td class="markdownTableBodyNone">Minimum distance in y-dimension with respect to the origin in the World co-ordinates <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>y-max</code>  </td><td class="markdownTableBodyNone">Maximum distance in y-dimension with respect to the origin in the World co-ordinates <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>z-min</code>  </td><td class="markdownTableBodyNone">Minimum distance in z-dimension with respect to the origin in the World co-ordinates <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>z-max</code>  </td><td class="markdownTableBodyNone">Maximum distance in z-dimension with respect to the origin in the World co-ordinates <br  />
Note that Z = 0 corresponds to the ground plane.<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="5"><b>sensorPosition</b>  </td><td class="markdownTableBodyNone"><code>xOffset</code>  </td><td class="markdownTableBodyNone">Offset of the radar sensor position in x-axis referenced to the boundary box origin. (m) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>yOffset</code>  </td><td class="markdownTableBodyNone">Offset of the radar sensor position in y-axis referenced to the boundary box origin. (m) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>zOffset</code>  </td><td class="markdownTableBodyNone">Height of the radar sensor above the ground plane. (m) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>azimTilt</code>  </td><td class="markdownTableBodyNone">The azimuth tilt (in degrees)of the sensor about the axis Zw. A positive value indicates clockwise rotation when viewing towards the ground. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>elevTilt</code>  </td><td class="markdownTableBodyNone">The elevation tilt (in degrees)of the sensor about the axis Xw. A positive value indicates tilt towards the ground. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="6"><b>presenceBoundaryBox</b>  </td><td class="markdownTableBodyNone"><code>x-min</code>  </td><td class="markdownTableBodyNone">Minimum distance in x-dimension with respect to the origin in the World co-ordinates <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>x-max</code>  </td><td class="markdownTableBodyNone">Maximum distance in x-dimension with respect to the origin in the World co-ordinates <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>y-min</code>  </td><td class="markdownTableBodyNone">Minimum distance in y-dimension with respect to the origin in the World co-ordinates <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>y-max</code>  </td><td class="markdownTableBodyNone">Maximum distance in y-dimension with respect to the origin in the World co-ordinates <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>z-min</code>  </td><td class="markdownTableBodyNone">Minimum distance in z-dimension with respect to the origin in the World co-ordinates <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>z-max</code>  </td><td class="markdownTableBodyNone">Maximum distance in z-dimension with respect to the origin in the World co-ordinates <br  />
Note that Z = 0 corresponds to the ground plane.<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="5"><b>gatingParam</b>  </td><td class="markdownTableBodyNone"><code>Gain</code>  </td><td class="markdownTableBodyNone">Gain of the gating function. It is set based on expected tracking errors and uncertainties of detection layer <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Limit-Width</code>  </td><td class="markdownTableBodyNone">Gating Limit in Width (m). It is set based on the physical dimensions and agility of the targets <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Limit-Depth</code>  </td><td class="markdownTableBodyNone">Gating Limit in Depth (m). It is set based on the physical dimensions and agility of the targets <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Limit-Height</code>  </td><td class="markdownTableBodyNone">Gating Limit in Height (m). It is set based on the physical dimensions and agility of the targets <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Limit-Velocity</code>  </td><td class="markdownTableBodyNone">Gating Limit in (radial) Velocity (m/s). It is set based on the motion of the targets <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="6"><b>allocationParam</b>  </td><td class="markdownTableBodyNone"><code>snrThre</code>  </td><td class="markdownTableBodyNone">Minimum total SNR for the allocation set <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>snrThreObscured</code>  </td><td class="markdownTableBodyNone">Minimum total SNR for the allocation set when obscured by another target <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>velocityThre</code>  </td><td class="markdownTableBodyNone">Minimum radial velocity of the allocation set centroid (m/s) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>pointsThre</code>  </td><td class="markdownTableBodyNone">Minimum number of points in the allocation set <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>maxDistanceThre</code>  </td><td class="markdownTableBodyNone">Maximum squared distance between candidate centroid and centroid to be part of the allocation set (m^2) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>maxVelThre</code>  </td><td class="markdownTableBodyNone">Maximum velocity difference between candidate and centroid to be part of the allocation set (m/s) <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="6"><b>stateParam</b>  </td><td class="markdownTableBodyNone"><code>det2actThre</code>  </td><td class="markdownTableBodyNone">In DETECT state; threshold for the number of continuous HIT events to transition from DETECT to ACTIVE state (number of frames) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>det2freeThre</code>  </td><td class="markdownTableBodyNone">In DETECT state; threshold for the number of continuous MISS events to transition from DETECT to FREE state (number of frames)<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>active2freeThre</code>  </td><td class="markdownTableBodyNone">In ACTIVE state and NORMAL condition; threshold for the number of consecutive MISS events needed to transition from ACTIVE to FREE state (number of frames)<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>static2freeThre</code>  </td><td class="markdownTableBodyNone">In ACTIVE state and STATIC condition; threshold for the number of continuous MISS events for a STATIC target in a static zone to transition from ACTIVE to FREE state (number of frames)<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>exit2freeThre</code>  </td><td class="markdownTableBodyNone">In ACTIVE state and EXIT condition; threshold for the number of continuous MISS events for a target outside the static zone to transition from ACTIVE to FREE state. Determines the Maximum lifespan for the target outside the static box (number of frames)<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>sleep2freeThre</code>  </td><td class="markdownTableBodyNone">Determines the Maximum lifespan for the target inside the static box (number of frames)<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="3"><b>maxAcceleration</b>  </td><td class="markdownTableBodyNone"><code>MaxAccel-X-direction</code>  </td><td class="markdownTableBodyNone">Maximum amount that the target acceleration is expected to change in the X-direction between time-periods (m/s^2)<br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>MaxAccel-Y-direction</code>  </td><td class="markdownTableBodyNone">Maximum amount that the target acceleration is expected to change in the Y-direction between time-periods (m/s^2)<br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>MaxAccel-Z-direction</code>  </td><td class="markdownTableBodyNone">Maximum amount that the target acceleration is expected to change in the Z-direction in between time-periods (m/s^2) <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="5"><b>trackingCfg</b>  </td><td class="markdownTableBodyNone"><code>enable</code>  </td><td class="markdownTableBodyNone">Group tracker processing enable/disable flag: <br  />
 0 - Disabled <br  />
 1 - Enabled <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>IntialConfigParams</code>  </td><td class="markdownTableBodyNone">An index to the default internal tracker parameter structure array that initializes the tracker configurations for different use-cases. These internal tracker parameters will be used by default if the user does not set these through the corresponding CLI command <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>maxNumPoints</code>  </td><td class="markdownTableBodyNone">Maximum number of Detection points per frame <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>maxNumTracks</code>  </td><td class="markdownTableBodyNone">Maximum number of Targets to track at any given time <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>boresightFilteringEnable</code>  </td><td class="markdownTableBodyNone">Boresight filtering enable/disable flag: <br  />
 0 - Disabled <br  />
 1 - Enabled <br  />
 <b>Note:</b> The parameters from previous SDK versions are now automatically calculated by the software.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md787"></a>
Classification layer parameters</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Commands  </th><th class="markdownTableHeadNone">Parameters  </th><th class="markdownTableHeadNone">Notes   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="9"><b>microDopplerCfg</b>  </td><td class="markdownTableBodyNone"><code>enabled</code>  </td><td class="markdownTableBodyNone">Micro-Doppler (¬µ-Doppler) and feature extraction processing enable/disable flag:<br  />
 0 - Disabled <br  />
 1 - Enabled <br  />
 (<em>For detailed information refer to Parameter Tuning and Customization Guide</em>)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>genApproach</code>  </td><td class="markdownTableBodyNone">The angle spectrum generation approach (in the azimuth domain) when creating the ¬µ-Doppler spectrum per track: <br  />
 0 - FFT <br  />
 1 - Beamforming   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>targetSize</code>  </td><td class="markdownTableBodyNone">The target size (in xy-domain) to be used to when extracting the ¬µ-Doppler around the corresponding centroid. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>magnitudeSquared</code>  </td><td class="markdownTableBodyNone">If this flag is enabled, the generated ¬µ-Doppler spectrum will be magnitude squared:<br  />
 0: Keep the magnitude spectrum as is.<br  />
 1: Take the magnitude square (i.e., power spectrum).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>circShiftCentroid</code>  </td><td class="markdownTableBodyNone">If this flag is enabled, the generated ¬µ-Doppler spectrum will be circularly shifted around the estimated target velocity provided by the tracker: <br  />
 0: Keep the ¬µ-Doppler spectrum as is.&lt;br&gt; 1: Circularly shift the ¬µ-Doppler spectrum around the estimated target velocity from the tracker.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>normalizedSpectrum</code>  </td><td class="markdownTableBodyNone">If this flag is enabled, the generated ¬µ-Doppler spectrum will be normalized between [0 1]: <br  />
 0: Keep the ¬µ-Doppler spectrum as is. <br  />
 1: Normalize the ¬µ-Doppler spectrum between [0 1].   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>interceptThrLowFreq</code>  </td><td class="markdownTableBodyNone">The power ratio (%) used to compute the lower envelope (Dlow) feature from the ¬µ-Doppler spectrum. This parameter is common for all the tracked objects. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>interceptThrUpFreq</code>  </td><td class="markdownTableBodyNone">The power ratio (%) used to compute the upper envelope (Dup) feature from the ¬µ-Doppler spectrum. This parameter is common for all the tracked objects. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>specShiftMode</code>  </td><td class="markdownTableBodyNone">If this flag is enabled, the generated ¬µ-Doppler spectrum will be circularly shifted around the mean Doppler: <br  />
 0: Keep the ¬µ-Doppler spectrum as is. <br  />
 1: Circularly shift the ¬µ-Doppler spectrum around the mean Doppler.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone" rowspan="3"><b>classifierCfg</b>  </td><td class="markdownTableBodyNone"><code>enabled</code>  </td><td class="markdownTableBodyNone">Classifier processing enable/disable flag: <br  />
 0: Disable. <br  />
 1: Enable.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>minNumPntsPerTrack</code>  </td><td class="markdownTableBodyNone">Minimum number of points required for a track to run the classifier for it. <br  />
   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>missTotFrmThre</code>  </td><td class="markdownTableBodyNone">The maximum number of frames allowed which do not have enough number of points for a specific track. <br  />
   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md788"></a>
Profile switching parameters</h2>
<p>This configuration enables dynamic switching between high performance tracker configuration, processing and low power presence detection based on a state machine. </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Commands  </th><th class="markdownTableHeadNone">Parameters  </th><th class="markdownTableHeadNone">Notes   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone" rowspan="3"><b>profileSwitchCfg</b>  </td><td class="markdownTableBodyNone"><code>switchCfgEnable</code>  </td><td class="markdownTableBodyNone">Profile switch enable: <br  />
 0: Disable. <br  />
 1: Enable. <br  />
 Enabling low power mode in lowPowerCfg CLI is a prerequisite to enable this feature.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>frmPretoTrack</code>  </td><td class="markdownTableBodyNone">Threshold on number of frames for switching from presence to tracker state. <br  />
   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>frmTracktoPre</code>  </td><td class="markdownTableBodyNone">Threshold on number of frames for switching from tracker to presence state. <br  />
   </td></tr>
</table>
<p>Refer <b>${SDK_INSTALL_PATH}/docs/Motion_Presence_Detection_Demo_Tuning_Guide.pdf</b> and <b>${SDK_INSTALL_PATH}/docs/Motion_Presence_Detection_Demo_Group_Tracker_Tuning_Guide.pdf</b> document for Parameter tuning and customization of Demo application.</p>
<h1><a class="anchor" id="autotoc_md789"></a>
UART and Output to the Host</h1>
<h2><a class="anchor" id="autotoc_md790"></a>
Output TLV Description</h2>
<p>The packet structure consists of fixed sized frame header, followed by variable number of TLVs (see Figure below). Each TLV has fixed header followed by variable size payload. The Byte order is Little Endian.</p>
<p> <style>div.image img[src="mpd_datapacket.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_datapacket.png" alt=""/>
<div class="caption">
Data packet structure sent to Host.</div></div>
<h3><a class="anchor" id="autotoc_md791"></a>
Frame Header Structure</h3>
<p>The frame header is of fixed size (40bytes). It is defined by the structure as</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>MmwDemo_output_message_header_t</div>
<div class="line">{</div>
<div class="line">uint16_t magicWord[4]; <span class="comment">/* Sync word: {0x0102,0x0304,0x0506,0x0708} */</span></div>
<div class="line">uint32_t version; <span class="comment">/* MajorNum*2^24+MinorNum*2^16+BugfixNum*2^8+BuildNum */</span></div>
<div class="line">uint32_t totalPacketLen; <span class="comment">/* Total packet length including header in Bytes */</span></div>
<div class="line">uint32_t platform; <span class="comment">/* platform type */</span></div>
<div class="line">uint32_t frameNumber; <span class="comment">/* Frame number */</span></div>
<div class="line">uint32_t timeCpuCycles; <span class="comment">/* Time in CPU cycles when the message was created */</span></div>
<div class="line">uint32_t numDetectedObj; <span class="comment">/* Number of detected objects */</span></div>
<div class="line">uint32_t numTLVs; <span class="comment">/* Number of TLVs */</span></div>
<div class="line">uint32_t subFrameNumber; <span class="comment">/* Subframe number */</span></div>
<div class="line">} MmwDemo_output_message_header;</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md792"></a>
TLV Structure</h3>
<p>The TLV structure consists of a fixed header, TL (8bytes) followed by TLV specific payload. The TLV header structure is shown below.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>MmwDemo_output_message_tl_t</div>
<div class="line">{</div>
<div class="line">uint32_t type; <span class="comment">/* TLV type */</span></div>
<div class="line">uint32_t length; <span class="comment">/* Length in bytes */</span></div>
<div class="line">} MmwDemo_output_message_tl;</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md793"></a>
Point Cloud TLV</h3>
<p>Motion detection demo outputs point cloud data in one of the two formats, floating point format and more compressed fixed point format. The format option is selected from the CLI configuration.</p>
<h4><a class="anchor" id="autotoc_md794"></a>
Floating point format</h4>
<p>The point cloud data are sent using two TLV elements, first one with the detected point cartesian coordinates and the radial velocity, and the second one, this side information, the detected point snr and noise.</p>
<p><a class="anchor" id="autotoc_md795"></a></p><h5>Point Cloud ‚Äì Coordinates TLV</h5>
<ul>
<li>Type = MMWDEMO_OUTPUT_MSG_DETECTED_POINTS</li>
<li>Length = sizeof(DPIF_PointCloudCartesian) * numberOfPoints</li>
</ul>
<p>The single point is defined as:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>DPIF_PointCloudCartesian_t</div>
<div class="line">{</div>
<div class="line"><span class="keywordtype">float</span> x; <span class="comment">/* x - coordinate in meters. */</span></div>
<div class="line"><span class="keywordtype">float</span> y; <span class="comment">/* y - coordinate in meters. */</span></div>
<div class="line"><span class="keywordtype">float</span> z; <span class="comment">/* z - coordinate in meters. */</span></div>
<div class="line"><span class="keywordtype">float</span> velocity; <span class="comment">/* radial velocity away from sensor in m/s */</span></div>
<div class="line">} DPIF_PointCloudCartesian;</div>
</div><!-- fragment --><p> <a class="anchor" id="autotoc_md796"></a></p><h5>Point Cloud - Side information TLV</h5>
<ul>
<li>Type = MMWDEMO_OUTPUT_MSG_DETECTED_POINTS_SIDE_INFO</li>
<li>Length = sizeof(DPIF_PointCloudSideInfo) * numberOfPoints</li>
</ul>
<p>The single point side info is defined as:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>DPIF_PointCloudSideInfo_t</div>
<div class="line">{</div>
<div class="line">int16_t snr; <span class="comment">/* snr - CFAR cell to side noise ratio in dB, 1LSB = 0.1dB */</span></div>
<div class="line">int16_t noise; <span class="comment">/* noise level of side of detected cell in dB, 1LSB = 0.1dB */</span></div>
<div class="line">} DPIF_PointCloudSideInfo;</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md797"></a>
Fix-point format</h4>
<ul>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_DETECTED_POINTS</li>
<li>Length = sizeof (MmwDemo_output_message_point_uint) + sizeof (MmwDemo_output_message_UARTpoint) * numberOfPoints</li>
</ul>
<p>The unit structure is defined as:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>MmwDemo_output_message_point_uint_t</div>
<div class="line">{</div>
<div class="line"><span class="keywordtype">float</span> xyzUnit; <span class="comment">/* x/y/z coordinates reporting unit, in m */</span></div>
<div class="line"><span class="keywordtype">float</span> dopplerUnit; <span class="comment">/* radial velocity reporting unit, in m/s */</span></div>
<div class="line"><span class="keywordtype">float</span> snrUint; <span class="comment">/* SNR reporting unit, in dB */</span></div>
<div class="line"><span class="keywordtype">float</span> noiseUint; <span class="comment">/* Noise reporting unit, in dB */</span></div>
<div class="line">uint16_t numDetectedPoints[2]; <span class="comment">/* number of detected points in [0]-major and [1]-minor motion mode */</span></div>
<div class="line">} MmwDemo_output_message_point_uint;</div>
</div><!-- fragment --><p> The single point is defined as:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>MmwDemo_output_message_UARTpoint_t</div>
<div class="line">{</div>
<div class="line">int16_t x; <span class="comment">/* Detected point x, 1LSB = xyzUnit */</span></div>
<div class="line">int16_t y; <span class="comment">/* Detected point y, 1LSB = xyzUnit */</span></div>
<div class="line">int16_t z; <span class="comment">/* Detected point z, 1LSB = xyzUnit */</span></div>
<div class="line">int16_t doppler; <span class="comment">/* Detected point radial velocity, 1LSB = dopplerUnit */</span></div>
<div class="line">uint8_t snr; <span class="comment">/* Range detection SNR, 1LSB = snrUnit */</span></div>
<div class="line">uint8_t noise; <span class="comment">/* Detected point noise value 1LSB = noiseUnit */</span></div>
<div class="line">} MmwDemo_output_message_UARTpoint;</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md798"></a>
Range Profile TLV</h3>
<p>This TLV contains the range profile, specified as an array of 32-bit unsigned linear values of range bins. The length is equal to number of range bin elements, (half of the range FFT size, since the ADC samples are real).</p>
<ul>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_RANGE_PROFILE_MAJOR, or MMWDEMO_OUTPUT_EXT_MSG_RANGE_PROFILE_MINOR</li>
<li>Length = sizeof(uint32_t) * numberOfRangeBins</li>
</ul>
<h3><a class="anchor" id="autotoc_md799"></a>
Detection heatmap TLV</h3>
<p>This TLV contains the range-azimuth detection matrix (heatmap) which consists of two dimensional array of 32-bit unsigned magnitude values. The matrix is arranged as X[rangeInd*azimuthFftSize + azimuthInd], rangeInd = 0, numRangeBins - 1, azimuthInd = 0, azimuthFftSize ‚Äì 1</p>
<ul>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_RANGE_AZIMUT_HEAT_MAP_MAJOR, or MMWDEMO_OUTPUT_EXT_MSG_RANGE_AZIMUT_HEAT_MAP_MINOR</li>
<li>Length = sizeof(uint32_t) * numberOfRangeBins * numAzimuthBins</li>
</ul>
<h3><a class="anchor" id="autotoc_md800"></a>
Presence Detection TLV</h3>
<p>This TLV contains the presence information for number of zones defined in the radar scene. The information for each zone is represented with 2 bits, packed in bytes starting from LSB position towards MSB.</p>
<ul>
<li>0 ‚Äì no detection</li>
<li>1 ‚Äì minor motion detected</li>
<li>2 ‚Äì major motion detected</li>
<li>3 ‚Äì major and minor motion detected</li>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_ENHANCED_PRESENCE_INDICATION</li>
<li>Length = sizeof(uint8_t) * (1 + celing(NumberOfZones/4))</li>
</ul>
<h3><a class="anchor" id="autotoc_md801"></a>
Stats TLV</h3>
<p>This TLV contains statistics described in the structure below.</p>
<ul>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_STATS</li>
<li>Length = sizeof(MmwDemo_output_message_stats)</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>MmwDemo_output_message_stats_t</div>
<div class="line">{</div>
<div class="line">uint32_t interFrameProcessingTime; <span class="comment">/* Interframe processing time in usec */</span></div>
<div class="line">uint32_t transmitOutputTime; <span class="comment">/* Transmission data transmit time in usec */</span></div>
<div class="line">uint16_t powerMeasured[4]; <span class="comment">/* Power at 1.8V, 3.3V, 1.2V and 1.2V RF rails(1LSB = 100 uW) */</span></div>
<div class="line">int16_t tempReading[4]; <span class="comment">/* Temperature: Rx, Tx, PM, DIG. (oC), 1LSB = 1oC */</span></div>
<div class="line">} MmwDemo_output_message_stats;</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md802"></a>
Group tracker data TLVs</h3>
<p>There are two TLV types associated with the tracking data:</p><ul>
<li>TLV with the list of tracking objects of the current frame, and</li>
<li>TLV with the target index array, the array indicating which tracking ID is assigned to the point-cloud point of the current frame.</li>
</ul>
<p>These two TLVs are sent together to the host when all of the following conditions are satisfied:</p><ul>
<li>the group tracker is enabled in the CLI command trackingCfg,</li>
<li>the tracking data enable bit is enabled in the CLI command guiMonitor,</li>
<li>the number of tracking objects in the current frame is greater than zero.</li>
</ul>
<h4><a class="anchor" id="autotoc_md803"></a>
List of tracking objects TLV</h4>
<ul>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_TARGET_LIST</li>
<li>Length = numTrackedObjects * sizeof(trackerProc_Target)</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>trackerProc_Target_t</div>
<div class="line">{</div>
<div class="line">uint32_t tid;</div>
<div class="line"><span class="keywordtype">float</span> posX;</div>
<div class="line"><span class="keywordtype">float</span> posY;</div>
<div class="line"><span class="keywordtype">float</span> posZ;</div>
<div class="line"><span class="keywordtype">float</span> velX;</div>
<div class="line"><span class="keywordtype">float</span> velY;</div>
<div class="line"><span class="keywordtype">float</span> velZ;</div>
<div class="line"><span class="keywordtype">float</span> accX;</div>
<div class="line"><span class="keywordtype">float</span> accY;</div>
<div class="line"><span class="keywordtype">float</span> accZ;</div>
<div class="line"><span class="keywordtype">float</span> ec[16];</div>
<div class="line"><span class="keywordtype">float</span> g;</div>
<div class="line"><span class="keywordtype">float</span> confidenceLevel;</div>
<div class="line">} <a class="code" href="structtrackerProc__Target.html">trackerProc_Target</a>;</div>
</div><!-- fragment --><p> The target coordinates are ‚Äúsensor‚Äù coordinates that could be converted to ‚Äúworld‚Äù coordinates on the Host side.</p>
<h4><a class="anchor" id="autotoc_md804"></a>
Group Tracker indices array TLV</h4>
<ul>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_TARGET_INDEX</li>
<li>Length = numberOfPoints * sizeof(uint8_t)</li>
</ul>
<h3><a class="anchor" id="autotoc_md805"></a>
Micro-Doppler TLV</h3>
<p>This TLV contains ¬µ-Doppler spectra of the tracked objects. Note that this TLV is sent to host when all of the following conditions are satisfied:</p><ul>
<li>the group tracker is enabled in the CLI command trackingCfg,</li>
<li>the ¬µ-Doppler DPU is enabled in the CLI command microDopplerCfg,</li>
<li>the tracking data enable bit is enabled in the CLI command guiMonitor,</li>
<li>the ¬µ-Doppler data enable bit is enabled in the CLI command guiMonitor,</li>
<li>the number of tracking objects in the current frame is greater than zero.</li>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_MICRO_DOPPLER_RAW_DATA</li>
<li>Length = numTrackedObjects * numDopplerBins * sizeof(float)</li>
</ul>
<p>Value = Array of ¬µ-Doppler spectra of the tracked targets, corresponding to target IDs sent in the tracker data TLV. The samples are stored in float format as dopplerData[targetIndex][DopplerIndex].</p>
<h3><a class="anchor" id="autotoc_md806"></a>
Features TLV</h3>
<p>This TLV contains features extracted from the ¬µ-Doppler FFT. It is sent out along with the ¬µ-Doppler TLV.</p>
<ul>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_MICRO_DOPPLER_FEATURES</li>
<li>Length = numTrackedObjects * numberOfFeatures * sizeof(float)</li>
</ul>
<p>Value = array of features sets, corresponding to target IDs sent in the tracker data TLV. The features are stored in a floating point format as features[targetIndex][featureIndex]</p>
<h3><a class="anchor" id="autotoc_md807"></a>
Classifier Output TLV</h3>
<p>This TLV is sent out when all of the following conditions are satisfied:</p><ul>
<li>the group tracker is enabled in the CLI command trackingCfg,</li>
<li>the ¬µ-Doppler DPU is enabled in the CLI command microDopplerCfg,</li>
<li>the classifier is enabled in the CLI command classifierCfg,</li>
<li>the classifier data enable bit is enabled in the CLI command guiMonitor,</li>
<li>the number of tracking objects in the current frame is greater than zero.</li>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_CLASSIFIER_INFO</li>
<li>Length = numTrackedObjects * CLASSIFIER_NUM_CLASSES * sizeof(uint8_t)</li>
</ul>
<p>Value = array of classifier outcome in Q7 format, packed as classOutcome[targetIndex][classIndex]</p>
<h3><a class="anchor" id="autotoc_md808"></a>
Quick-Eval TLV</h3>
<p>This TLV contains the presence info and is not useful without it being enabled.</p>
<ul>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_QUICK_EVAL_INFO</li>
<li>Length = sizeof(uint8_t) + sizeof(sceneryParams)</li>
</ul>
<h3><a class="anchor" id="autotoc_md809"></a>
Rx channel compensation measurement output TLV</h3>
<p>This TLV contains the output of Rx channel compensation measurement procedure.</p>
<ul>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_RX_CHAN_COMPENSATION_INFO</li>
<li>Length = sizeof(DPU_DoaProc_compRxChannelBiasFloatCfg)</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>DPU_DoaProc_compRxChannelBiasFloatCfg_t</div>
<div class="line">{</div>
<div class="line"><span class="keywordtype">float</span> rangeBias;</div>
<div class="line"><span class="keywordtype">float</span> rxChPhaseComp[2 * SYS_COMMON_NUM_TX_ANTENNAS * SYS_COMMON_NUM_RX_CHANNEL];</div>
<div class="line">} <a class="code" href="structDPU__DoaProc__compRxChannelBiasFloatCfg.html">DPU_DoaProc_compRxChannelBiasFloatCfg</a>;</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md810"></a>
Antenna symbols TLV</h3>
<p>This TLV contains the Antenna symbols per detected point</p>
<ul>
<li>Type = MMWDEMO_OUTPUT_EXT_MSG_POINT_CLOUD_ANTENNA_SYMBOLS</li>
<li>Length = sizeof (<a class="el" href="structDPU__AoasvcProc__VirtualAntennaElements.html">DPU_AoasvcProc_VirtualAntennaElements</a>) x numberOfPoints</li>
</ul>
<h1><a class="anchor" id="autotoc_md811"></a>
Low Power Configuration (lowPowerCfg = 1)</h1>
<h2><a class="anchor" id="autotoc_md812"></a>
Flow Diagram</h2>
<p>Below is the high level flow diagram of Motion and Presence detection OOB demo in Low Power Mode:  <style>div.image img[src="motiondet_demo_flow_lp.png"]{width:30%}</style> </p><div class="image">
<img src="motiondet_demo_flow_lp.png" alt=""/>
<div class="caption">
Flow in Low Power Mode</div></div>
<h2><a class="anchor" id="autotoc_md813"></a>
Threshold and Latency time duration for Power module</h2>
<p>Syscfg of Power driver provides some options to be configured by user as per their demo implementations:</p>
<p><b>Threshold Value</b> The idle time available only after which entry to various power modes is considered. This is upto the user to configure based on their system requirements.<br  />
 <b>Latency Value:</b> There is a latency for the device to transition into the different low power modes, and to wake up from that specific low power mode to resume activity. The actual transition latency will depend upon overall device state, as well as execution of notification functions that are registered with the Power driver. User is expected to measure this in their implementations and configure this value. If there is Xms idle time, device will get into low power state for (X - Latency value) time duration.</p>
<p>Threshold and latency values can be changed (tuned) to meet specific application requirements. Threshold and Latency values for different power modes can be configured in Power Syscfg: <br  />
</p>
<p> <style>div.image img[src="lpds_values.png"]{width:45%}</style> </p><div class="image">
<img src="lpds_values.png" alt=""/>
<div class="caption">
THRESHOLD AND LATENCY VALUES OF DIFFERENT POWER MODES</div></div>
<p> <br  />
 <br  />
</p>
<p>Enabling wake-up sources from LPDS state: Wake-up from Deep sleep exit is provisioned in the device through a number of external wakeup sources like UART/SPI/GPIO/SYNC_IN/Sleep counter, etc. By Default, wake-up using Sleep Counter is enabled in Demo.</p>
<p> <style>div.image img[src="wakeup_sources_lpds.png"]{width:45%}</style> </p><div class="image">
<img src="wakeup_sources_lpds.png" alt=""/>
<div class="caption">
LPDS WAKEUP SOURCES</div></div>
<p> <br  />
 <br  />
</p>
<h1><a class="anchor" id="autotoc_md814"></a>
Raw ADC data streaming</h1>
<h2><a class="anchor" id="autotoc_md815"></a>
Steps for DCA based streaming</h2>
<p>MMWAVE-L-SDK OOB (out-of-box) demo supports raw ADC data streaming through the RDIF interface. When the radar EVM board connected with the DCA1000EVM board, users can use the DCA1000EVM CLI application to capture the raw data without starting the mmWaveStudio GUI interface. The DCA1000EVM CLI application is primarily a command line tool for configuration of FPGA and recording based on the user inputs. The DCA1000EVM CLI application connects to DCA1000EVM system through 1GB Ethernet for configuration and recording of data. RADAR EVM is connected to DCA1000EVM for data capture and connected to PC for configuration of data generation. However, there are some important limitations associated with this feature:</p><ul>
<li>Do not use this feature when Low power mode is enabled (lowPowerCfg 1).</li>
</ul>
<p>The DCA1000EVM CLI application is provided for Windows and can be recompiled for other platforms. Users can find the source code and user guide in MMWAVE-STUDIO release package.</p>
<p>The DCA1000EVM CLI application has the following functionalities.</p><ul>
<li>CLI application parses the parameters in JSON formatted config file for the corresponding CLI Control commands.</li>
<li>CLI application supports both Windows and Linux.</li>
<li>Acknowledgement of commands and error codes are handled and returned by the CLI application.</li>
<li>The response status of each of the command is captured in a log file by the CLI application.</li>
<li>CLI application supports running as a foreground as well as a background process.</li>
</ul>
<h3><a class="anchor" id="autotoc_md816"></a>
DCA1000EVM Setup</h3>
<ul>
<li>DCA1000EVM should be connected to Host PC via Ethernet cable to access the CLI and Data Transfer process.</li>
<li>DCA1000EVM should be connected to TI Radar EVM via 60 pin HD Connector by using 60 pin Samtec ribbon cable.</li>
<li>DCA1000EVM power input should be connected either from DC Jack or TI Radar EVM power output (from 60 pin HD connector) by selecting the switch SW3.</li>
<li>Follow the mmWave Studio for additional RADAR EVM connectivity to PC and other pre-requisites.</li>
<li>Refer <b>TI_DCA1000EVM_quickStartGuide.pdf</b> document for more details.</li>
</ul>
<h3><a class="anchor" id="autotoc_md817"></a>
Power on/off sequence</h3>
<p>Initiate the power on sequence by turning on the radar EVM first, followed by the DCA1000EVM board. For shutdown, power off the DCA1000EVM board first, and then the radar EVM board.</p>
<h3><a class="anchor" id="autotoc_md818"></a>
Steps to Perform Raw ADC Data Streaming</h3>
<p>For successful recording of data from RADAR EVM sequence is given as follows</p>
<ul>
<li>Configure FPGA<ul>
<li>Ensure JSON config file (CLI) and Script config file (RADAR EVM) data format mode are in sync</li>
<li>Run the command - DCA1000EVM_CLI_Control.exe fpga configFile.json (located in mmWaveStudio/PostProc)</li>
<li>The acknowledgement for the above command is shown below  <style>div.image img[src="dca1000_cfg.png"]{width:50%}</style> <div class="image">
<img src="dca1000_cfg.png" alt=""/>
</div>
</li>
</ul>
</li>
<li>Start the record<ul>
<li>Ensure JSON config file (CLI) and Script config file (RADAR EVM) data logging mode are in sync</li>
<li>Run the command - DCA1000EVM_CLI_Control.exe start_record configFile.json (located in mmWaveStudio/PostProc)</li>
<li>The acknowledgement for the above command is shown below  <style>div.image img[src="dca1000_logging.png"]{width:50%}</style> <div class="image">
<img src="dca1000_logging.png" alt=""/>
</div>
</li>
</ul>
</li>
<li>Run the demo immediately after the above command by using the configuration with "adcLoggging 1" to enable this feature.</li>
<li>When data transfer starts DATA_TRANS_PRG LED (LD1) on DCA1000EVM will start toggling.</li>
<li>After the Raw ADC Data capture it will get stored in a adc_data_Raw_0.bin file in PostProc folder. And CLI_LogFile.txt contains all the commands execution information along with the timestamp. It can be viewed manually whenever required. The file will be appended for new sessions and new command execution information.</li>
<li>FPGA should be reconfigured in the following scenarios<ul>
<li>When the system is booted or rebooted</li>
<li>When the FPGA or DCA1000EVM is reset</li>
</ul>
</li>
</ul>
<p><b>NOTE:</b> In order to capture raw data with sideband data enabled it is recommended to Set packetDelay_us = 5 in <b>${STUDIO_INSTALL_PATH}/mmWaveStudio/PostProc/cf.json</b>.</p>
<p>Refer <b>TI_DCA1000EVM_CLI_Software_UserGuide.pdf</b> document for more details.</p>
<h3><a class="anchor" id="autotoc_md819"></a>
Validation of the ADC data</h3>
<p>The path <b>${SDK_INSTALL_PATH}/tools/ADC_parser</b> includes parsing and post processing scripts for interpreting Raw ADC data acquired from the DCA1000EVM board.</p><ul>
<li>The ar_convertAdcData_xWRLx432.m takes the Raw adc dump as input and converts it into adc matrix.</li>
<li>In addition, a post processing script Test_read_adc_data_xWRLx432.m, has been included to invoke the above parsing script, compute 1D and 2D FFTs.</li>
<li>Raw ADC data post-processing script requires:<ul>
<li>Input Files:<ul>
<li>adc_data_Raw_0.bin</li>
<li>cli_configuration.cfg</li>
</ul>
</li>
<li>Configuration Parameters:<ul>
<li>adcLogging: 1=DCA RAW ADC capture, 2=SPI RAW ADC capture</li>
<li>sideband_data_present: 0=ADC data only, 1=ADC + sideband data</li>
<li>rdif_scrambler_en: 0=disabled, 1=enabled</li>
<li><b>NOTE:</b> Sideband data and RDIF scrambler mode are only supported when RAW ADC data is logged from DCA.</li>
</ul>
</li>
</ul>
</li>
<li>Update paths and variables in the post-processing script accordingly and run the script as shown below:  <style>div.image img[src="matlab_ss.png"]{width:60%}</style> <div class="image">
<img src="matlab_ss.png" alt=""/>
</div>
</li>
<li>The FFT peaks are a means of validating the captured raw adc data. For example, a corner reflector is placed at 1m along the boresight of the radar. Assuming an FFT bin resolution of 0.1m/bin (derived based on chirping params), the 1D FFT peak falls at 10th bin.</li>
<li>To ensure that the side band data is correct, parse the data with sideband using the above post processing script, once the script has been run the data can be validated as follows: In the workspace access the cp variable to verify data as shown.</li>
</ul>
<p> <style>div.image img[src="workspace.png"]{width:40%}</style> </p><div class="image">
<img src="workspace.png" alt=""/>
</div>
<ul>
<li>If chirps and frames are incrementing then data is correct as below.  <style>div.image img[src="sideband_correct.png"]{width:38%}</style> <div class="image">
<img src="sideband_correct.png" alt=""/>
</div>
</li>
<li>And below is an example of corrupted data  <style>div.image img[src="sideband_incorrect.png"]{width:38%}</style> <div class="image">
<img src="sideband_incorrect.png" alt=""/>
</div>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md820"></a>
SPI based streaming of Raw ADC Data</h2>
<p>The Motion and Presence Detect Demo supports streaming of raw ADC data over SPI interface every frame during the frame idle time. However, there are some important things associated with this feature which user should ensure before performing the capture:</p>
<ul>
<li>User has to ensure that sufficient memory is available to store Raw ADC Data required per frame.</li>
<li>ADC data of every frame is transmitted during frame idle time. User has to ensure that sufficient frame idle time is available to transmit all the data by using proper frame periodicity in their config.</li>
<li>Use this feature with Low power mode disabled (lowPowerCfg 0).</li>
<li>This feature uses FTDI USB to SPI converter chips like FT232H, FT4232H etc. to transfer data from SPI interface of xWRL1432 to Host. If EVMs have these FTDI chips on them, user can use those, if not external converters have to be connected. Here the FTDI chip acts as SPI master and xWRL1432 acts as Slave device. SPI_busy signal is used as means of synchronization between FTDI chip and xWRL1432 device.</li>
</ul>
<h3><a class="anchor" id="autotoc_md821"></a>
Building the demo with this feature enabled</h3>
<p>Demos in SDK have this feature disabled by default. Follow below steps to enable this feature in demo.</p>
<ul>
<li>Enable the "ADC STREAMING via SPI" feature in "TI Demo" tab of demo Sysconfig.</li>
<li>"ADC_DATA_BUFF_MAX_SIZE" in "mmw_cli.h" file defines the size of buffer that holds ADC data of every frame. User is expected to update this macro based on the configurations being used. This size is "Number of RX antennas used X Number of Chirps per Frame X Number of ADC Samples per Chirp X Number of bytes per ADC Sample". Also, user has to work on linker scipt if required to get this buffer memory allocated and has to ensure that demo builds.</li>
<li>Rebuild the demo. Flash the appimage.</li>
</ul>
<h3><a class="anchor" id="autotoc_md822"></a>
Steps to Perform Raw ADC Data Streaming on xWRL1432 FCCSP device</h3>
<ul>
<li>FCCSP EVM does not have on board SPI FTDI chip. User has to use external converter cable. We show the usage with C232HM-DDHSL-0 cable here (FT232H device) (<a href="https://ftdichip.com/products/c232hm-ddhsl-0-2/">https://ftdichip.com/products/c232hm-ddhsl-0-2/</a>). Please use C232HM-DDHSL-0 external cable or any FT232H device only. We can use other FTDI SPI-to-USB interface cable and chip but that needs to have MPSSE engine, also it may require different configuration for GPIO read. That's why It is preferable to use FT232H device only.</li>
</ul>
<p> <style>div.image img[src="C232HM-DDHSL-0_color_code.png"]{width:40%}</style> </p><div class="image">
<img src="C232HM-DDHSL-0_color_code.png" alt=""/>
<div class="caption">
C232HM-DDHSL-0 Cable SPI Wire Description</div></div>
<ul>
<li>Connection Table of SPI Interface of xWRL1432 with C232HM-DDHSL-0 Cable</li>
</ul>
<table class="doxtable">
<tr>
<th>XWRLx4XX FCCSP Device </th><th>C232HM-DDHSL-0 Cable  </th></tr>
<tr>
<td>MOSI </td><td>YELLOW WIRE  </td></tr>
<tr>
<td>MISO </td><td>GREEN WIRE  </td></tr>
<tr>
<td>CHIP SELECT </td><td>BROWN WIRE  </td></tr>
<tr>
<td>SPI CLOCK </td><td>ORANGE WIRE  </td></tr>
<tr>
<td>SPI BUSY </td><td>GREY WIRE  </td></tr>
<tr>
<td>GROUND </td><td>BLACK WIRE  </td></tr>
</table>
<p><br  />
</p>
<ul>
<li>Ensure that switch S1.1 and S1.6 is ON.</li>
<li>Setup Teraterm and send the configuration, change only two Config commands in the configuration, i.e. Change "lowPowerCfg 1" to lowPowerCfg 0" to make the low power mode disabled and change the "adcLogging 0" to "adcLogging 2" to enable this feature.</li>
<li>Do not press enter after sensor start command.</li>
</ul>
<p> <style>div.image img[src="Tera_term_spi_commands.png"]{width:60%}</style> </p><div class="image">
<img src="Tera_term_spi_commands.png" alt=""/>
<div class="caption">
Stop at the sensor start command</div></div>
<ul>
<li>Configure the FTDI chip to tranfer data to the Host.</li>
<li>To configure the FTDI chip, Run the adcDataSPIFTDI.exe application located in tools/spi_adc_streaming folder.</li>
<li>Give all the inputs to adcDataSPIFTDI application like Device Type, Number of ADC samples, Number of chiprs in burst, Number of burst in frame, Number of Frames, Number of Rx Antennas as given in configuration file. Ensure that this is done before "sensorStart" command is sent.</li>
</ul>
<p> <style>div.image img[src="adc_spi_exe.png"]{width:60%}</style> </p><div class="image">
<img src="adc_spi_exe.png" alt=""/>
<div class="caption">
Configuring adcDataSPIFTDI.exe</div></div>
<ul>
<li>After configuring the FTDI chip, send the Sensor Start command and Demo will start, Raw ADC Data for given number of frames will get stored in a adcData.txt file in spi_adc_streaming folder.</li>
<li>After getting all the data, you should see "Press Any key to Exit" text in adcDataSPIFTDI.exe. Close the adcDataSPIFTDI.exe application before opening the adcData.txt file.</li>
</ul>
<p> <style>div.image img[src="Close_the_exe.png"]{width:60%}</style> </p><div class="image">
<img src="Close_the_exe.png" alt=""/>
<div class="caption">
Configuring adcDataSPIFTDI.exe</div></div>
<h3><a class="anchor" id="autotoc_md823"></a>
Validation of the ADC data</h3>
<p>The path <b>${SDK_INSTALL_PATH}/tools/ADC_parser</b> includes parsing and post processing scripts for interpreting Raw ADC data acquired through SPI.</p><ul>
<li>The SPI based adc data is input as a .txt file along with the corresponding cli.cfg file.</li>
<li>The above file paths can be updated in the post processing script Test_read_adc_data_xWRLx432.m, to compute 1D and 2D FFTs.</li>
<li>The FFT peaks are a means of validating the captured raw adc data. For example, a corner reflector is placed at 1m along the boresight of the radar. Assuming an FFT bin resolution of 0.1m/bin (derived based on chirping params), the 1D FFT peak falls at 10th bin.</li>
</ul>
<h1><a class="anchor" id="autotoc_md824"></a>
Steering Vector Tool Usage</h1>
<p>The <code>generateSteeringVectors.exe</code> tool at <b>${SDK_INSTALL_PATH}/tools/steeringvector_generation_tool/v0</b> processes a CLI configuration file (<code>.cfg</code>) and generates steering vectors corresponding to the start frequency and bandwidth specified in the input configuration file.</p>
<h2><a class="anchor" id="autotoc_md825"></a>
Running the Tool</h2>
<ol type="1">
<li>Open Command Prompt</li>
<li>Navigate to the folder containing the executable (<b>${SDK_INSTALL_PATH}/tools/steeringvector_generation_tool/v0</b>)</li>
<li>Run with arguments:</li>
</ol>
<ul>
<li>generateSteeringVectors.exe &ndash;filename "path\to\config.cfg" &ndash;azimSpacing 2.5 &ndash;elevSpacing 5</li>
</ul>
<p><b>Note:</b> If the path contains spaces, enclose it in quotes as shown above.</p>
<h2><a class="anchor" id="autotoc_md826"></a>
Input Parameters</h2>
<p>The tool takes the following inputs:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Parameter  </th><th class="markdownTableHeadNone">Required  </th><th class="markdownTableHeadNone">Default  </th><th class="markdownTableHeadNone">Description   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--filename</code>  </td><td class="markdownTableBodyNone">Yes  </td><td class="markdownTableBodyNone">‚Äî  </td><td class="markdownTableBodyNone">Path to the CLI configuration file.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>--azimSpacing</code>  </td><td class="markdownTableBodyNone">No  </td><td class="markdownTableBodyNone">2.5  </td><td class="markdownTableBodyNone">Angular spacing (in degrees) between azimuth steering vectors.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>--elevSpacing</code>  </td><td class="markdownTableBodyNone">No  </td><td class="markdownTableBodyNone">5  </td><td class="markdownTableBodyNone">Angular spacing (in degrees) between elevation steering vectors.   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md827"></a>
Output</h2>
<p>On successful execution, the tool generates a <code>.c</code> file containing the steering vectors for the configured input. <br  />
 The output file is named as: <code>aoasv_table_6432.c</code> and is saved in the same location as the tool. Copy the contents of this file to <b>${SDK_INSTALL_PATH}/source/datapath/dpu/aossvcproc/v0/aoasv_table.c</b>, rebuild the datapath libraries and application.</p>
<h2><a class="anchor" id="autotoc_md828"></a>
Examples</h2>
<h3><a class="anchor" id="autotoc_md829"></a>
Example 1: Basic Usage</h3>
<ul>
<li>generateSteeringVectors.exe &ndash;filename "config.cfg"</li>
</ul>
<h3><a class="anchor" id="autotoc_md830"></a>
Example 2: Custom Spacing</h3>
<ul>
<li>generateSteeringVectors.exe &ndash;filename "config.cfg" &ndash;azimSpacing 5 &ndash;elevSpacing 5</li>
</ul>
<h2><a class="anchor" id="autotoc_md831"></a>
Troubleshooting</h2>
<ul>
<li>If you encounter <b>path-related errors</b>, use <b>absolute paths</b> for the config file.</li>
<li>Ensure the <code>.cfg</code> file is properly formatted.</li>
<li>For <b>relative paths</b>, ensure they are relative to the location of the executable.</li>
</ul>
<h1><a class="anchor" id="autotoc_md832"></a>
Running in test mode</h1>
<p>For testing the signal processing chain, the source for the ADC samples can be configured to be the input file, instead of RF input stream, as shown in Figure below. This mode is enabled using a CLI command adcDataSource which specifies the input binary ADC data file. Note that this mode can run when the code is loaded through CCS. In this mode the RF part of the SOC is not configured.</p>
<p> <style>div.image img[src="mpd_adcdata.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_adcdata.png" alt=""/>
<div class="caption">
Reading ADC data from file</div></div>
<p>In this mode demo is controlled form the ADC read data task mmwDemo_adcFileReadTask(), that reads data from the file, and triggers the input EDMA of the range DPU. This task also saves the point cloud and the range azimuth heat map to files.</p>
<p>The timing diagram is illustrated below.</p>
<p> <style>div.image img[src="mpd_adc_timing_diagram.png"]{width:80%}</style> </p><div class="image">
<img src="mpd_adc_timing_diagram.png" alt=""/>
<div class="caption">
Timing diagram in demo test mode - ADC samples read from file.</div></div>
<h1><a class="anchor" id="autotoc_md833"></a>
Steps to Run Monitors</h1>
<p>Please refer to <a class="el" href="MONITORS.html">Monitors</a> for steps to run monitors</p>
<h1><a class="anchor" id="autotoc_md834"></a>
Steps to Run the Example</h1>
<ul>
<li><b>When using CCS projects to build</b>, import the CCS project for the required combination and build it using the CCS project menu (see <a class="el" href="CCS_PROJECTS_PAGE.html">Using SDK with CCS Projects</a>).</li>
<li><b>When using makefiles to build</b>, note the required combination and build using make command (see <a class="el" href="MAKEFILE_BUILD_PAGE.html">Using SDK with Makefiles</a>)</li>
<li>Launch a CCS debug session and run the executable, see <a class="el" href="CCS_LAUNCH_PAGE.html">CCS Launch, Load and Run</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md835"></a>
Power Measurements with INA228</h1>
<p>Following are power numbers with SDK default configurations measured using INA228 sensor.</p>
<table class="doxtable">
<tr>
<th>Configuration </th><th>Average Power (mW)  </th></tr>
<tr>
<td>High Performance Motion Detection </td><td>31.5  </td></tr>
<tr>
<td>Low Power Presence Detection </td><td>8.7  </td></tr>
<tr>
<td>Object Tracking </td><td>80.5  </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md836"></a>
Memory Usage</h1>
<p>The OOB motion detection demo memory usage can always be found in the MAP file. The current usage is shown in Table below.</p>
<p> <style>div.image img[src="mpd_mem_usage.png"]{width:15%}</style> </p><div class="image">
<img src="mpd_mem_usage.png" alt=""/>
<div class="caption">
Motion detection OOB demo memory usage</div></div>
<p>Some of the data arrays are dynamically handled using a set of simple memory allocation utility functions, provided below.</p>
<p> <style>div.image img[src="mpd_mem_func.png"]{width:50%}</style> </p><div class="image">
<img src="mpd_mem_func.png" alt=""/>
<div class="caption">
Memory allocation functions</div></div>
<p>Two memory heaps are created, one in the local core memory, gMmwCoreLocMem[28*1024], and the other, gMmwL3[416K], occupying 256KB shared memory of APPSS and 160KB shared memory of HWASS. Currently less than one 1kB of memory is allocated in the local core RAM.</p>
<p>In addition to the above local core memory heap, two more memory heaps objects are created in gMmwCoreLocMem2[25*1024] and gMmwCoreLocMem3[2*1024] using the free RTOS memory heap management scheme. The former is used for the tracker and the latter is used for the feature extraction and for the classifier.</p>
<p>The usage of the shared memory depends on the configuration. At the start time, after the CLI commands has been received and configuration completed, memory usage of these two heaps is printed out on the console.</p>
<p>The memory usage for the CLI configurations files provided in this SDK release is shown in Tables below. (The configuration files are located in examples/mmw_demo/motion_and_presence_detection/profiles.)</p>
<p> <style>div.image img[src="mpd_majormotion_size.png"]{width:50%}</style> </p><div class="image">
<img src="mpd_majormotion_size.png" alt=""/>
<div class="caption">
Memory usage ‚Äì dynamic allocation in major motion mode, (configuration file: MotionDetect.cfg).</div></div>
<p> <style>div.image img[src="mpd_minormotion_size.png"]{width:50%}</style> </p><div class="image">
<img src="mpd_minormotion_size.png" alt=""/>
<div class="caption">
Memory usage - dynamic allocation in minor motion detection mode, (configuration file: PresenceDetect.cfg).</div></div>
<p> <style>div.image img[src="mpd_automode_size.png"]{width:50%}</style> </p><div class="image">
<img src="mpd_automode_size.png" alt=""/>
<div class="caption">
Memory usage - dynamic allocation in auto motion detection mode, with tracker and classifier, (configuration file: TrackingClassification_MidBw.cfg).</div></div>
<p> <style>div.image img[src="mpd_automode_hibw_size.png"]{width:50%}</style> </p><div class="image">
<img src="mpd_automode_hibw_size.png" alt=""/>
<div class="caption">
Memory usage - dynamic allocation in auto motion detection mode, with tracker and classifier, (configuration file: TrackingClassification_HighBw_4Ant.cfg).</div></div>
 </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="astructDPU__DoaProc__compRxChannelBiasFloatCfg_html"><div class="ttname"><a href="structDPU__DoaProc__compRxChannelBiasFloatCfg.html">DPU_DoaProc_compRxChannelBiasFloatCfg</a></div><div class="ttdoc">Range Bias and rx channel gain/phase compensation configuration.</div><div class="ttdef"><b>Definition:</b> doaproc.h:474</div></div>
<div class="ttc" id="astructtrackerProc__Target_html"><div class="ttname"><a href="structtrackerProc__Target.html">trackerProc_Target</a></div><div class="ttdoc">Structure holds the target features.</div><div class="ttdef"><b>Definition:</b> trackerproc.h:234</div></div>
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
